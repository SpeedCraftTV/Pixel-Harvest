<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Harvest - 3D Farming Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            max-width: 300px;
        }
        
        #score {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 16px;
            opacity: 0.9;
            max-width: 300px;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        #plantSelector {
            position: absolute;
            top: 20px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 180px;
        }

        .plant-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .plant-btn:hover {
            background: #45a049;
        }

        .plant-btn.selected {
            background: #2196F3;
        }

        #marketplace {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .market-category {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .market-category:last-child {
            border-bottom: none;
        }

        .market-category h3 {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .market-btn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .market-btn:hover {
            background: #e68900;
        }

        #objectives {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 180px;
            overflow-y: auto;
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            min-width: 400px;
            display: none;
            border: 2px solid #4CAF50;
        }

        #settingsMenu h2 {
            margin-top: 0;
            text-align: center;
            color: #4CAF50;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .control-label {
            font-weight: bold;
            min-width: 120px;
        }

        .key-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            min-width: 60px;
        }

        .key-button:hover {
            background: #1976D2;
        }

        .key-button.recording {
            background: #FF5722;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .preset-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .preset-btn:hover {
            background: #7B1FA2;
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .menu-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .menu-btn:hover {
            background: #45a049;
        }

        .cancel-btn {
            background: #f44336;
        }

        .cancel-btn:hover {
            background: #da190b;
        }

        #settingsButton {
            position: absolute;
            top: 20px;
            right: 280px;
            z-index: 100;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #settingsButton:hover {
            background: #45a049;
        }
        
        #newGameButton {
            position: absolute;
            top: 20px;
            right: 410px;
            z-index: 100;
            background: #FF5722;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #newGameButton:hover {
            background: #D84315;
        }
        
        #canvas {
            display: block;
            border: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        #dayNightIndicator {
            position: absolute;
            top: 20px;
            right: 530px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Weather and Season Panels */
        #weatherPanel {
            position: absolute;
            top: 80px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 2px solid #87CEEB;
        }

        #seasonPanel {
            position: absolute;
            top: 80px;
            left: 570px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 180px;
            border: 2px solid #32CD32;
        }

        /* Animals Panel */
        #animalsPanel {
            position: absolute;
            top: 280px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 280px;
            max-height: 280px;
            overflow-y: auto;
            border: 2px solid #FFD700;
        }

        /* Daily Quests Panel */
        #questsPanel {
            position: absolute;
            top: 280px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            max-height: 280px;
            overflow-y: auto;
            border: 2px solid #FF6347;
        }

        .weather-icon {
            font-size: 32px;
            text-align: center;
            margin-bottom: 10px;
        }

        .season-icon {
            font-size: 32px;
            text-align: center;
            margin-bottom: 10px;
        }

        .animal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .animal-btn {
            background: #FFD700;
            color: black;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 5px;
        }

        .animal-btn:hover {
            background: #FFA500;
        }

        .animal-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        .quest-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #FF6347;
        }

        .quest-completed {
            border-left-color: #4CAF50;
            opacity: 0.7;
        }

        .quest-progress {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
            margin: 5px 0;
            overflow: hidden;
        }

        .quest-progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .weather-effect {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        /* Responsive layout for smaller screens */
        @media (max-width: 1200px) {
            #weatherPanel, #seasonPanel {
                display: none; /* Hide on smaller screens to prevent overlap */
            }
            
            #dayNightIndicator {
                right: 20px; /* Move back to original position when panels are hidden */
            }
        }

        @media (max-width: 800px) {
            #animalsPanel, #questsPanel {
                position: relative;
                width: 90%;
                margin: 10px auto;
                top: auto;
                left: auto;
                right: auto;
                max-height: 200px;
            }
            
            #ui, #plantSelector, #objectives, #marketplace, #inventory {
                position: relative;
                width: 90%;
                margin: 10px auto;
                top: auto;
                left: auto;
                right: auto;
            }
        }

        @media (max-height: 600px) {
            #animalsPanel, #questsPanel, #objectives, #marketplace {
                max-height: 150px;
            }
        }

        /* Draggable and Resizable Panel Styles */
        .draggable-panel {
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
            resize: both;
            overflow: auto;
            min-width: 150px;
            min-height: 100px;
        }

        .draggable-panel:hover {
            border-color: rgba(76, 175, 80, 0.5);
        }

        .draggable-panel.dragging {
            border-color: #4CAF50;
            z-index: 1000;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 25px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.8), rgba(67, 160, 71, 0.8));
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .draggable-panel:hover .drag-handle {
            opacity: 1;
            visibility: visible;
        }

        .draggable-panel.dragging .drag-handle {
            opacity: 1;
            visibility: visible;
        }

        .drag-handle::before {
            content: "‚ãÆ‚ãÆ‚ãÆ";
            font-size: 16px;
            line-height: 1;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: se-resize;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            background: linear-gradient(135deg, transparent 40%, rgba(76, 175, 80, 0.8) 40%);
            border-radius: 0 0 8px 0;
        }

        .draggable-panel:hover .resize-handle {
            opacity: 1;
            visibility: visible;
        }

        .resize-handle::after {
            content: "";
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-bottom: 8px solid rgba(255, 255, 255, 0.8);
        }

        .ui-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: #673AB7;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .ui-mode-toggle:hover {
            background: #5E35B1;
        }

        .ui-mode-toggle.active {
            background: #4CAF50;
        }

        .panel-content {
            padding-top: 10px;
        }

        /* Adjust existing panels to work with draggable system */
        .draggable-panel .drag-handle + * {
            margin-top: 25px;
        }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 160px;
            background: rgba(0, 0, 0, 0.1);
            pointer-events: none;
            z-index: 200;
            display: none;
        }

        .mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            pointer-events: all;
            touch-action: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.1s ease;
        }

        .mobile-joystick:active,
        .mobile-joystick.active {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(76, 175, 80, 0.6);
            transform: scale(1.05);
        }

        .mobile-joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .mobile-joystick.active .mobile-joystick-handle {
            background: rgba(76, 175, 80, 0.9);
            border-color: rgba(76, 175, 80, 0.8);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .mobile-action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: all;
            z-index: 201;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(76, 175, 80, 1);
        }

        .mobile-btn.secondary {
            background: rgba(33, 150, 243, 0.9);
        }

        .mobile-btn.secondary:active {
            background: rgba(33, 150, 243, 1);
        }

        .mobile-camera-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 10px;
            pointer-events: all;
            z-index: 201;
        }

        .mobile-camera-btn {
            width: 50px;
            height: 50px;
            background: rgba(156, 39, 176, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .mobile-camera-btn:active {
            transform: scale(0.95);
            background: rgba(156, 39, 176, 1);
        }

        /* Mobile Navigation Menu */
        #mobileNavMenu {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 300;
            background: rgba(0, 0, 0, 0.9);
            border-radius: 25px;
            padding: 15px;
            display: none;
            flex-direction: row;
            gap: 10px;
            border: 2px solid #4CAF50;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .mobile-nav-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .mobile-nav-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .mobile-nav-btn.active {
            background: linear-gradient(135deg, #2196F3, #1976D2);
        }

        .mobile-nav-btn .badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #FF5722;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* Mobile Panel System */
        .mobile-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.95);
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            padding: 20px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 350;
            max-height: 60vh;
            overflow-y: auto;
            border-top: 3px solid #4CAF50;
        }

        .mobile-panel.active {
            transform: translateY(0);
        }

        .mobile-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .mobile-panel-title {
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .mobile-panel-close {
            background: #f44336;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .mobile-panel-close:active {
            transform: scale(0.95);
        }

        .mobile-panel-content {
            color: white;
        }

        /* Mobile Grid Layout */
        .mobile-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .mobile-grid-item {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(76, 175, 80, 0.3);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }

        .mobile-grid-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #4CAF50;
        }

        .mobile-grid-item:active {
            transform: scale(0.95);
            background: rgba(76, 175, 80, 0.4);
        }

        .mobile-grid-item.selected {
            background: rgba(76, 175, 80, 0.3);
            border-color: #4CAF50;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        .mobile-grid-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mobile-grid-item .emoji {
            font-size: 24px;
            margin-bottom: 5px;
        }

        .mobile-grid-item .name {
            font-size: 12px;
            font-weight: bold;
        }

        .mobile-grid-item .count {
            font-size: 10px;
            opacity: 0.8;
        }

        .mobile-grid-item .price {
            font-size: 11px;
            color: #FFD700;
        }

        /* Responsive Typography */
        @media (max-width: 480px) {
            .mobile-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
                gap: 10px;
            }
            
            .mobile-grid-item {
                padding: 10px;
                min-height: 70px;
            }
            
            .mobile-grid-item .emoji {
                font-size: 20px;
            }
        }

        /* Mobile responsive improvements */
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            #mobileNavMenu {
                display: flex;
            }

            /* Hide desktop panels on mobile */
            #ui, #plantSelector, #inventory, #marketplace, #objectives, #animalsPanel, #questsPanel {
                display: none !important;
            }

            /* Hide some less critical panels on mobile to reduce clutter */
            #weatherPanel, #seasonPanel {
                display: none !important;
            }

            /* Adjust top buttons for mobile */
            #settingsButton, #newGameButton, #uiModeToggle {
                display: none !important;
            }

            /* Adjust day/night indicator */
            #dayNightIndicator {
                position: fixed;
                top: 10px;
                left: 10px;
                font-size: 16px;
                z-index: 150;
                background: rgba(0, 0, 0, 0.7);
                padding: 8px 12px;
                border-radius: 8px;
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            /* Mobile Menu Button */
            #unifiedMenu {
                position: fixed;
                top: 10px;
                right: 10px;
                z-index: 150;
            }

            #mainMenuButton {
                padding: 8px 12px;
                font-size: 14px;
                border-radius: 8px;
                background: #4CAF50;
                border: 2px solid #45a049;
            }

            /* Enhanced mobile controls */
            .mobile-joystick {
                width: 100px;
                height: 100px;
                bottom: 25px;
                left: 25px;
            }

            .mobile-joystick-handle {
                width: 35px;
                height: 35px;
            }

            .mobile-action-buttons {
                bottom: 25px;
                right: 25px;
                gap: 8px;
            }

            .mobile-btn {
                width: 55px;
                height: 55px;
                font-size: 22px;
            }

            .mobile-camera-controls {
                top: 60px;
                gap: 8px;
            }

            .mobile-camera-btn {
                width: 45px;
                height: 45px;
                font-size: 16px;
            }

            /* Touch-friendly scrollbars */
            .mobile-panel::-webkit-scrollbar {
                width: 8px;
            }

            .mobile-panel::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
            }

            .mobile-panel::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 4px;
            }

            .mobile-panel::-webkit-scrollbar-thumb:active {
                background: rgba(255, 255, 255, 0.5);
            }
        }

        @media (max-height: 600px) {
            #mobileControls {
                height: 120px;
            }

            .mobile-joystick {
                width: 100px;
                height: 100px;
            }

            .mobile-joystick-handle {
                width: 35px;
                height: 35px;
            }

            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            /* Further reduce panel heights on very short screens */
            #ui, #plantSelector, #inventory, #marketplace, #objectives, #animalsPanel, #questsPanel {
                max-height: 30vh;
            }
        }

        /* Touch feedback animations */
        @keyframes touchFeedback {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: rgba(76, 175, 80, 1); }
            100% { transform: scale(1); }
        }

        .mobile-btn.touched {
            animation: touchFeedback 0.2s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="loading" id="loading">Loading Pixel-Harvest...</div>
        <div id="ui" style="display: none;">
            <div id="score">Score: 0</div>
            <div id="instructions">
                üå± Move with WASD or arrow keys<br>
                ‚ö° SPACE to plant/harvest at closest plot<br>
                üíß E to water plants<br>
                üìπ C to toggle camera mode<br>
                üåø Plants grow automatically (3 stages)<br>
                üîí Unlock plots by getting close and pressing SPACE<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view<br>
                üîç Scroll wheel to zoom in/out
            </div>
        </div>
        <div id="plantSelector" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;"></div>
            <button class="plant-btn selected" data-plant="carrot">ü•ï <span data-plant-name="carrot">Carrot</span> (<span data-seed-count="carrot">5</span>)</button><br>
            <button class="plant-btn" data-plant="tomato">üçÖ <span data-plant-name="tomato">Tomato</span> (<span data-seed-count="tomato">2</span>)</button><br>
            <button class="plant-btn" data-plant="rare">‚ú® <span data-plant-name="rare">Rare Plant</span> (<span data-seed-count="rare">1</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="potato">ü•î <span data-plant-name="potato">Potato</span> (<span data-seed-count="potato">3</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="cabbage">ü•¨ <span data-plant-name="cabbage">Cabbage</span> (<span data-seed-count="cabbage">2</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="corn">üåΩ <span data-plant-name="corn">Corn</span> (<span data-seed-count="corn">1</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="watermelon">üçâ <span data-plant-name="watermelon">Watermelon</span> (<span data-seed-count="watermelon">1</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="pumpkin">üéÉ <span data-plant-name="pumpkin">Pumpkin</span> (<span data-seed-count="pumpkin">2</span>) ‚ùÑÔ∏è</button><br>
            <button class="plant-btn" data-plant="apple">üçé <span data-plant-name="apple">Apple Tree</span> (<span data-seed-count="apple">1</span>) ‚ùÑÔ∏è</button>
            <div class="coins-display" style="font-size: 12px; margin-top: 10px; opacity: 0.8;">
                üí∞ Coins: <span id="coins">50</span>
            </div>
        </div>
        <div id="inventory" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üì¶ Inventory:</div>
            <div id="carrotCount">ü•ï Carrots: 0</div>
            <div id="tomatoCount">üçÖ Tomatoes: 0</div>
            <div id="rareCount">‚ú® Rare Plants: 0</div>
            <div id="potatoCount">ü•î Potatoes: 0</div>
            <div id="cabbageCount">ü•¨ Cabbages: 0</div>
            <div id="cornCount">üåΩ Corn: 0</div>
            <div id="watermelonCount">üçâ Watermelons: 0</div>
            <div id="pumpkinCount">üéÉ Pumpkins: 0</div>
            <div id="appleCount">üçé Apples: 0</div>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <div class="equipment-header" style="font-weight: bold; margin-bottom: 5px;">üîß Equipment:</div>
            <div id="sprinklerCount">üíß Auto Sprinklers: 0</div>
            <div id="fertilizerCount">üåø Fertilizer: 0</div>
            <div id="greenhouseCount">üè† Greenhouses: 0</div>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <div class="animal-products-header" style="font-weight: bold; margin-bottom: 5px;">üêÑ Animal Products:</div>
            <div id="eggInventory">ü•ö Eggs: 0</div>
            <div id="milkInventory">ü•õ Milk: 0</div>
            <div id="truffleInventory">üçÑ Truffles: 0</div>
        </div>
        <div id="marketplace" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;"></div>
            
            <div class="market-category">
                <h3>üí∞ Sell Produce</h3>
                <button class="market-btn" onclick="sellAll('carrot')" id="sellCarrotBtn">Sell Carrots (1üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('tomato')" id="sellTomatoBtn">Sell Tomatoes (3üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('rare')" id="sellRareBtn">Sell Rare (10üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('potato')" id="sellPotatoBtn">Sell Potatoes (2üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('cabbage')" id="sellCabbageBtn">Sell Cabbages (4üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('corn')" id="sellCornBtn">Sell Corn (5üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('watermelon')" id="sellWatermelonBtn">Sell Watermelons (8üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('pumpkin')" id="sellPumpkinBtn">Sell Pumpkins (6üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('apple')" id="sellAppleBtn">Sell Apples (12üí∞)</button>
            </div>
            
            <div class="market-category">
                <h3>üêÑ Sell Animal Products</h3>
                <button class="market-btn" onclick="sellAnimalProduct('eggs')" id="sellEggsBtn">Sell Eggs (2üí∞ each)</button><br>
                <button class="market-btn" onclick="sellAnimalProduct('milk')" id="sellMilkBtn">Sell Milk (5üí∞ each)</button><br>
                <button class="market-btn" onclick="sellAnimalProduct('truffles')" id="sellTrufflesBtn">Sell Truffles (8üí∞ each)</button>
            </div>
            
            <div class="market-category">
                <h3>üå± Seeds</h3>
                <button class="market-btn" onclick="buySeeds('carrot', 1)" id="buyCarrotSeedsBtn">Buy Carrot Seeds (1üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('tomato', 2)" id="buyTomatoSeedsBtn">Buy Tomato Seeds (2üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('rare', 5)" id="buyRareSeedsBtn">Buy Rare Seeds (5üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('potato', 2)" id="buyPotatoSeedsBtn">Buy Potato Seeds (2üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('cabbage', 3)" id="buyCabbageSeedsBtn">Buy Cabbage Seeds (3üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('corn', 3)" id="buyCornSeedsBtn">Buy Corn Seeds (3üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('watermelon', 4)" id="buyWatermelonSeedsBtn">Buy Watermelon Seeds (4üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('pumpkin', 4)" id="buyPumpkinSeedsBtn">Buy Pumpkin Seeds (4üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('apple', 6)" id="buyAppleSeedsBtn">Buy Apple Seeds (6üí∞)</button>
            </div>
            
            <div class="market-category">
                <h3>üîß Equipment</h3>
                <button class="market-btn" onclick="buyItem('sprinkler', 150)" id="sprinklerBtn">Auto Sprinkler (150üí∞)</button><br>
                <button class="market-btn" onclick="buyItem('fertilizer', 50)" id="fertilizerBtn">Fertilizer Pack (50üí∞)</button><br>
                <button class="market-btn" onclick="buyItem('greenhouse', 300)" id="greenhouseBtn">Mini Greenhouse (300üí∞)</button>
            </div>
        </div>
        <div id="objectives" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üéØ Objectives:</div>
            <div id="objective1" class="objective">ü•ï Harvest 5 carrots (0/5)</div>
            <div id="objective2" class="objective">üåô Survive 2 day/night cycles (0/2)</div>
            <div id="objective3" class="objective">üí∞ Earn 20 coins (0/20)</div>
            <div id="objective4" class="objective" style="display: none;">üåæ Harvest 25 total plants (0/25)</div>
            <div id="objective5" class="objective" style="display: none;">üîß Buy any equipment (0/1)</div>
            <div id="objective6" class="objective" style="display: none;">üí∞ Earn 500 coins (0/500)</div>
            <div id="objective7" class="objective" style="display: none;">üå± Plant 50 seeds (0/50)</div>
            <div id="objective8" class="objective" style="display: none;">üèÜ Unlock all plots (0/25)</div>
        </div>
        <div id="dayNightIndicator" style="display: none;">
            <div id="timeDisplay">Day</div>
            <div id="cameraMode" style="margin-top: 10px; font-size: 14px;">Camera: Character Follow</div>
            <div id="characterStatus" style="margin-top: 10px; font-size: 12px; color: #FFD700;">
                Character: Idle
            </div>
        </div>
        
        <!-- Weather Panel -->
        <div id="weatherPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;"></div>
            <div class="weather-icon" id="weatherIcon">‚òÄÔ∏è</div>
            <div id="weatherName" style="text-align: center; margin-bottom: 5px;">Sunny</div>
            <div id="weatherEffect" style="font-size: 12px; text-align: center; opacity: 0.8;">Plants grow normally</div>
        </div>

        <!-- Season Panel -->
        <div id="seasonPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;"></div>
            <div class="season-icon" id="seasonIcon">üå∏</div>
            <div id="seasonName" style="text-align: center; margin-bottom: 5px;">Spring</div>
            <div id="seasonDay" style="font-size: 12px; text-align: center; opacity: 0.8;">Day 1 of 20</div>
        </div>

        <!-- Animals Panel -->
        <div id="animalsPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;"></div>
            
            <div class="animal-item">
                <div>
                    <div>üêî Chickens: <span id="chickenCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="eggCount">0</span> ü•ö</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('chicken', 30)" id="buyChickenBtn">Buy (30üí∞)</button>
                    <button class="animal-btn" onclick="collectResource('eggs')" id="collectEggsBtn">Collect</button>
                </div>
            </div>

            <div class="animal-item">
                <div>
                    <div>üêÑ Cows: <span id="cowCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="milkCount">0</span> ü•õ</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('cow', 100)" id="buyCowBtn">Buy (100üí∞)</button>
                    <button class="animal-btn" onclick="collectResource('milk')" id="collectMilkBtn">Collect</button>
                </div>
            </div>

            <div class="animal-item">
                <div>
                    <div>üê∑ Pigs: <span id="pigCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="truffleCount">0</span> üçÑ</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('pig', 150)" id="buyPigBtn">Buy (150üí∞)</button>
                    <button class="animal-btn" onclick="collectResource('truffles')" id="collectTrufflesBtn">Collect</button>
                </div>
            </div>
        </div>

        <!-- Daily Quests Panel -->
        <div id="questsPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;"></div>
            <div id="questList">
                <!-- Quests will be populated dynamically -->
            </div>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; opacity: 0.8;">
                <button class="market-btn" onclick="resetDailyQuests()" style="font-size: 11px; padding: 5px 10px;">üîÑ New Quests (50üí∞)</button>
            </div>
        </div>
        <button id="settingsButton" style="display: none;">‚öôÔ∏è Controls</button>
        <button id="newGameButton" style="display: none;">üÜï New Game</button>
        <button id="uiModeToggle" class="ui-mode-toggle" style="display: none;">üîß UI Mode</button>
        
        <!-- Unified Menu System -->
        <div id="unifiedMenu" style="position: absolute; top: 20px; right: 20px; z-index: 150;">
            <button id="mainMenuButton" class="menu-btn" style="background: #4CAF50; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; font-size: 14px;">
                üìã Menu
            </button>
            <div id="menuDropdown" style="display: none; position: absolute; top: 100%; right: 0; background: rgba(0, 0, 0, 0.9); border: 2px solid #4CAF50; border-radius: 10px; min-width: 200px; padding: 15px; margin-top: 5px;">
                <div style="color: white; font-weight: bold; margin-bottom: 15px; text-align: center; border-bottom: 1px solid #4CAF50; padding-bottom: 10px;">
                    üéÆ Game Menu
                </div>
                
                <!-- Language Selection -->
                <div style="margin-bottom: 15px;">
                    <div style="color: #FFD700; font-weight: bold; margin-bottom: 8px;">üåç Language</div>
                    <select id="languageSelector" style="width: 100%; background: #333; color: white; border: 1px solid #4CAF50; border-radius: 3px; padding: 5px;">
                        <option value="en">üá∫üá∏ English</option>
                        <option value="fr">üá´üá∑ Fran√ßais</option>
                        <option value="es">üá™üá∏ Espa√±ol</option>
                    </select>
                </div>
                
                <!-- Menu Options -->
                <button class="dropdown-menu-btn" onclick="showTutorialMenu()" style="width: 100%; background: #FF9800; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 3px 0; font-size: 13px;">
                    üéì <span data-translate="menu.tutorial">Tutorial</span>
                </button>
                
                <button class="dropdown-menu-btn" onclick="openSettings()" style="width: 100%; background: #2196F3; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 3px 0; font-size: 13px;">
                    ‚öôÔ∏è <span data-translate="menu.controls">Controls</span>
                </button>
                
                <button class="dropdown-menu-btn" onclick="toggleUIEditMode()" style="width: 100%; background: #9C27B0; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 3px 0; font-size: 13px;">
                    üîß <span data-translate="menu.uiMode">UI Mode</span>
                </button>
                
                <button class="dropdown-menu-btn" onclick="confirmNewGame()" style="width: 100%; background: #FF5722; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 3px 0; font-size: 13px;">
                    üÜï <span data-translate="menu.newGame">New Game</span>
                </button>
                
                <button class="dropdown-menu-btn" onclick="closeMenu()" style="width: 100%; background: #666; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 8px 0 0 0; font-size: 13px;">
                    ‚ùå Close
                </button>
            </div>
        </div>
        
        <!-- Mobile Navigation Menu -->
        <div id="mobileNavMenu">
            <button class="mobile-nav-btn" id="mobileInventoryBtn" data-panel="inventory">
                üì¶
                <span class="badge" id="inventoryBadge" style="display: none;">0</span>
            </button>
            <button class="mobile-nav-btn" id="mobilePlantsBtn" data-panel="plants">
                üå±
                <span class="badge" id="plantsBadge">5</span>
            </button>
            <button class="mobile-nav-btn" id="mobileMarketBtn" data-panel="market">
                üè™
                <span class="badge" id="marketBadge" style="display: none;">0</span>
            </button>
            <button class="mobile-nav-btn" id="mobileAnimalsBtn" data-panel="animals">
                üêÑ
                <span class="badge" id="animalsBadge" style="display: none;">0</span>
            </button>
            <button class="mobile-nav-btn" id="mobileQuestsBtn" data-panel="quests">
                üìã
                <span class="badge" id="questsBadge">3</span>
            </button>
        </div>

        <!-- Mobile Panels -->
        <div id="mobileInventoryPanel" class="mobile-panel">
            <div class="mobile-panel-header">
                <div class="mobile-panel-title">üì¶ Inventory</div>
                <button class="mobile-panel-close">√ó</button>
            </div>
            <div class="mobile-panel-content" id="mobileInventoryContent">
                <!-- Inventory content will be dynamically populated -->
            </div>
        </div>

        <div id="mobilePlantsPanel" class="mobile-panel">
            <div class="mobile-panel-header">
                <div class="mobile-panel-title">üå± Plant Types</div>
                <button class="mobile-panel-close">√ó</button>
            </div>
            <div class="mobile-panel-content">
                <div style="margin-bottom: 15px; text-align: center; color: #FFD700;">
                    üí∞ Coins: <span id="mobileCoins">50</span>
                </div>
                <div class="mobile-grid" id="mobilePlantsGrid">
                    <!-- Plants will be dynamically populated -->
                </div>
            </div>
        </div>

        <div id="mobileMarketPanel" class="mobile-panel">
            <div class="mobile-panel-header">
                <div class="mobile-panel-title">üè™ Marketplace</div>
                <button class="mobile-panel-close">√ó</button>
            </div>
            <div class="mobile-panel-content" id="mobileMarketContent">
                <!-- Market content will be dynamically populated -->
            </div>
        </div>

        <div id="mobileAnimalsPanel" class="mobile-panel">
            <div class="mobile-panel-header">
                <div class="mobile-panel-title">üêÑ Farm Animals</div>
                <button class="mobile-panel-close">√ó</button>
            </div>
            <div class="mobile-panel-content" id="mobileAnimalsContent">
                <!-- Animals content will be dynamically populated -->
            </div>
        </div>

        <div id="mobileQuestsPanel" class="mobile-panel">
            <div class="mobile-panel-header">
                <div class="mobile-panel-title">üìã Daily Quests</div>
                <button class="mobile-panel-close">√ó</button>
            </div>
            <div class="mobile-panel-content" id="mobileQuestsContent">
                <!-- Quests content will be dynamically populated -->
            </div>
        </div>

        <!-- Mobile Controls -->
        <div id="mobileControls">
            <!-- Virtual Joystick for Movement -->
            <div class="mobile-joystick" id="mobileJoystick">
                <div class="mobile-joystick-handle" id="joystickHandle"></div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mobile-action-buttons">
                <button class="mobile-btn" id="mobileActionBtn" title="Plant/Harvest">üå±</button>
                <button class="mobile-btn secondary" id="mobileWaterBtn" title="Water">üíß</button>
            </div>
            
            <!-- Camera Controls -->
            <div class="mobile-camera-controls">
                <button class="mobile-camera-btn" id="mobileCameraBtn" title="Toggle Camera">üìπ</button>
                <button class="mobile-camera-btn" id="mobileZoomInBtn" title="Zoom In">üîç</button>
                <button class="mobile-camera-btn" id="mobileZoomOutBtn" title="Zoom Out">üîç</button>
            </div>
        </div>
        
        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2>‚öôÔ∏è Control Settings</h2>
            
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setControlPreset('azerty')">AZERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('qwerty')">QWERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('arrows')">Arrow Keys</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Forward:</span>
                <button class="key-button" id="key-forward" onclick="recordKey('forward')">Z</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Left:</span>
                <button class="key-button" id="key-left" onclick="recordKey('left')">Q</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Backward:</span>
                <button class="key-button" id="key-backward" onclick="recordKey('backward')">S</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Right:</span>
                <button class="key-button" id="key-right" onclick="recordKey('right')">D</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Plant/Harvest:</span>
                <button class="key-button" id="key-action" onclick="recordKey('action')">SPACE</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Water Plants:</span>
                <button class="key-button" id="key-water" onclick="recordKey('water')">E</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Toggle Camera:</span>
                <button class="key-button" id="key-camera" onclick="recordKey('camera')">C</button>
            </div>
            
            <div class="menu-buttons">
                <button class="menu-btn" onclick="saveControls()">Save</button>
                <button class="menu-btn cancel-btn" onclick="cancelControls()">Cancel</button>
                <button class="menu-btn" onclick="resetControls()">Reset to Default</button>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <!-- Tutorial System Scripts -->
    <script src="src/tutorial/tutorial-localization.js"></script>
    <script src="src/tutorial/tutorial-ui.js"></script>
    <script src="src/tutorial/tutorial-steps.js"></script>
    <script src="src/tutorial/tutorial-manager.js"></script>

    <script>
        // Internationalization System
        let currentLanguage = 'en';
        
        const translations = {
            en: {
                // Game UI
                score: 'Score',
                instructions: {
                    move: 'üå± Move with ZQSD or arrow keys',
                    action: '‚ö° SPACE to plant/harvest at closest plot',
                    water: 'üíß E to water plants',
                    camera: 'üìπ C to toggle camera mode',
                    growth: 'üåø Plants grow automatically (3 stages)',
                    unlock: 'üîí Unlock plots by getting close and pressing SPACE',
                    cycle: 'üåô Watch the day/night cycle!',
                    drag: 'üñ±Ô∏è Drag to rotate camera view',
                    zoom: 'üîç Scroll wheel to zoom in/out'
                },
                menu: {
                    main: 'Menu',
                    controls: 'Controls',
                    newGame: 'New Game',
                    language: 'Language',
                    uiMode: 'UI Mode',
                    settings: 'Settings',
                    tutorial: 'Tutorial'
                },
                plants: {
                    title: 'Plant Types:',
                    carrot: 'Carrot',
                    tomato: 'Tomato', 
                    rare: 'Rare Plant',
                    potato: 'Potato',
                    cabbage: 'Cabbage',
                    corn: 'Corn',
                    watermelon: 'Watermelon',
                    pumpkin: 'Pumpkin',
                    apple: 'Apple Tree',
                    fast: 'Fast',
                    normal: 'Normal',
                    slow: 'Slow',
                    medium: 'Medium',
                    verySlow: 'Very Slow',
                    coins: 'Coins'
                },
                inventory: {
                    title: 'Inventory:',
                    carrots: 'Carrots',
                    tomatoes: 'Tomatoes',
                    rarePlants: 'Rare Plants',
                    potatoes: 'Potatoes',
                    cabbages: 'Cabbages',
                    corn: 'Corn',
                    watermelons: 'Watermelons',
                    pumpkins: 'Pumpkins',
                    apples: 'Apples',
                    equipment: 'Equipment:',
                    autoSprinklers: 'Auto Sprinklers',
                    fertilizer: 'Fertilizer',
                    greenhouses: 'Greenhouses',
                    animalProducts: 'Animal Products:',
                    eggs: 'Eggs',
                    milk: 'Milk',
                    truffles: 'Truffles'
                },
                marketplace: {
                    title: 'Marketplace:',
                    sellProduce: 'Sell Produce',
                    sellAnimalProducts: 'Sell Animal Products',
                    seeds: 'Seeds',
                    equipment: 'Equipment',
                    sell: 'Sell',
                    buy: 'Buy',
                    sellCarrots: 'Sell Carrots',
                    sellTomatoes: 'Sell Tomatoes',
                    sellRare: 'Sell Rare Plants',
                    sellPotatoes: 'Sell Potatoes',
                    sellCabbages: 'Sell Cabbages',
                    sellCorn: 'Sell Corn',
                    sellWatermelons: 'Sell Watermelons',
                    sellPumpkins: 'Sell Pumpkins',
                    sellApples: 'Sell Apples',
                    sellEggs: 'Sell Eggs',
                    sellMilk: 'Sell Milk',
                    sellTruffles: 'Sell Truffles',
                    buySeeds: 'Seeds',
                    autoSprinkler: 'Auto Sprinkler',
                    fertilizerPack: 'Fertilizer Pack',
                    miniGreenhouse: 'Mini Greenhouse',
                    each: 'each'
                },
                objectives: {
                    title: 'Objectives:',
                    harvestCarrots: 'Harvest 5 carrots',
                    surviveCycles: 'Survive 2 day/night cycles', 
                    earnCoins: 'Earn 20 coins',
                    harvestPlants: 'Harvest 25 total plants',
                    buyEquipment: 'Buy any equipment',
                    earnMoreCoins: 'Earn 500 coins',
                    plantSeeds: 'Plant 50 seeds',
                    unlockPlots: 'Unlock all plots'
                },
                weather: {
                    title: 'Weather',
                    sunny: 'Sunny',
                    cloudy: 'Cloudy',
                    rainy: 'Rainy',
                    stormy: 'Stormy',
                    effect: {
                        sunny: 'Plants grow faster',
                        cloudy: 'Normal growth, less water loss',
                        rainy: 'Slower growth, plants auto-watered',
                        stormy: 'Much slower growth, auto-watered'
                    }
                },
                season: {
                    title: 'Season',
                    spring: 'Spring',
                    summer: 'Summer',
                    autumn: 'Autumn',
                    winter: 'Winter',
                    day: 'Day',
                    of: 'of'
                },
                animals: {
                    title: 'Farm Animals',
                    chickens: 'Chickens',
                    cows: 'Cows',
                    pigs: 'Pigs',
                    produce: 'Produce',
                    buy: 'Buy',
                    collect: 'Collect'
                },
                quests: {
                    title: 'Daily Quests',
                    harvest: 'Harvest {0} plants',
                    plant: 'Plant {0} seeds',
                    earn: 'Earn {0} coins',
                    collect: 'Collect {0} animal products',
                    water: 'Water {0} plants',
                    harvestDesc: 'Harvest any type of plant',
                    plantDesc: 'Plant any type of seed',
                    earnDesc: 'Earn coins by selling items',
                    collectDesc: 'Collect eggs, milk, or truffles',
                    waterDesc: 'Water growing plants',
                    progress: 'Progress',
                    reward: 'Reward',
                    newQuests: 'New Quests'
                },
                time: {
                    day: 'Day',
                    night: 'Night',
                    camera: 'Camera',
                    characterFollow: 'Character Follow',
                    character: 'Character',
                    idle: 'Idle',
                    walking: 'Walking',
                    planting: 'Planting',
                    watering: 'Watering'
                }
            },
            fr: {
                // French translations
                score: 'Score',
                instructions: {
                    move: 'üå± D√©placez-vous avec ZQSD ou les touches fl√©ch√©es',
                    action: '‚ö° ESPACE pour planter/r√©colter √† la parcelle la plus proche',
                    water: 'üíß E pour arroser les plantes',
                    camera: 'üìπ C pour changer de mode cam√©ra',
                    growth: 'üåø Les plantes poussent automatiquement (3 √©tapes)',
                    unlock: 'üîí D√©bloquez les parcelles en vous approchant et en appuyant sur ESPACE',
                    cycle: 'üåô Regardez le cycle jour/nuit !',
                    drag: 'üñ±Ô∏è Faites glisser pour faire pivoter la vue de la cam√©ra',
                    zoom: 'üîç Molette de la souris pour zoomer/d√©zoomer'
                },
                menu: {
                    main: 'Menu',
                    controls: 'Contr√¥les',
                    newGame: 'Nouveau Jeu',
                    language: 'Langue',
                    uiMode: 'Mode Interface',
                    settings: 'Param√®tres'
                },
                plants: {
                    title: 'Types de Plantes :',
                    carrot: 'Carotte',
                    tomato: 'Tomate',
                    rare: 'Plante Rare',
                    potato: 'Pomme de terre',
                    cabbage: 'Chou',
                    corn: 'Ma√Øs',
                    watermelon: 'Past√®que',
                    pumpkin: 'Citrouille',
                    apple: 'Pommier',
                    fast: 'Rapide',
                    normal: 'Normal',
                    slow: 'Lent',
                    medium: 'Moyen',
                    verySlow: 'Tr√®s Lent',
                    coins: 'Pi√®ces'
                },
                inventory: {
                    title: 'Inventaire :',
                    carrots: 'Carottes',
                    tomatoes: 'Tomates',
                    rarePlants: 'Plantes Rares',
                    potatoes: 'Pommes de terre',
                    cabbages: 'Choux',
                    corn: 'Ma√Øs',
                    watermelons: 'Past√®ques',
                    pumpkins: 'Citrouilles',
                    apples: 'Pommes',
                    equipment: '√âquipement :',
                    autoSprinklers: 'Arroseurs Auto',
                    fertilizer: 'Engrais',
                    greenhouses: 'Serres',
                    animalProducts: 'Produits Animaux :',
                    eggs: '≈íufs',
                    milk: 'Lait',
                    truffles: 'Truffes'
                },
                marketplace: {
                    title: 'March√© :',
                    sellProduce: 'Vendre R√©coltes',
                    sellAnimalProducts: 'Vendre Produits Animaux',
                    seeds: 'Graines',
                    equipment: '√âquipement',
                    sell: 'Vendre',
                    buy: 'Acheter',
                    sellCarrots: 'Vendre Carottes',
                    sellTomatoes: 'Vendre Tomates',
                    sellRare: 'Vendre Plantes Rares',
                    sellPotatoes: 'Vendre Pommes de terre',
                    sellCabbages: 'Vendre Choux',
                    sellCorn: 'Vendre Ma√Øs',
                    sellWatermelons: 'Vendre Past√®ques',
                    sellPumpkins: 'Vendre Citrouilles',
                    sellApples: 'Vendre Pommes',
                    sellEggs: 'Vendre ≈íufs',
                    sellMilk: 'Vendre Lait',
                    sellTruffles: 'Vendre Truffes',
                    buySeeds: 'Graines',
                    autoSprinkler: 'Arroseur Auto',
                    fertilizerPack: 'Pack Engrais',
                    miniGreenhouse: 'Mini Serre',
                    each: 'chacun'
                },
                objectives: {
                    title: 'Objectifs :',
                    harvestCarrots: 'R√©colter 5 carottes',
                    surviveCycles: 'Survivre 2 cycles jour/nuit',
                    earnCoins: 'Gagner 20 pi√®ces',
                    harvestPlants: 'R√©colter 25 plantes au total',
                    buyEquipment: 'Acheter un √©quipement',
                    earnMoreCoins: 'Gagner 500 pi√®ces',
                    plantSeeds: 'Planter 50 graines',
                    unlockPlots: 'D√©bloquer toutes les parcelles'
                },
                weather: {
                    title: 'M√©t√©o',
                    sunny: 'Ensoleill√©',
                    cloudy: 'Nuageux',
                    rainy: 'Pluvieux',
                    stormy: 'Orageux',
                    effect: {
                        sunny: 'Les plantes poussent plus vite',
                        cloudy: 'Croissance normale, moins de perte d\'eau',
                        rainy: 'Croissance plus lente, plantes auto-arros√©es',
                        stormy: 'Croissance beaucoup plus lente, auto-arros√©es'
                    }
                },
                season: {
                    title: 'Saison',
                    spring: 'Printemps',
                    summer: '√ât√©',
                    autumn: 'Automne',
                    winter: 'Hiver',
                    day: 'Jour',
                    of: 'de'
                },
                animals: {
                    title: 'Animaux de Ferme',
                    chickens: 'Poules',
                    cows: 'Vaches',
                    pigs: 'Cochons',
                    produce: 'Production',
                    buy: 'Acheter',
                    collect: 'Collecter'
                },
                quests: {
                    title: 'Qu√™tes Quotidiennes',
                    harvest: 'R√©colter {0} plantes',
                    plant: 'Planter {0} graines',
                    earn: 'Gagner {0} pi√®ces',
                    collect: 'Collecter {0} produits animaux',
                    water: 'Arroser {0} plantes',
                    harvestDesc: 'R√©colter n\'importe quel type de plante',
                    plantDesc: 'Planter n\'importe quel type de graine',
                    earnDesc: 'Gagner des pi√®ces en vendant des objets',
                    collectDesc: 'Collecter ≈ìufs, lait ou truffes',
                    waterDesc: 'Arroser les plantes qui poussent',
                    progress: 'Progr√®s',
                    reward: 'R√©compense',
                    newQuests: 'Nouvelles Qu√™tes'
                },
                time: {
                    day: 'Jour',
                    night: 'Nuit',
                    camera: 'Cam√©ra',
                    characterFollow: 'Suivi Personnage',
                    character: 'Personnage',
                    idle: 'Inactif',
                    walking: 'Marche',
                    planting: 'Plantation',
                    watering: 'Arrosage'
                }
            },
            es: {
                // Spanish translations
                score: 'Puntuaci√≥n',
                instructions: {
                    move: 'üå± Mu√©vete con ZQSD o las teclas de flecha',
                    action: '‚ö° ESPACIO para plantar/cosechar en la parcela m√°s cercana',
                    water: 'üíß E para regar plantas',
                    camera: 'üìπ C para cambiar modo de c√°mara',
                    growth: 'üåø Las plantas crecen autom√°ticamente (3 etapas)',
                    unlock: 'üîí Desbloquea parcelas acerc√°ndote y presionando ESPACIO',
                    cycle: 'üåô ¬°Observa el ciclo d√≠a/noche!',
                    drag: 'üñ±Ô∏è Arrastra para rotar la vista de la c√°mara',
                    zoom: 'üîç Rueda del rat√≥n para acercar/alejar'
                },
                menu: {
                    main: 'Men√∫',
                    controls: 'Controles',
                    newGame: 'Nuevo Juego',
                    language: 'Idioma',
                    uiMode: 'Modo Interfaz',
                    settings: 'Configuraci√≥n'
                },
                plants: {
                    title: 'Tipos de Plantas:',
                    carrot: 'Zanahoria',
                    tomato: 'Tomate',
                    rare: 'Planta Rara',
                    potato: 'Papa',
                    cabbage: 'Repollo',
                    corn: 'Ma√≠z',
                    watermelon: 'Sand√≠a',
                    pumpkin: 'Calabaza',
                    apple: 'Manzano',
                    fast: 'R√°pido',
                    normal: 'Normal',
                    slow: 'Lento',
                    medium: 'Medio',
                    verySlow: 'Muy Lento',
                    coins: 'Monedas'
                },
                inventory: {
                    title: 'Inventario:',
                    carrots: 'Zanahorias',
                    tomatoes: 'Tomates',
                    rarePlants: 'Plantas Raras',
                    potatoes: 'Papas',
                    cabbages: 'Repollos',
                    corn: 'Ma√≠z',
                    watermelons: 'Sand√≠as',
                    pumpkins: 'Calabazas',
                    apples: 'Manzanas',
                    equipment: 'Equipamiento:',
                    autoSprinklers: 'Aspersores Auto',
                    fertilizer: 'Fertilizante',
                    greenhouses: 'Invernaderos',
                    animalProducts: 'Productos Animales:',
                    eggs: 'Huevos',
                    milk: 'Leche',
                    truffles: 'Trufas'
                },
                marketplace: {
                    title: 'Mercado:',
                    sellProduce: 'Vender Productos',
                    sellAnimalProducts: 'Vender Productos Animales',
                    seeds: 'Semillas',
                    equipment: 'Equipamiento',
                    sell: 'Vender',
                    buy: 'Comprar',
                    sellCarrots: 'Vender Zanahorias',
                    sellTomatoes: 'Vender Tomates',
                    sellRare: 'Vender Plantas Raras',
                    sellPotatoes: 'Vender Papas',
                    sellCabbages: 'Vender Repollos',
                    sellCorn: 'Vender Ma√≠z',
                    sellWatermelons: 'Vender Sand√≠as',
                    sellPumpkins: 'Vender Calabazas',
                    sellApples: 'Vender Manzanas',
                    sellEggs: 'Vender Huevos',
                    sellMilk: 'Vender Leche',
                    sellTruffles: 'Vender Trufas',
                    buySeeds: 'Semillas',
                    autoSprinkler: 'Aspersor Auto',
                    fertilizerPack: 'Pack Fertilizante',
                    miniGreenhouse: 'Mini Invernadero',
                    each: 'cada uno'
                },
                objectives: {
                    title: 'Objetivos:',
                    harvestCarrots: 'Cosechar 5 zanahorias',
                    surviveCycles: 'Sobrevivir 2 ciclos d√≠a/noche',
                    earnCoins: 'Ganar 20 monedas',
                    harvestPlants: 'Cosechar 25 plantas en total',
                    buyEquipment: 'Comprar cualquier equipamiento',
                    earnMoreCoins: 'Ganar 500 monedas',
                    plantSeeds: 'Plantar 50 semillas',
                    unlockPlots: 'Desbloquear todas las parcelas'
                },
                weather: {
                    title: 'Clima',
                    sunny: 'Soleado',
                    cloudy: 'Nublado',
                    rainy: 'Lluvioso',
                    stormy: 'Tormentoso',
                    effect: {
                        sunny: 'Las plantas crecen m√°s r√°pido',
                        cloudy: 'Crecimiento normal, menos p√©rdida de agua',
                        rainy: 'Crecimiento m√°s lento, plantas auto-regadas',
                        stormy: 'Crecimiento mucho m√°s lento, auto-regadas'
                    }
                },
                season: {
                    title: 'Estaci√≥n',
                    spring: 'Primavera',
                    summer: 'Verano',
                    autumn: 'Oto√±o',
                    winter: 'Invierno',
                    day: 'D√≠a',
                    of: 'de'
                },
                animals: {
                    title: 'Animales de Granja',
                    chickens: 'Gallinas',
                    cows: 'Vacas',
                    pigs: 'Cerdos',
                    produce: 'Producci√≥n',
                    buy: 'Comprar',
                    collect: 'Recolectar'
                },
                quests: {
                    title: 'Misiones Diarias',
                    harvest: 'Cosechar {0} plantas',
                    plant: 'Plantar {0} semillas',
                    earn: 'Ganar {0} monedas',
                    collect: 'Recolectar {0} productos animales',
                    water: 'Regar {0} plantas',
                    harvestDesc: 'Cosechar cualquier tipo de planta',
                    plantDesc: 'Plantar cualquier tipo de semilla',
                    earnDesc: 'Ganar monedas vendiendo objetos',
                    collectDesc: 'Recolectar huevos, leche o trufas',
                    waterDesc: 'Regar plantas en crecimiento',
                    progress: 'Progreso',
                    reward: 'Recompensa',
                    newQuests: 'Nuevas Misiones'
                },
                time: {
                    day: 'D√≠a',
                    night: 'Noche',
                    camera: 'C√°mara',
                    characterFollow: 'Seguir Personaje',
                    character: 'Personaje',
                    idle: 'Inactivo',
                    walking: 'Caminando',
                    planting: 'Plantando',
                    watering: 'Regando'
                }
            }
        };
        
        // Translation function
        function t(key, ...args) {
            const keys = key.split('.');
            let value = translations[currentLanguage];
            
            for (const k of keys) {
                if (value && typeof value === 'object' && k in value) {
                    value = value[k];
                } else {
                    // Fallback to English if translation not found
                    value = translations['en'];
                    for (const fallbackKey of keys) {
                        if (value && typeof value === 'object' && fallbackKey in value) {
                            value = value[fallbackKey];
                        } else {
                            return key; // Return key if not found
                        }
                    }
                    break;
                }
            }
            
            // Handle string formatting with {0}, {1}, etc.
            if (typeof value === 'string' && args.length > 0) {
                return value.replace(/\{(\d+)\}/g, (match, index) => {
                    const argIndex = parseInt(index);
                    return argIndex < args.length ? args[argIndex] : match;
                });
            }
            
            return value || key;
        }
        
        // Language switching function
        function setLanguage(lang) {
            if (translations[lang]) {
                currentLanguage = lang;
                localStorage.setItem('pixelHarvestLanguage', lang);
                updateAllUI();
            }
        }
        
        // Load saved language
        function loadSavedLanguage() {
            const saved = localStorage.getItem('pixelHarvestLanguage');
            if (saved && translations[saved]) {
                currentLanguage = saved;
            }
        }
        
        // Menu System Functions
        function initMenuSystem() {
            const mainMenuButton = document.getElementById('mainMenuButton');
            const menuDropdown = document.getElementById('menuDropdown');
            const languageSelector = document.getElementById('languageSelector');
            
            // Set initial language in selector
            languageSelector.value = currentLanguage;
            
            // Menu toggle functionality
            mainMenuButton.addEventListener('click', function(e) {
                e.stopPropagation();
                const isVisible = menuDropdown.style.display !== 'none';
                if (isVisible) {
                    closeMenu();
                } else {
                    openMenu();
                }
            });
            
            // Language selector change
            languageSelector.addEventListener('change', function() {
                setLanguage(this.value);
                updateMenuTexts();
            });
            
            // Close menu when clicking outside
            document.addEventListener('click', function(e) {
                if (!e.target.closest('#unifiedMenu')) {
                    closeMenu();
                }
            });
        }
        
        function openMenu() {
            const menuDropdown = document.getElementById('menuDropdown');
            menuDropdown.style.display = 'block';
            updateMenuTexts();
        }
        
        function closeMenu() {
            const menuDropdown = document.getElementById('menuDropdown');
            menuDropdown.style.display = 'none';
        }
        
        function updateMenuTexts() {
            const mainMenuButton = document.getElementById('mainMenuButton');
            mainMenuButton.innerHTML = 'üìã ' + t('menu.main');
            
            // Update all elements with data-translate attribute
            const translatableElements = document.querySelectorAll('[data-translate]');
            translatableElements.forEach(element => {
                const key = element.getAttribute('data-translate');
                element.textContent = t(key);
            });
        }
        
        function openSettings() {
            closeMenu();
            const settingsMenu = document.getElementById('settingsMenu');
            settingsMenu.style.display = 'block';
            updateSettingsTexts();
        }
        
        function confirmNewGame() {
            closeMenu();
            if (confirm(t('menu.newGame') + '?')) {
                location.reload();
            }
        }
        
        function updateSettingsTexts() {
            // Update settings menu texts
            const settingsTitle = document.querySelector('#settingsMenu h2');
            if (settingsTitle) {
                settingsTitle.innerHTML = '‚öôÔ∏è ' + t('menu.controls');
            }
        }
        
        // Update all UI elements with translations
        function updateAllUI() {
            updateMenuTexts();
            updateInstructionsUI();
            updatePlantSelectorUI();
            updateInventoryUI();
            updateMarketplaceUI();
            updateObjectivesUI();
            updateWeatherUI();
            updateSeasonUI();
            updateAnimalsUI();
            updateQuestsUI();
            updateTimeUI();
        }
        
        function updateInstructionsUI() {
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = `
                    ${t('instructions.move')}<br>
                    ${t('instructions.action')}<br>
                    ${t('instructions.water')}<br>
                    ${t('instructions.camera')}<br>
                    ${t('instructions.growth')}<br>
                    ${t('instructions.unlock')}<br>
                    ${t('instructions.cycle')}<br>
                    ${t('instructions.drag')}<br>
                    ${t('instructions.zoom')}
                `;
            }
        }
        
        function updatePlantSelectorUI() {
            const plantTitle = document.querySelector('#plantSelector > div:first-child');
            if (plantTitle) {
                plantTitle.innerHTML = `üå± ${t('plants.title')}`;
            }
            
            // Update plant button names and seed counts
            const plantButtons = document.querySelectorAll('#plantSelector .plant-btn');
            plantButtons.forEach(button => {
                const plantType = button.getAttribute('data-plant');
                const plantNameSpan = button.querySelector(`[data-plant-name="${plantType}"]`);
                const seedCountSpan = button.querySelector(`[data-seed-count="${plantType}"]`);
                
                if (plantNameSpan && plantType) {
                    plantNameSpan.textContent = t(`plants.${plantType}`);
                }
                
                if (seedCountSpan && plantType) {
                    const count = seedInventory[plantType] || 0;
                    seedCountSpan.textContent = count;
                    
                    // Disable button if no seeds and add visual indicator
                    button.disabled = count <= 0;
                    button.style.opacity = count > 0 ? '1' : '0.5';
                    
                    // Check if plant is available in current season
                    const seasonPlants = SEASON_TYPES[currentSeason.type]?.availableCrops || [];
                    const isSeasonAppropriate = seasonPlants.includes(plantType);
                    
                    if (!isSeasonAppropriate) {
                        button.innerHTML = button.innerHTML.replace(' ‚ùÑÔ∏è', '') + ' ‚ùÑÔ∏è'; // Add winter indicator
                        button.disabled = true;
                        button.style.opacity = '0.5';
                    }
                }
            });
            
            const coinsDisplay = document.querySelector('#plantSelector .coins-display');
            if (coinsDisplay) {
                coinsDisplay.innerHTML = `üí∞ ${t('plants.coins')}: <span id="coins">${coins}</span>`;
            }
        }
        
        function updateInventoryUI() {
            const inventoryTitle = document.querySelector('#inventory > div:first-child');
            if (inventoryTitle) {
                inventoryTitle.innerHTML = `üì¶ ${t('inventory.title')}`;
            }
            
            // Update individual inventory items with current counts
            const inventoryElements = {
                'carrotCount': { key: 'carrots', emoji: 'ü•ï', inventoryKey: 'carrot' },
                'tomatoCount': { key: 'tomatoes', emoji: 'üçÖ', inventoryKey: 'tomato' },
                'rareCount': { key: 'rarePlants', emoji: '‚ú®', inventoryKey: 'rare' },
                'potatoCount': { key: 'potatoes', emoji: 'ü•î', inventoryKey: 'potato' },
                'cabbageCount': { key: 'cabbages', emoji: 'ü•¨', inventoryKey: 'cabbage' },
                'cornCount': { key: 'corn', emoji: 'üåΩ', inventoryKey: 'corn' },
                'watermelonCount': { key: 'watermelons', emoji: 'üçâ', inventoryKey: 'watermelon' },
                'pumpkinCount': { key: 'pumpkins', emoji: 'üéÉ', inventoryKey: 'pumpkin' },
                'appleCount': { key: 'apples', emoji: 'üçé', inventoryKey: 'apple' }
            };
            
            Object.entries(inventoryElements).forEach(([id, config]) => {
                const element = document.getElementById(id);
                if (element) {
                    const count = inventory[config.inventoryKey] || 0;
                    element.innerHTML = `${config.emoji} ${t('inventory.' + config.key)}: ${count}`;
                }
            });
            
            // Update equipment items
            const sprinklerElement = document.getElementById('sprinklerCount');
            if (sprinklerElement) {
                sprinklerElement.innerHTML = `üíß ${t('inventory.autoSprinklers')}: ${equipment.sprinkler || 0}`;
            }
            
            const fertilizerElement = document.getElementById('fertilizerCount');
            if (fertilizerElement) {
                fertilizerElement.innerHTML = `üåø ${t('inventory.fertilizer')}: ${equipment.fertilizer || 0}`;
            }
            
            const greenhouseElement = document.getElementById('greenhouseCount');
            if (greenhouseElement) {
                greenhouseElement.innerHTML = `üè† ${t('inventory.greenhouses')}: ${equipment.greenhouse || 0}`;
            }
            
            // Update animal products
            const eggElement = document.getElementById('eggInventory');
            if (eggElement) {
                eggElement.innerHTML = `ü•ö ${t('inventory.eggs')}: ${animalInventory.eggs || 0}`;
            }
            
            const milkElement = document.getElementById('milkInventory');
            if (milkElement) {
                milkElement.innerHTML = `ü•õ ${t('inventory.milk')}: ${animalInventory.milk || 0}`;
            }
            
            const truffleElement = document.getElementById('truffleInventory');
            if (truffleElement) {
                truffleElement.innerHTML = `üçÑ ${t('inventory.truffles')}: ${animalInventory.truffles || 0}`;
            }
            
            // Update section headers
            const equipmentHeader = document.querySelector('#inventory .equipment-header');
            if (equipmentHeader) {
                equipmentHeader.innerHTML = `üîß ${t('inventory.equipment')}`;
            }
            
            const animalProductsHeader = document.querySelector('#inventory .animal-products-header');
            if (animalProductsHeader) {
                animalProductsHeader.innerHTML = `üêÑ ${t('inventory.animalProducts')}`;
            }
        }
        
        function updateMarketplaceUI() {
            const marketTitle = document.querySelector('#marketplace > div:first-child');
            if (marketTitle) {
                marketTitle.innerHTML = `üè™ ${t('marketplace.title')}`;
            }
            
            // Update category headers
            const categories = document.querySelectorAll('#marketplace .market-category h3');
            if (categories.length >= 4) {
                categories[0].innerHTML = `üí∞ ${t('marketplace.sellProduce')}`;
                categories[1].innerHTML = `üêÑ ${t('marketplace.sellAnimalProducts')}`;
                categories[2].innerHTML = `üå± ${t('marketplace.seeds')}`;
                categories[3].innerHTML = `üîß ${t('marketplace.equipment')}`;
            }
            
            // Update sell buttons with dynamic prices and translations
            const plantTypes = ['carrot', 'tomato', 'rare', 'potato', 'cabbage', 'corn', 'watermelon', 'pumpkin', 'apple'];
            plantTypes.forEach(plantType => {
                const price = getDynamicPrice(plantType, 'sell');
                const plantTranslation = t(`plants.${plantType}`);
                const sellBtn = document.getElementById(`sell${plantType.charAt(0).toUpperCase() + plantType.slice(1)}Btn`);
                if (sellBtn) {
                    const count = inventory[plantType] || 0;
                    const sellText = (() => {
                        switch(plantType) {
                            case 'carrot': return t('marketplace.sellCarrots');
                            case 'tomato': return t('marketplace.sellTomatoes');
                            case 'rare': return t('marketplace.sellRare');
                            case 'potato': return t('marketplace.sellPotatoes');
                            case 'cabbage': return t('marketplace.sellCabbages');
                            case 'corn': return t('marketplace.sellCorn');
                            case 'watermelon': return t('marketplace.sellWatermelons');
                            case 'pumpkin': return t('marketplace.sellPumpkins');
                            case 'apple': return t('marketplace.sellApples');
                            default: return t(`marketplace.sell${plantType.charAt(0).toUpperCase() + plantType.slice(1)}`);
                        }
                    })();
                    sellBtn.textContent = `${sellText} (${price}üí∞)`;
                    sellBtn.disabled = count <= 0;
                    sellBtn.style.opacity = count > 0 ? '1' : '0.5';
                }
            });
            
            // Update animal product sell buttons
            const animalProducts = ['eggs', 'milk', 'truffles'];
            const animalPrices = { eggs: 2, milk: 5, truffles: 8 };
            animalProducts.forEach(productType => {
                const price = animalPrices[productType];
                const sellBtn = document.getElementById(`sell${productType.charAt(0).toUpperCase() + productType.slice(1)}Btn`);
                if (sellBtn) {
                    const count = animalInventory[productType] || 0;
                    const productTranslation = (() => {
                        switch(productType) {
                            case 'eggs': return t('marketplace.sellEggs');
                            case 'milk': return t('marketplace.sellMilk');
                            case 'truffles': return t('marketplace.sellTruffles');
                            default: return t(`marketplace.sell${productType.charAt(0).toUpperCase() + productType.slice(1)}`);
                        }
                    })();
                    sellBtn.textContent = `${productTranslation} (${price}üí∞ ${t('marketplace.each')}) [${count}]`;
                    sellBtn.disabled = count <= 0;
                    sellBtn.style.opacity = count > 0 ? '1' : '0.5';
                }
            });
            
            // Update seed purchase buttons
            plantTypes.forEach(plantType => {
                const price = getDynamicPrice(plantType, 'buy');
                const plantTranslation = t(`plants.${plantType}`);
                const buyBtn = document.getElementById(`buy${plantType.charAt(0).toUpperCase() + plantType.slice(1)}SeedsBtn`);
                if (buyBtn) {
                    buyBtn.textContent = `${t('marketplace.buy')} ${plantTranslation} ${t('marketplace.seeds')} (${price}üí∞)`;
                    buyBtn.disabled = coins < price;
                    buyBtn.style.opacity = coins >= price ? '1' : '0.5';
                }
            });
            
            // Update equipment buttons
            const equipmentButtons = [
                { id: 'sprinklerBtn', key: 'autoSprinkler', cost: 150 },
                { id: 'fertilizerBtn', key: 'fertilizerPack', cost: 50 },
                { id: 'greenhouseBtn', key: 'miniGreenhouse', cost: 300 }
            ];
            
            equipmentButtons.forEach(({ id, key, cost }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.textContent = `${t(`marketplace.${key}`)} (${cost}üí∞)`;
                    btn.disabled = coins < cost;
                    btn.style.opacity = coins >= cost ? '1' : '0.5';
                }
            });
        }
        
        function updateObjectivesUI() {
            const objectivesTitle = document.querySelector('#objectives > div:first-child');
            if (objectivesTitle) {
                objectivesTitle.innerHTML = `üéØ ${t('objectives.title')}`;
            }
            
            // Update objective text based on current progress
            const objective1 = document.getElementById('objective1');
            if (objective1) {
                objective1.textContent = `ü•ï ${t('objectives.harvestCarrots')} (${objectives.carrotsHarvested}/5)`;
            }
            
            const objective2 = document.getElementById('objective2');
            if (objective2) {
                objective2.textContent = `üåô ${t('objectives.surviveCycles')} (${objectives.dayNightCycles}/2)`;
            }
            
            const objective3 = document.getElementById('objective3');
            if (objective3) {
                objective3.textContent = `üí∞ ${t('objectives.earnCoins')} (${objectives.coinsEarned}/20)`;
            }
            
            const objective4 = document.getElementById('objective4');
            if (objective4) {
                objective4.textContent = `üåæ ${t('objectives.harvestPlants')} (${objectives.plantsHarvested}/25)`;
            }
            
            const objective5 = document.getElementById('objective5');
            if (objective5) {
                objective5.textContent = `üîß ${t('objectives.buyEquipment')} (${objectives.equipmentBought}/1)`;
            }
            
            const objective6 = document.getElementById('objective6');
            if (objective6) {
                objective6.textContent = `üí∞ ${t('objectives.earnMoreCoins')} (${objectives.coinsEarned}/500)`;
            }
            
            const objective7 = document.getElementById('objective7');
            if (objective7) {
                objective7.textContent = `üå± ${t('objectives.plantSeeds')} (${objectives.seedsPlanted}/50)`;
            }
            
            const objective8 = document.getElementById('objective8');
            if (objective8) {
                objective8.textContent = `üèÜ ${t('objectives.unlockPlots')} (${objectives.plotsUnlocked}/25)`;
            }
        }
        
        function updateWeatherUI() {
            const weatherTitle = document.querySelector('#weatherPanel > div:first-child');
            if (weatherTitle) {
                weatherTitle.innerHTML = `üå§Ô∏è ${t('weather.title')}`;
            }
            
            const weatherName = document.getElementById('weatherName');
            if (weatherName) {
                weatherName.textContent = t(`weather.${currentWeather.type}`);
            }
            
            const weatherEffect = document.getElementById('weatherEffect');
            if (weatherEffect) {
                weatherEffect.textContent = t(`weather.effect.${currentWeather.type}`);
            }
        }
        
        function updateSeasonUI() {
            const seasonTitle = document.querySelector('#seasonPanel > div:first-child');
            if (seasonTitle) {
                seasonTitle.innerHTML = `üçÇ ${t('season.title')}`;
            }
            
            const seasonName = document.getElementById('seasonName');
            if (seasonName) {
                seasonName.textContent = t(`season.${currentSeason.type}`);
            }
            
            const seasonDay = document.getElementById('seasonDay');
            if (seasonDay) {
                seasonDay.textContent = `${t('season.day')} ${currentSeason.day} ${t('season.of')} ${currentSeason.maxDays}`;
            }
        }
        
        function updateAnimalsUI() {
            const animalsTitle = document.querySelector('#animalsPanel > div:first-child');
            if (animalsTitle) {
                animalsTitle.innerHTML = `üêÑ ${t('animals.title')}`;
            }
            
            // Update animal names and labels
            const animalItems = document.querySelectorAll('#animalsPanel .animal-item');
            animalItems.forEach((item, index) => {
                const animalTypes = ['chicken', 'cow', 'pig'];
                const animalType = animalTypes[index];
                
                if (animalType) {
                    // Update animal name label
                    const animalLabel = item.querySelector('div:first-child div:first-child');
                    if (animalLabel) {
                        const count = animals[animalType]?.count || 0;
                        const animalName = t(`animals.${animalType}s`);
                        animalLabel.innerHTML = `${animalType === 'chicken' ? 'üêî' : animalType === 'cow' ? 'üêÑ' : 'üê∑'} ${animalName}: <span id="${animalType}Count">${count}</span>`;
                    }
                    
                    // Update produce label
                    const produceLabel = item.querySelector('[style*="font-size: 11px"]');
                    if (produceLabel) {
                        const produceType = animalType === 'chicken' ? 'eggs' : animalType === 'cow' ? 'milk' : 'truffles';
                        const produceCount = animals[animalType]?.[produceType] || 0;
                        const produceEmoji = animalType === 'chicken' ? 'ü•ö' : animalType === 'cow' ? 'ü•õ' : 'üçÑ';
                        produceLabel.innerHTML = `${t('animals.produce')}: <span id="${produceType}Count">${produceCount}</span> ${produceEmoji}`;
                    }
                    
                    // Update buy button
                    const buyBtn = item.querySelector(`#buy${animalType.charAt(0).toUpperCase() + animalType.slice(1)}Btn`);
                    if (buyBtn) {
                        const cost = ANIMAL_COSTS[animalType];
                        buyBtn.textContent = `${t('animals.buy')} (${cost}üí∞)`;
                    }
                    
                    // Update collect button
                    const collectBtn = item.querySelector(`#collect${animalType === 'chicken' ? 'Eggs' : animalType === 'cow' ? 'Milk' : 'Truffles'}Btn`);
                    if (collectBtn) {
                        collectBtn.textContent = t('animals.collect');
                    }
                }
            });
        }
        
        function updateQuestsUI() {
            const questsTitle = document.querySelector('#questsPanel > div:first-child');
            if (questsTitle) {
                questsTitle.innerHTML = `üìã ${t('quests.title')}`;
            }
            
            // Update quest descriptions and progress
            dailyQuests.forEach((quest, index) => {
                const questElement = document.querySelector(`#questsPanel .quest-item:nth-child(${index + 1})`);
                if (questElement) {
                    const questTitle = questElement.querySelector('.quest-title');
                    const questDesc = questElement.querySelector('.quest-description');
                    const questProgress = questElement.querySelector('.quest-progress-text');
                    
                    if (questTitle) {
                        const questName = t(`quests.${quest.baseType}`, quest.target);
                        questTitle.textContent = `üìã ${questName}`;
                    }
                    
                    if (questDesc) {
                        questDesc.textContent = t(`quests.${quest.baseType}Desc`);
                    }
                    
                    if (questProgress) {
                        const progress = questProgress[quest.id] || 0;
                        questProgress.textContent = `${t('quests.progress')}: ${progress}/${quest.target} | ${t('quests.reward')}: ${quest.reward}üí∞`;
                    }
                }
            });
            
            // Update new quests button
            const newQuestsBtn = document.querySelector('#questsPanel button');
            if (newQuestsBtn && newQuestsBtn.textContent.includes('New Quests')) {
                newQuestsBtn.innerHTML = `üîÑ ${t('quests.newQuests')} (50üí∞)`;
            }
        }
        
        function updateTimeUI() {
            // Update day/night display
            const timeDisplay = document.getElementById('timeDisplay');
            const cameraMode = document.getElementById('cameraMode');
            
            if (timeDisplay) {
                const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
                const isDay = dayProgress > 0.5;
                timeDisplay.textContent = isDay ? t('time.day') : t('time.night');
            }
            
            if (cameraMode) {
                cameraMode.innerHTML = `${t('time.camera')}: ${t('time.characterFollow')}`;
            }
            
            // Update character status
            const characterStatus = document.getElementById('characterStatus');
            if (characterStatus) {
                const action = character.currentAction || 'idle';
                const actionText = t(`time.${action}`);
                const coords = `(${character.x.toFixed(1)}, ${character.z.toFixed(1)})`;
                
                const closestPlot = findClosestPlot();
                let statusText = `${t('time.character')}: ${actionText} ${coords}`;
                
                if (closestPlot) {
                    const distance = getDistanceToPlot(closestPlot);
                    if (distance <= 2.5) {
                        statusText += ` - Near plot (${distance.toFixed(1)}m)`;
                    }
                }
                
                characterStatus.textContent = statusText;
            }
        }

        // Game state
        let canvas, ctx;
        let score = 0;
        let coins = 50; // Balanced starting amount
        let dayNightCycle = 0;
        let dayNightCycleCount = 0;
        let isGamePaused = false;
        
        // Tutorial system
        let tutorialManager = null;
        let tutorialEnabled = true;
        let tutorialProgress = {
            characterMoved: false,
            cameraToggled: false,
            nearPlot: false,
            plantedSeed: false,
            wateredPlant: false,
            harvestedPlant: false,
            unlockedPlot: false
        };
        
        // Weather System
        let currentWeather = {
            type: 'sunny',
            name: 'Sunny',
            icon: '‚òÄÔ∏è',
            effect: 'Plants grow normally',
            growthMultiplier: 1.0,
            waterDecayMultiplier: 1.0,
            duration: 0,
            maxDuration: 30000 // 30 seconds per weather
        };
        
        const WEATHER_TYPES = {
            sunny: {
                name: 'Sunny',
                icon: '‚òÄÔ∏è',
                effect: 'Plants grow faster',
                growthMultiplier: 1.2,
                waterDecayMultiplier: 1.2,
                bgColor: { r: 135, g: 206, b: 235 },
                probability: 0.3
            },
            cloudy: {
                name: 'Cloudy',
                icon: '‚òÅÔ∏è',
                effect: 'Normal growth, less water loss',
                growthMultiplier: 1.0,
                waterDecayMultiplier: 0.7,
                bgColor: { r: 105, g: 105, b: 105 },
                probability: 0.25
            },
            rainy: {
                name: 'Rainy',
                icon: 'üåßÔ∏è',
                effect: 'Slower growth, plants auto-watered',
                growthMultiplier: 0.8,
                waterDecayMultiplier: -0.5, // Negative means plants gain water
                bgColor: { r: 70, g: 130, b: 180 },
                probability: 0.25
            },
            stormy: {
                name: 'Stormy',
                icon: '‚õàÔ∏è',
                effect: 'Much slower growth, auto-watered',
                growthMultiplier: 0.5,
                waterDecayMultiplier: -0.8,
                bgColor: { r: 47, g: 79, b: 79 },
                probability: 0.2
            }
        };
        
        // Season System  
        let currentSeason = {
            type: 'spring',
            name: 'Spring',
            icon: 'üå∏',
            day: 1,
            maxDays: 20,
            availableCrops: ['carrot', 'tomato'],
            growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
        };
        
        const SEASON_TYPES = {
            spring: {
                name: 'Spring',
                icon: 'üå∏',
                availableCrops: ['carrot', 'tomato', 'potato'],
                growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8, potato: 1.1, cabbage: 0.9, corn: 0.8, watermelon: 0.7, pumpkin: 0.8, apple: 0.9 },
                bgTint: { r: 1.1, g: 1.0, b: 1.0 }
            },
            summer: {
                name: 'Summer',
                icon: '‚òÄÔ∏è',
                availableCrops: ['tomato', 'corn', 'watermelon', 'rare'],
                growthBonus: { carrot: 0.8, tomato: 1.3, rare: 1.1, potato: 0.7, cabbage: 0.6, corn: 1.4, watermelon: 1.3, pumpkin: 0.8, apple: 1.0 },
                bgTint: { r: 1.2, g: 1.1, b: 0.9 }
            },
            autumn: {
                name: 'Autumn',
                icon: 'üçÇ',
                availableCrops: ['carrot', 'potato', 'pumpkin', 'apple', 'rare'],
                growthBonus: { carrot: 1.1, tomato: 0.8, rare: 1.2, potato: 1.0, cabbage: 1.1, corn: 0.6, watermelon: 0.5, pumpkin: 1.3, apple: 1.4 },
                bgTint: { r: 1.1, g: 0.9, b: 0.8 }
            },
            winter: {
                name: 'Winter',
                icon: '‚ùÑÔ∏è',
                availableCrops: ['potato', 'cabbage', 'rare'],
                growthBonus: { carrot: 0.6, tomato: 0.6, rare: 1.0, potato: 1.2, cabbage: 1.3, corn: 0.4, watermelon: 0.3, pumpkin: 0.7, apple: 0.8 },
                bgTint: { r: 0.9, g: 0.9, b: 1.1 }
            }
        };
        
        // Animals System
        let animals = {
            chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 }, // 8 seconds
            cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 }, // 15 seconds  
            pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 } // 20 seconds
        };
        
        const ANIMAL_COSTS = {
            chicken: 30,
            cow: 100,
            pig: 150
        };
        
        const ANIMAL_PRODUCTS = {
            chicken: { name: 'eggs', emoji: 'ü•ö', value: 2 },
            cow: { name: 'milk', emoji: 'ü•õ', value: 5 },
            pig: { name: 'truffles', emoji: 'üçÑ', value: 8 }
        };
        
        // Daily Quests System
        let dailyQuests = [];
        let questProgress = {};
        let lastQuestReset = Date.now();
        
        const QUEST_TYPES = [
            {
                id: 'harvest_plants',
                name: 'Harvest {target} plants',
                description: 'Harvest any type of plant',
                target: [5, 10, 15],
                reward: [15, 25, 40],
                type: 'harvest'
            },
            {
                id: 'plant_seeds',
                name: 'Plant {target} seeds',
                description: 'Plant any type of seed',
                target: [3, 8, 12],
                reward: [10, 20, 35],
                type: 'plant'
            },
            {
                id: 'earn_coins',
                name: 'Earn {target} coins',
                description: 'Earn coins by selling items',
                target: [25, 50, 100],
                reward: [20, 35, 60],
                type: 'coins'
            },
            {
                id: 'collect_animal_products',
                name: 'Collect {target} animal products',
                description: 'Collect eggs, milk, or truffles',
                target: [2, 5, 8],
                reward: [15, 30, 50],
                type: 'collect'
            },
            {
                id: 'water_plants',
                name: 'Water {target} plants',
                description: 'Water growing plants',
                target: [5, 10, 15],
                reward: [10, 18, 30],
                type: 'water'
            }
        ];
        
        // Audio system
        let audioContext;
        let sounds = {
            plant: null,
            harvest: null,
            water: null,
            unlock: null,
            wind: null,
            birds: null
        };
        let windGain, windOscillator;
        let lastBirdSound = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraDistance = 10;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredPlot = null;
        let selectedPlantType = 'carrot';
        let selectedEquipment = null;
        let cameraFollowCharacter = true;
        let freeCameraMode = false;
        
        // Camera follow variables for smooth following
        let cameraFollowX = 0;
        let cameraFollowZ = 0;
        const cameraFollowLerp = 0.1;
        
        // Water decay rate (per second)
        const waterDecayRate = 0.02;
        
        // Auto-save interval (10 seconds)
        let autoSaveInterval;
        
        // Character system
        let character = {
            x: 0,
            y: 0,
            z: 0,
            size: 1,
            color: '#4169E1', // Royal blue
            targetX: 0,
            targetZ: 0,
            moving: false,
            speed: 0.05, // Movement speed
            animationFrame: 0,
            currentAction: 'idle', // idle, walking, planting, watering
            actionTimer: 0,
            direction: 0, // rotation in radians
            targetDirection: 0
        };
        
        // Keyboard state
        let keys = {};
        
        // Control mappings (AZERTY by default)
        let controls = {
            forward: 'KeyZ',
            left: 'KeyQ', 
            backward: 'KeyS',
            right: 'KeyD',
            action: 'Space',
            water: 'KeyE',
            camera: 'KeyC'
        };
        
        // Backup controls for cancelling changes
        let backupControls = {};
        
        // Key recording state
        let recordingKey = null;
        
        // Game objects
        let plots = [];
        let inventory = {
            carrot: 0,
            tomato: 0,
            rare: 0,
            potato: 0,
            cabbage: 0,
            corn: 0,
            watermelon: 0,
            pumpkin: 0,
            apple: 0
        };
        let seedInventory = {
            carrot: 5,
            tomato: 2,
            rare: 1,
            potato: 3,
            cabbage: 2,
            corn: 1,
            watermelon: 1,
            pumpkin: 2,
            apple: 1
        };
        let equipment = {
            sprinkler: 0,
            fertilizer: 0,
            greenhouse: 0
        };
        let animalInventory = {
            eggs: 0,
            milk: 0,
            truffles: 0
        };
        let activeSprinklers = []; // Array of sprinkler positions
        let objectives = {
            carrotsHarvested: 0,
            dayNightCycles: 0,
            coinsEarned: 0,
            plantsHarvested: 0,
            equipmentBought: 0,
            seedsPlanted: 0,
            plotsUnlocked: 9 // Start with 9 plots unlocked (3x3 center)
        };
        
        // Plant types configuration
        const PLANT_TYPES = {
            carrot: {
                name: 'Carrot',
                emoji: 'ü•ï',
                growthTime: 2000, // 2 seconds per stage
                value: 1,
                seedCost: 1,
                color: '#FFA500',
                waterNeed: 0.3,
                dayPreference: true
            },
            tomato: {
                name: 'Tomato',
                emoji: 'üçÖ',
                growthTime: 4000, // 4 seconds per stage
                value: 3,
                seedCost: 2,
                color: '#FF6347',
                waterNeed: 0.5,
                dayPreference: false
            },
            rare: {
                name: 'Rare Plant',
                emoji: '‚ú®',
                growthTime: 8000, // 8 seconds per stage
                value: 10,
                seedCost: 5,
                color: '#9370DB',
                waterNeed: 0.8,
                dayPreference: false
            },
            // New winter plants
            potato: {
                name: 'Potato',
                emoji: 'ü•î',
                growthTime: 3000, // 3 seconds per stage
                value: 2,
                seedCost: 2,
                color: '#8B4513',
                waterNeed: 0.4,
                dayPreference: false
            },
            cabbage: {
                name: 'Cabbage',
                emoji: 'ü•¨',
                growthTime: 5000, // 5 seconds per stage
                value: 4,
                seedCost: 3,
                color: '#228B22',
                waterNeed: 0.6,
                dayPreference: false
            },
            // New summer plants
            corn: {
                name: 'Corn',
                emoji: 'üåΩ',
                growthTime: 6000, // 6 seconds per stage
                value: 5,
                seedCost: 3,
                color: '#FFD700',
                waterNeed: 0.7,
                dayPreference: true
            },
            watermelon: {
                name: 'Watermelon',
                emoji: 'üçâ',
                growthTime: 7000, // 7 seconds per stage
                value: 8,
                seedCost: 4,
                color: '#FF69B4',
                waterNeed: 0.9,
                dayPreference: true
            },
            // New autumn plants
            pumpkin: {
                name: 'Pumpkin',
                emoji: 'üéÉ',
                growthTime: 6500, // 6.5 seconds per stage
                value: 6,
                seedCost: 4,
                color: '#FF7F00',
                waterNeed: 0.5,
                dayPreference: false
            },
            apple: {
                name: 'Apple Tree',
                emoji: 'üçé',
                growthTime: 9000, // 9 seconds per stage
                value: 12,
                seedCost: 6,
                color: '#FF0000',
                waterNeed: 0.4,
                dayPreference: false
            }
        };
        
        // Colors
        const colors = {
            ground: '#228B22',
            plot: '#8B4513',
            seed: '#654321',
            plantStage1: '#90EE90',
            plantStage2: '#32CD32',
            plantStage3: '#006400',
            plotHover: '#CD853F',
            plantHover: '#228B22',
            water: '#87CEEB',
            dryPlot: '#8B7355'
        };
        
        // Plant growth stages
        const PLANT_STAGES = {
            EMPTY: 0,
            PLANTED: 1,
            GROWING1: 2,
            GROWING2: 3,
            MATURE: 4,
            WITHERING: 5
        };
        
        // 3D projection and rendering functions
        function project3D(x, y, z) {
            // Simple perspective projection with zoom support
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Apply camera offset when following character
            let offsetX = 0;
            let offsetZ = 0;
            if (cameraFollowCharacter) {
                offsetX = -cameraFollowX;
                offsetZ = -cameraFollowZ;
            }
            
            // Apply camera rotation
            const cosX = Math.cos(cameraAngleX);
            const sinX = Math.sin(cameraAngleX);
            const cosY = Math.cos(cameraAngleY);
            const sinY = Math.sin(cameraAngleY);
            
            // Apply offset for character following
            const x1_offset = x + offsetX;
            const z1_offset = z + offsetZ;
            
            // Rotate around Y axis then X axis
            const x1 = x1_offset * cosY - z1_offset * sinY;
            const z1 = x1_offset * sinY + z1_offset * cosY;
            const y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX + cameraDistance; // Use cameraDistance for zoom
            
            if (z2 <= 0) z2 = 0.1; // Prevent division by zero
            
            const scale = canvas.width / z2;
            return {
                x: cx + x1 * scale,
                y: cy - y1 * scale,
                z: z2,
                scale: scale
            };
        }
        
        function drawCube(x, y, z, size, color, outline = true) {
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            const projected = vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
            
            // Define faces (front, back, top, bottom, left, right)
            const faces = [
                [0, 1, 2, 3], // front
                [5, 4, 7, 6], // back
                [4, 5, 1, 0], // bottom
                [3, 2, 6, 7], // top
                [4, 0, 3, 7], // left
                [1, 5, 6, 2]  // right
            ];
            
            // Sort faces by average z-depth for proper rendering
            const faceDepths = faces.map(face => {
                const avgZ = face.reduce((sum, i) => sum + projected[i].z, 0) / face.length;
                return { face, depth: avgZ };
            });
            faceDepths.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faceDepths.forEach(({ face }, faceIndex) => {
                ctx.beginPath();
                ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                }
                ctx.closePath();
                
                // Apply lighting based on face orientation and day/night cycle
                const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
                const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
                const faceLight = 0.7 + faceIndex * 0.05; // Different faces have different lighting
                const finalLight = lightIntensity * faceLight;
                
                ctx.fillStyle = adjustColorBrightness(color, finalLight);
                ctx.fill();
                
                if (outline) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
            
            return projected; // Return projected vertices for click detection
        }
        
        function getProjectedCube(x, y, z, size) {
            // Calculate cube projection without drawing - for click detection only
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            return vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
        }
        
        function drawPlane(x, y, z, width, height, color) {
            // Draw ground plane
            const hw = width / 2;
            const hh = height / 2;
            
            const corners = [
                project3D(x - hw, y, z - hh),
                project3D(x + hw, y, z - hh),
                project3D(x + hw, y, z + hh),
                project3D(x - hw, y, z + hh)
            ];
            
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
            ctx.closePath();
            
            // Apply day/night lighting
            const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
            const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
            ctx.fillStyle = adjustColorBrightness(color, lightIntensity);
            ctx.fill();
            
            // Grid lines
            ctx.strokeStyle = adjustColorBrightness('#000', lightIntensity * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            return corners;
        }
        
        function adjustColorBrightness(color, factor) {
            // Convert hex color to RGB and adjust brightness
            const hex = color.replace('#', '');
            const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function isPointInProjectedQuad(point, quad) {
            // Simple point-in-polygon test for click detection
            let inside = false;
            for (let i = 0, j = quad.length - 1; i < quad.length; j = i++) {
                if (((quad[i].y > point.y) !== (quad[j].y > point.y)) &&
                    (point.x < (quad[j].x - quad[i].x) * (point.y - quad[i].y) / (quad[j].y - quad[i].y) + quad[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function plotContainsScreenPoint(x, y, plot) {
            // Use the "top" face of the cube for precise click detection
            const projected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
            
            // Top face vertices are indices [3,2,6,7] of the projected cube
            const topQuad = [
                projected[3], // top-left
                projected[2], // top-right
                projected[6], // bottom-right
                projected[7]  // bottom-left
            ];
            
            return isPointInProjectedQuad({x: x, y: y}, topQuad);
        }
        
        // Save/Load Game System
        function saveGame() {
            const gameState = {
                score: score,
                coins: coins,
                inventory: inventory,
                seedInventory: seedInventory,
                equipment: equipment,
                animalInventory: animalInventory,
                plots: plots.map(plot => ({
                    x: plot.x,
                    y: plot.y,
                    z: plot.z,
                    stage: plot.stage,
                    plantType: plot.plantType,
                    growthTimer: plot.growthTimer,
                    waterLevel: plot.waterLevel,
                    lastWatered: plot.lastWatered,
                    unlocked: plot.unlocked,
                    unlockCost: plot.unlockCost
                })),
                activeSprinklers: activeSprinklers,
                objectives: objectives,
                dayNightCycle: dayNightCycle,
                dayNightCycleCount: dayNightCycleCount,
                cameraFollowX: cameraFollowX,
                cameraFollowZ: cameraFollowZ,
                // New save data
                currentWeather: currentWeather,
                currentSeason: currentSeason,
                animals: animals,
                dailyQuests: dailyQuests,
                questProgress: questProgress,
                lastQuestReset: lastQuestReset
            };
            
            try {
                localStorage.setItem('pixelHarvestSave', JSON.stringify(gameState));
                console.log('Game saved successfully');
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }
        
        function loadGame() {
            try {
                const savedData = localStorage.getItem('pixelHarvestSave');
                if (!savedData) return false;
                
                const gameState = JSON.parse(savedData);
                
                // Restore basic game state
                score = gameState.score || 0;
                coins = gameState.coins || 50;
                inventory = gameState.inventory || { 
                    carrot: 0, tomato: 0, rare: 0, potato: 0, cabbage: 0, 
                    corn: 0, watermelon: 0, pumpkin: 0, apple: 0 
                };
                seedInventory = gameState.seedInventory || { 
                    carrot: 5, tomato: 2, rare: 1, potato: 3, cabbage: 2,
                    corn: 1, watermelon: 1, pumpkin: 2, apple: 1
                };
                equipment = gameState.equipment || { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
                animalInventory = gameState.animalInventory || { eggs: 0, milk: 0, truffles: 0 };
                objectives = gameState.objectives || {
                    carrotsHarvested: 0,
                    dayNightCycles: 0,
                    coinsEarned: 0,
                    plantsHarvested: 0,
                    equipmentBought: 0,
                    seedsPlanted: 0,
                    plotsUnlocked: 9
                };
                dayNightCycle = gameState.dayNightCycle || 0;
                dayNightCycleCount = gameState.dayNightCycleCount || 0;
                cameraFollowX = gameState.cameraFollowX || 0;
                cameraFollowZ = gameState.cameraFollowZ || 0;
                
                // Restore new features with defaults for compatibility
                currentWeather = gameState.currentWeather || {
                    type: 'sunny',
                    name: 'Sunny',
                    icon: '‚òÄÔ∏è',
                    effect: 'Plants grow normally',
                    growthMultiplier: 1.0,
                    waterDecayMultiplier: 1.0,
                    duration: 0,
                    maxDuration: 30000
                };
                
                currentSeason = gameState.currentSeason || {
                    type: 'spring',
                    name: 'Spring',
                    icon: 'üå∏',
                    day: 1,
                    maxDays: 20,
                    availableCrops: ['carrot', 'tomato'],
                    growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
                };
                
                animals = gameState.animals || {
                    chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 },
                    cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 },
                    pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 }
                };
                
                dailyQuests = gameState.dailyQuests || [];
                questProgress = gameState.questProgress || {};
                lastQuestReset = gameState.lastQuestReset || Date.now();
                
                // Restore sprinklers
                activeSprinklers = gameState.activeSprinklers || [];
                
                // Restore plots with plant reconstruction
                if (gameState.plots) {
                    plots = gameState.plots.map(savedPlot => {
                        const plot = {
                            x: savedPlot.x,
                            y: savedPlot.y,
                            z: savedPlot.z,
                            stage: savedPlot.stage,
                            plantType: savedPlot.plantType,
                            growthTimer: savedPlot.growthTimer,
                            waterLevel: savedPlot.waterLevel,
                            lastWatered: savedPlot.lastWatered,
                            unlocked: savedPlot.unlocked,
                            unlockCost: savedPlot.unlockCost,
                            plant: null
                        };
                        
                        // Reconstruct plant object if needed
                        if (plot.stage > PLANT_STAGES.EMPTY && plot.plantType) {
                            const plantConfig = PLANT_TYPES[plot.plantType];
                            let size = 0.3;
                            if (plot.stage === PLANT_STAGES.GROWING1) size = 0.6;
                            else if (plot.stage === PLANT_STAGES.GROWING2) size = 0.9;
                            else if (plot.stage === PLANT_STAGES.MATURE) size = 1.2;
                            
                            plot.plant = {
                                size: size,
                                color: plantConfig.color,
                                baseColor: plantConfig.color
                            };
                            
                            if (plot.stage === PLANT_STAGES.MATURE) {
                                plot.plant.glow = true;
                            }
                            
                            // Handle withered plants
                            if (plot.stage === PLANT_STAGES.WITHERING) {
                                plot.plant.color = adjustColorBrightness(plantConfig.color, 0.5);
                            }
                        }
                        
                        return plot;
                    });
                }
                
                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }
        
        function newGame() {
            // Clear save data
            localStorage.removeItem('pixelHarvestSave');
            
            // Reset all game state
            score = 0;
            coins = 50;
            dayNightCycle = 0;
            dayNightCycleCount = 0;
            cameraFollowX = 0;
            cameraFollowZ = 0;
            
            inventory = { 
                carrot: 0, tomato: 0, rare: 0, potato: 0, cabbage: 0, 
                corn: 0, watermelon: 0, pumpkin: 0, apple: 0 
            };
            seedInventory = { 
                carrot: 5, tomato: 2, rare: 1, potato: 3, cabbage: 2,
                corn: 1, watermelon: 1, pumpkin: 2, apple: 1
            };
            equipment = { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
            animalInventory = { eggs: 0, milk: 0, truffles: 0 };
            activeSprinklers = [];
            objectives = {
                carrotsHarvested: 0,
                dayNightCycles: 0,
                coinsEarned: 0,
                plantsHarvested: 0,
                equipmentBought: 0,
                seedsPlanted: 0,
                plotsUnlocked: 9
            };
            
            // Reset new systems
            currentWeather = {
                type: 'sunny',
                name: 'Sunny',
                icon: '‚òÄÔ∏è',
                effect: 'Plants grow normally',
                growthMultiplier: 1.0,
                waterDecayMultiplier: 1.0,
                duration: 0,
                maxDuration: 30000
            };
            
            currentSeason = {
                type: 'spring',
                name: 'Spring',
                icon: 'üå∏',
                day: 1,
                maxDays: 20,
                availableCrops: ['carrot', 'tomato'],
                growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
            };
            
            animals = {
                chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 },
                cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 },
                pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 }
            };
            
            dailyQuests = [];
            questProgress = {};
            lastQuestReset = Date.now();
            
            // Generate initial quests
            generateDailyQuests();
            
            // Recreate plots
            createPlots();
            
            // Update UI
            updateUI();
            updateObjectives();
            updateWeatherUI();
            updateSeasonUI();
            updateAnimalsUI();
            updateQuestsUI();
            
            // Clear any effects
            if (window.gameEffects) window.gameEffects = [];
            
            console.log('New game started');
        }

        // Weather System Functions
        function updateWeather(deltaTime) {
            currentWeather.duration += deltaTime;
            
            // Check if weather should change
            if (currentWeather.duration >= currentWeather.maxDuration) {
                changeWeather();
            }
            
            // Apply weather effects to background
            updateBackgroundForWeather();
        }
        
        function changeWeather() {
            const weatherTypes = Object.keys(WEATHER_TYPES);
            const probabilities = weatherTypes.map(type => WEATHER_TYPES[type].probability);
            
            // Weighted random selection
            let random = Math.random();
            let selectedWeather = 'sunny';
            
            for (let i = 0; i < weatherTypes.length; i++) {
                random -= probabilities[i];
                if (random <= 0) {
                    selectedWeather = weatherTypes[i];
                    break;
                }
            }
            
            const weatherConfig = WEATHER_TYPES[selectedWeather];
            currentWeather = {
                type: selectedWeather,
                name: weatherConfig.name,
                icon: weatherConfig.icon,
                effect: weatherConfig.effect,
                growthMultiplier: weatherConfig.growthMultiplier,
                waterDecayMultiplier: weatherConfig.waterDecayMultiplier,
                duration: 0,
                maxDuration: 30000 + Math.random() * 20000 // 30-50 seconds
            };
            
            updateWeatherUI();
            saveGame();
        }
        
        
        function updateBackgroundForWeather() {
            const weatherConfig = WEATHER_TYPES[currentWeather.type];
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Blend day/night with weather colors
            const dayColor = weatherConfig.bgColor;
            const nightColor = { r: 25, g: 25, b: 112 };
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }

        // Season System Functions
        let lastDayState = false; // Track day state for season progression
        
        function updateSeason(deltaTime) {
            // Each day/night cycle advances the season by 1 day
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Check for season day advancement
            if (lastDayState !== isDay && isDay) {
                advanceSeasonDay();
            }
            lastDayState = isDay;
        }
        
        function advanceSeasonDay() {
            currentSeason.day++;
            
            if (currentSeason.day > currentSeason.maxDays) {
                changeSeason();
            }
            
            updateSeasonUI();
            saveGame();
        }
        
        function changeSeason() {
            const seasons = ['spring', 'summer', 'autumn', 'winter'];
            const currentIndex = seasons.indexOf(currentSeason.type);
            const nextIndex = (currentIndex + 1) % seasons.length;
            const nextSeasonType = seasons[nextIndex];
            
            const seasonConfig = SEASON_TYPES[nextSeasonType];
            currentSeason = {
                type: nextSeasonType,
                name: seasonConfig.name,
                icon: seasonConfig.icon,
                day: 1,
                maxDays: 20,
                availableCrops: seasonConfig.availableCrops,
                growthBonus: seasonConfig.growthBonus
            };
            
            updateSeasonUI();
            updateUI(); // Update plant buttons based on season
            
            // Show season change notification
            showInstruction(`üçÇ Season changed to ${currentSeason.name}! Available crops updated.`, 3000);
            saveGame();
        }
        
        // Animals System Functions
        function updateAnimals(deltaTime) {
            const currentTime = Date.now();
            
            Object.keys(animals).forEach(animalType => {
                const animal = animals[animalType];
                if (animal.count > 0) {
                    // Check if it's time to produce
                    if (currentTime - animal.lastProduction >= animal.productionRate) {
                        const productName = ANIMAL_PRODUCTS[animalType].name;
                        animal[productName] += animal.count; // Each animal produces 1 item
                        animal.lastProduction = currentTime;
                        updateAnimalsUI();
                        saveGame();
                    }
                }
            });
        }
        
        function buyAnimal(animalType, cost) {
            if (coins >= cost) {
                coins -= cost;
                animals[animalType].count++;
                objectives.equipmentBought++; // Count animals as equipment
                
                updateUI();
                updateAnimalsUI();
                updateObjectives();
                saveGame();
                
                showInstruction(`üêÑ ${animalType.charAt(0).toUpperCase() + animalType.slice(1)} purchased! It will produce resources automatically.`, 2000);
            }
        }
        
        function collectResource(resourceType) {
            let collected = 0;
            
            Object.keys(animals).forEach(animalType => {
                const productInfo = ANIMAL_PRODUCTS[animalType];
                if (productInfo.name === resourceType) {
                    const amount = animals[animalType][resourceType];
                    if (amount > 0) {
                        collected += amount;
                        animals[animalType][resourceType] = 0;
                        
                        // Add to animal inventory instead of selling immediately
                        animalInventory[resourceType] += amount;
                        
                        // Track quest progress
                        updateQuestProgress('collect', amount);
                    }
                }
            });
            
            if (collected > 0) {
                updateUI();
                updateAnimalsUI();
                updateMarketplaceUI();
                updateQuestsUI();
                saveGame();
                
                showInstruction(`üì¶ Collected ${collected} ${resourceType}! Sell them at the marketplace.`, 2000);
            }
        }
        
        // Daily Quests System Functions  
        function generateDailyQuests() {
            dailyQuests = [];
            questProgress = {};
            
            // Generate 3 random quests
            const availableQuests = [...QUEST_TYPES];
            for (let i = 0; i < 3; i++) {
                if (availableQuests.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableQuests.length);
                const questTemplate = availableQuests.splice(randomIndex, 1)[0];
                
                // Random difficulty (0, 1, or 2)
                const difficulty = Math.floor(Math.random() * 3);
                const quest = {
                    id: questTemplate.id + '_' + Date.now() + '_' + i,
                    name: questTemplate.name.replace('{target}', questTemplate.target[difficulty]),
                    description: questTemplate.description,
                    type: questTemplate.type,
                    target: questTemplate.target[difficulty],
                    reward: questTemplate.reward[difficulty],
                    progress: 0,
                    completed: false
                };
                
                dailyQuests.push(quest);
                questProgress[quest.id] = 0;
            }
            
            updateQuestsUI();
            saveGame();
        }
        
        function updateQuestProgress(type, amount = 1) {
            let questsCompleted = false;
            
            dailyQuests.forEach(quest => {
                if (!quest.completed && quest.type === type) {
                    quest.progress = Math.min(quest.target, quest.progress + amount);
                    questProgress[quest.id] = quest.progress;
                    
                    if (quest.progress >= quest.target && !quest.completed) {
                        quest.completed = true;
                        coins += quest.reward;
                        objectives.coinsEarned += quest.reward;
                        questsCompleted = true;
                        
                        showInstruction(`‚úÖ Quest completed! Earned ${quest.reward} coins.`, 2000);
                    }
                }
            });
            
            if (questsCompleted) {
                updateUI();
                updateObjectives();
            }
            
            updateQuestsUI();
            saveGame();
        }
        
        function resetDailyQuests() {
            if (coins >= 50) {
                coins -= 50;
                generateDailyQuests();
                updateUI();
                showInstruction('üîÑ New daily quests generated!', 2000);
            }
        }
        
        
        function init() {
            // Load saved language first
            loadSavedLanguage();
            
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize audio
            initAudio();
            
            // Load saved controls
            loadSavedControls();
            
            // Try to load saved game, otherwise create new game
            if (!loadGame()) {
                // Initialize camera
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
                
                // Create farming plots
                createPlots();
            } else {
                // Initialize camera for loaded game
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
                
                // Generate quests if none exist or it's been too long
                if (dailyQuests.length === 0 || Date.now() - lastQuestReset > 86400000) {
                    generateDailyQuests();
                }
            }
            
            // Add event listeners
            addEventListeners();
            
            // Initialize UI
            setupUI();
            
            // Initialize menu system
            initMenuSystem();
            
            // Initialize new systems UI
            updateWeatherUI();
            updateSeasonUI();
            updateAnimalsUI();
            updateQuestsUI();
            
            // Generate initial daily quests if needed
            if (dailyQuests.length === 0) {
                generateDailyQuests();
            }
            
            // Update instructions with current controls
            updateInstructions();
            
            // Set up auto-save (every 10 seconds)
            autoSaveInterval = setInterval(saveGame, 10000);
            
            // Hide loading screen and show UI with translations
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('dayNightIndicator').style.display = 'block';
            document.getElementById('plantSelector').style.display = 'block';
            document.getElementById('inventory').style.display = 'block';
            document.getElementById('marketplace').style.display = 'block';
            document.getElementById('objectives').style.display = 'block';
            document.getElementById('unifiedMenu').style.display = 'block'; // Show unified menu instead of individual buttons
            document.getElementById('weatherPanel').style.display = 'block';
            document.getElementById('seasonPanel').style.display = 'block';
            document.getElementById('animalsPanel').style.display = 'block';
            document.getElementById('questsPanel').style.display = 'block';
            
            // Update all UI with current language
            updateAllUI();
            
            // Initialize tutorial system
            initTutorialSystem();
            
            // Start game loop
            animate();
        }
        
        // Tutorial System Integration
        async function initTutorialSystem() {
            if (!tutorialEnabled) return;
            
            try {
                // Initialize localization first
                if (window.TutorialLocalization) {
                    TutorialLocalization.initialize();
                }
                
                // Create tutorial manager
                tutorialManager = new TutorialManager();
                
                // Create game interface for tutorial interaction
                const gameInterface = {
                    // Game state checking
                    checkGameState: (conditions) => {
                        for (const [key, expectedValue] of Object.entries(conditions)) {
                            if (tutorialProgress[key] !== expectedValue) {
                                return false;
                            }
                        }
                        return true;
                    },
                    
                    // Game control functions
                    pauseGame: () => {
                        isGamePaused = true;
                    },
                    
                    resumeGame: () => {
                        isGamePaused = false;
                    },
                    
                    focusCharacter: () => {
                        cameraFollowCharacter = true;
                        cameraFollowX = character.x;
                        cameraFollowZ = character.z;
                    },
                    
                    // Tutorial rewards
                    giveReward: (rewards) => {
                        if (rewards.coins) {
                            coins += rewards.coins;
                            showInstruction(`+${rewards.coins} coins earned!`, 2000);
                        }
                        
                        if (rewards.seeds) {
                            for (const [plantType, amount] of Object.entries(rewards.seeds)) {
                                if (!seedInventory[plantType]) {
                                    seedInventory[plantType] = 0;
                                }
                                seedInventory[plantType] += amount;
                                showInstruction(`+${amount} ${plantType} seeds!`, 2000);
                            }
                        }
                        
                        if (rewards.experience) {
                            score += rewards.experience;
                            showInstruction(`+${rewards.experience} experience!`, 2000);
                        }
                        
                        updateUI();
                        saveGame();
                    },
                    
                    // Analytics (optional)
                    trackEvent: (eventName, data) => {
                        console.log('Tutorial Event:', eventName, data);
                        // Could integrate with actual analytics here
                    }
                };
                
                // Initialize tutorial with game interface and steps
                await tutorialManager.initialize(gameInterface, TutorialSteps);
                
                console.log('Tutorial system initialized successfully');
            } catch (error) {
                console.error('Failed to initialize tutorial system:', error);
                tutorialEnabled = false;
            }
        }
        
        // Tutorial progress tracking functions
        function trackTutorialProgress(action, value = true) {
            if (!tutorialManager || !tutorialManager.isActive) return;
            
            tutorialProgress[action] = value;
            
            // Trigger custom events for tutorial step advancement
            if (action === 'nearPlot' && value) {
                document.dispatchEvent(new CustomEvent('tutorialNearPlot'));
            }
        }
        
        // Tutorial helper functions
        function showTutorialMenu() {
            if (tutorialManager && tutorialManager.isAvailable()) {
                tutorialManager.showWelcomeScreen();
            } else {
                showInstruction('Tutorial system not available', 2000);
            }
        }
        
        function restartTutorial() {
            if (tutorialManager) {
                tutorialManager.restartTutorial();
            }
        }
        
        // Audio system functions
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Initialize wind ambience
                initWindAmbience();
                
                // Schedule bird sounds
                scheduleBirdSounds();
                
            } catch (e) {
                console.log('Web Audio API not supported', e);
            }
        }
        
        function initWindAmbience() {
            if (!audioContext) return;
            
            // Create wind sound using brown noise
            const bufferSize = audioContext.sampleRate * 2; // 2 seconds
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 0.1; // Lower volume
            }
            
            const windSource = audioContext.createBufferSource();
            windSource.buffer = buffer;
            windSource.loop = true;
            
            windGain = audioContext.createGain();
            windGain.gain.value = 0.1;
            
            // Create an irregular wind pattern
            const lfo = audioContext.createOscillator();
            lfo.frequency.value = 0.3; // Very slow modulation
            lfo.type = 'sine';
            
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 0.05;
            
            lfo.connect(lfoGain);
            lfoGain.connect(windGain.gain);
            
            windSource.connect(windGain);
            windGain.connect(audioContext.destination);
            
            // Start the wind with proper audio context handling
            const startAudio = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        try {
                            windSource.start();
                            lfo.start();
                        } catch (e) {
                            console.log('Audio already started', e);
                        }
                    });
                } else {
                    try {
                        windSource.start();
                        lfo.start();
                    } catch (e) {
                        console.log('Audio already started', e);
                    }
                }
            };
            
            // Try to start immediately, or wait for user interaction
            if (audioContext.state === 'running') {
                startAudio();
            } else {
                document.addEventListener('click', startAudio, { once: true });
                document.addEventListener('keydown', startAudio, { once: true });
            }
        }
        
        function scheduleBirdSounds() {
            if (!audioContext) return;
            
            const playBirdSound = () => {
                if (Date.now() - lastBirdSound > 15000) { // At least 15 seconds between bird sounds
                    createBirdSound();
                    lastBirdSound = Date.now();
                }
                
                // Schedule next bird sound randomly between 20-60 seconds
                const nextDelay = 20000 + Math.random() * 40000;
                setTimeout(playBirdSound, nextDelay);
            };
            
            // Start first bird sound after 10 seconds
            setTimeout(playBirdSound, 10000);
        }
        
        function createBirdSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Random bird chirp frequency
            const baseFreq = 800 + Math.random() * 1200;
            oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, audioContext.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, audioContext.currentTime + 0.2);
            
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function playActionSound(action) {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                switch (action) {
                    case 'plant':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'triangle';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'harvest':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.1);
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'water':
                        // Water splash sound
                        const whiteNoise = audioContext.createBufferSource();
                        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < buffer.length; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }
                        whiteNoise.buffer = buffer;
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 1000;
                        
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        whiteNoise.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        whiteNoise.start(audioContext.currentTime);
                        whiteNoise.stop(audioContext.currentTime + 0.3);
                        return; // Don't use oscillator for water sound
                        
                    case 'unlock':
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        oscillator.frequency.exponentialRampToValueAtTime(900, audioContext.currentTime + 0.2);
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime);
            } catch (e) {
                console.log('Audio playback error:', e);
            }
        }
        
        function createPlots() {
            // Create a 5x5 grid of farming plots (some locked initially)
            plots = [];
            for (let x = -8; x <= 8; x += 4) {
                for (let z = -8; z <= 8; z += 4) {
                    const distanceFromCenter = Math.sqrt(x*x + z*z);
                    const plot = {
                        x: x,
                        y: 0,
                        z: z,
                        stage: PLANT_STAGES.EMPTY,
                        plant: null,
                        plantType: null,
                        growthTimer: 0,
                        waterLevel: 1.0,
                        lastWatered: Date.now(),
                        unlocked: distanceFromCenter <= 6, // Inner 3x3 grid unlocked initially
                        unlockCost: Math.floor(distanceFromCenter * 2)
                    };
                    plots.push(plot);
                }
            }
        }
        
        function setupUI() {
            // Plant selector buttons
            document.querySelectorAll('.plant-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedPlantType = e.target.dataset.plant;
                });
            });
            
            // Settings button
            document.getElementById('settingsButton').addEventListener('click', openSettings);
            
            // New Game button
            document.getElementById('newGameButton').addEventListener('click', () => {
                if (confirm('Are you sure you want to start a new game? This will delete your current progress.')) {
                    newGame();
                }
            });
            
            updateUI();
        }
        
        function addEventListeners() {
            // Mouse controls
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('contextmenu', onRightClick);
            canvas.addEventListener('wheel', onMouseWheel);
            
            // Keyboard controls
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onKeyDown(event) {
            // Handle key recording
            if (recordingKey) {
                event.preventDefault();
                const keyCode = event.code;
                
                // Update the control mapping
                controls[recordingKey] = keyCode;
                
                // Update the button display
                document.getElementById(`key-${recordingKey}`).textContent = getKeyDisplayName(keyCode);
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                
                // Stop recording
                recordingKey = null;
                
                // Update instructions
                updateInstructions();
                return;
            }
            
            keys[event.code] = true;
            
            // Toggle camera mode
            if (event.code === controls.camera) {
                freeCameraMode = !freeCameraMode;
                cameraFollowCharacter = !freeCameraMode;
                
                // Track camera toggle for tutorial
                trackTutorialProgress('cameraToggled', true);
                
                // Update camera mode display
                document.getElementById('cameraMode').textContent = 
                    freeCameraMode ? 'Camera: Free Mode' : 'Camera: Character Follow';
            }
            
            // Action keys
            if (event.code === controls.action) {
                event.preventDefault();
                performCharacterAction();
            }
            
            if (event.code === controls.water) {
                event.preventDefault();
                performWateringAction();
            }
            
            // Open settings with Escape key
            if (event.code === 'Escape') {
                event.preventDefault();
                if (document.getElementById('settingsMenu').style.display === 'block') {
                    cancelControls();
                } else {
                    openSettings();
                }
            }
            
            // Handle R key for resetting panel positions (only in UI edit mode)
            if (event.code === 'KeyR' && window.uiEditMode) {
                event.preventDefault();
                resetPanelPositions();
            }
        }
        
        function updateInstructions() {
            const forwardKey = getKeyDisplayName(controls.forward);
            const leftKey = getKeyDisplayName(controls.left);
            const backwardKey = getKeyDisplayName(controls.backward);
            const rightKey = getKeyDisplayName(controls.right);
            const actionKey = getKeyDisplayName(controls.action);
            const waterKey = getKeyDisplayName(controls.water);
            const cameraKey = getKeyDisplayName(controls.camera);
            
            document.getElementById('instructions').innerHTML = `
                üå± Move with ${forwardKey}${leftKey}${backwardKey}${rightKey} or arrow keys<br>
                ‚ö° ${actionKey} to plant/harvest at closest plot<br>
                üíß ${waterKey} to water plants<br>
                üìπ ${cameraKey} to toggle camera mode<br>
                üåø Plants grow automatically (3 stages)<br>
                üîí Unlock plots by getting close and pressing ${actionKey}<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view<br>
                üîç Scroll wheel to zoom in/out<br>
                ‚öôÔ∏è ESC to open settings<br>
                üîß UI Mode button to customize interface<br>
                üìù R to reset panel positions (in UI Mode)
            `;
        }
        
        function getKeyDisplayName(keyCode) {
            const keyMap = {
                'KeyZ': 'Z', 'KeyQ': 'Q', 'KeyS': 'S', 'KeyD': 'D',
                'KeyW': 'W', 'KeyA': 'A', 'KeyE': 'E', 'KeyC': 'C',
                'Space': 'SPACE', 'ArrowUp': '‚Üë', 'ArrowDown': '‚Üì',
                'ArrowLeft': '‚Üê', 'ArrowRight': '‚Üí', 'ShiftLeft': 'SHIFT',
                'ControlLeft': 'CTRL', 'AltLeft': 'ALT'
            };
            return keyMap[keyCode] || keyCode.replace('Key', '').replace('Digit', '');
        }
        
        // Settings menu functions
        function openSettings() {
            // Backup current controls
            backupControls = {...controls};
            
            // Update button displays
            updateControlButtons();
            
            // Show settings menu
            document.getElementById('settingsMenu').style.display = 'block';
        }
        
        function updateControlButtons() {
            Object.keys(controls).forEach(action => {
                const button = document.getElementById(`key-${action}`);
                if (button) {
                    button.textContent = getKeyDisplayName(controls[action]);
                }
            });
        }
        
        function recordKey(action) {
            if (recordingKey === action) {
                // Cancel recording
                document.getElementById(`key-${action}`).classList.remove('recording');
                recordingKey = null;
                return;
            }
            
            // Stop any current recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
            }
            
            // Start recording for this action
            recordingKey = action;
            document.getElementById(`key-${action}`).classList.add('recording');
            document.getElementById(`key-${action}`).textContent = 'Press key...';
        }
        
        function setControlPreset(preset) {
            // Stop any recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
            
            switch(preset) {
                case 'azerty':
                    controls.forward = 'KeyZ';
                    controls.left = 'KeyQ';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'qwerty':
                    controls.forward = 'KeyW';
                    controls.left = 'KeyA';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'arrows':
                    controls.forward = 'ArrowUp';
                    controls.left = 'ArrowLeft';
                    controls.backward = 'ArrowDown';
                    controls.right = 'ArrowRight';
                    break;
            }
            
            updateControlButtons();
        }
        
        function saveControls() {
            // Save to localStorage
            localStorage.setItem('pixelHarvestControls', JSON.stringify(controls));
            
            // Update instructions
            updateInstructions();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            recordingKey = null;
        }
        
        function cancelControls() {
            // Restore backup controls
            controls = {...backupControls};
            
            // Update button displays
            updateControlButtons();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
        }
        
        function resetControls() {
            // Reset to AZERTY default
            controls = {
                forward: 'KeyZ',
                left: 'KeyQ',
                backward: 'KeyS',
                right: 'KeyD',
                action: 'Space',
                water: 'KeyE',
                camera: 'KeyC'
            };
            updateControlButtons();
        }
        
        function loadSavedControls() {
            const saved = localStorage.getItem('pixelHarvestControls');
            if (saved) {
                try {
                    controls = JSON.parse(saved);
                } catch (e) {
                    console.log('Failed to load saved controls, using defaults');
                }
            }
        }
        
        function onKeyUp(event) {
            keys[event.code] = false;
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (mouseDown && freeCameraMode) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                // Clear hover state when dragging
                hoveredPlot = null;
            } else if (mouseDown && !freeCameraMode) {
                // In character follow mode, still allow some camera control
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.005; // Reduced sensitivity
                cameraAngleX += deltaY * 0.005;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            } else {
                // Check for plot hover only in free camera mode
                if (freeCameraMode) {
                    hoveredPlot = null;
                    plots.forEach(plot => {
                        if (plotContainsScreenPoint(mouseX, mouseY, plot)) {
                            hoveredPlot = plot;
                        }
                    });
                }
                
                // Update cursor based on hover state and camera mode
                if (freeCameraMode) {
                    canvas.style.cursor = hoveredPlot ? 'pointer' : 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        }
        
        function onMouseUp(event) {
            mouseDown = false;
        }
        
        function onMouseLeave(event) {
            mouseDown = false; // Reset mouse state when leaving canvas
        }
        
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling
            
            // Zoom in/out based on wheel direction
            const zoomSpeed = 0.5;
            const zoomDirection = event.deltaY > 0 ? 1 : -1; // Positive = zoom out, negative = zoom in
            
            cameraDistance += zoomDirection * zoomSpeed;
            
            // Limit zoom range
            cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Min: 3, Max: 20
        }
        
        function onRightClick(event) {
            event.preventDefault();
            
            if (!freeCameraMode) return; // Only allow right-click watering in free camera mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks for watering
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    waterPlot(plot);
                }
            });
        }
        
        function waterPlot(plot) {
            if (plot.stage !== PLANT_STAGES.EMPTY) {
                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.5);
                plot.lastWatered = Date.now();
                
                // Track watering for tutorial
                trackTutorialProgress('wateredPlant', true);
                
                // Update quest progress
                updateQuestProgress('water');
                
                // Play water sound
                playActionSound('water');
                
                // Revive withered plants when watered
                if (plot.stage === PLANT_STAGES.WITHERING && plot.waterLevel > 0.3) {
                    // Determine what stage the plant should return to based on its growth timer
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    const growthProgress = Math.floor(plot.growthTimer / plantConfig.growthTime);
                    
                    if (growthProgress >= 2) {
                        plot.stage = PLANT_STAGES.GROWING2;
                    } else if (growthProgress >= 1) {
                        plot.stage = PLANT_STAGES.GROWING1;
                    } else {
                        plot.stage = PLANT_STAGES.PLANTED;
                    }
                    
                    // Restore plant color
                    if (plot.plant) {
                        plot.plant.color = plot.plant.baseColor || PLANT_TYPES[plot.plantType].color;
                    }
                }
                
                // Visual feedback for watering
                createWaterEffect(plot);
                updateQuestsUI();
                saveGame(); // Auto-save after watering
            }
        }
        
        function createWaterEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'water',
                emoji: 'üíß'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function onMouseClick(event) {
            if (mouseDown || !freeCameraMode) return; // Ignore clicks during drag or in character mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks without drawing
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    handlePlotClick(plot);
                }
            });
        }
        
        function handlePlotClick(plot) {
            // Handle equipment placement
            if (selectedEquipment === 'sprinkler' && plot.unlocked) {
                // Check if there's already a sprinkler here
                const existingSprinkler = activeSprinklers.find(s => s.x === plot.x && s.z === plot.z);
                if (!existingSprinkler) {
                    activeSprinklers.push({
                        x: plot.x,
                        y: plot.y + 1,
                        z: plot.z,
                        range: 6, // Affects plots within 6 units
                        lastSprinkleTime: 0  // Initialize to 0 for immediate first sprinkle
                    });
                    
                    equipment.sprinkler--; // Remove from inventory
                    selectedEquipment = null;
                    canvas.style.cursor = 'crosshair';
                    
                    showInstruction('Auto Sprinkler placed! It will water nearby plants automatically.', 2000);
                    updateUI();
                    saveGame(); // Auto-save after placing sprinkler
                }
                return;
            }
            
            if (!plot.unlocked) {
                // Try to unlock the plot
                if (coins >= plot.unlockCost) {
                    coins -= plot.unlockCost;
                    plot.unlocked = true;
                    objectives.plotsUnlocked++; // Increment unlocked plots counter
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    
                    // Create unlock effect
                    createUnlockEffect(plot);
                }
                return;
            }
            
            if (plot.stage === PLANT_STAGES.EMPTY) {
                plantSeed(plot, selectedPlantType);
            } else if (plot.stage === PLANT_STAGES.MATURE) {
                harvestPlant(plot);
            }
        }
        
        function createUnlockEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'unlock',
                emoji: 'üîì'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function plantSeed(plot, plantType) {
            if (seedInventory[plantType] <= 0) {
                return; // No seeds available
            }
            
            // Check if plant type is available in current season
            if (!currentSeason.availableCrops.includes(plantType)) {
                showInstruction(`‚ùÑÔ∏è ${PLANT_TYPES[plantType].name} is not available in ${currentSeason.name}!`, 2000);
                return;
            }
            
            const plantConfig = PLANT_TYPES[plantType];
            seedInventory[plantType]--;
            objectives.seedsPlanted++;
            
            // Track planting for tutorial
            trackTutorialProgress('plantedSeed', true);
            
            plot.stage = PLANT_STAGES.PLANTED;
            plot.plantType = plantType;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            plot.lastWatered = Date.now();
            plot.plant = {
                size: 0.3,
                color: plantConfig.color,
                baseColor: plantConfig.color
            };
            
            // Update quest progress
            updateQuestProgress('plant');
            
            // Play plant sound
            playActionSound('plant');
            
            updateUI();
            updateObjectives();
            updateQuestsUI();
            saveGame(); // Auto-save after planting
        }
        
        function growPlant(plot) {
            const plantConfig = PLANT_TYPES[plot.plantType];
            
            if (plot.stage === PLANT_STAGES.PLANTED) {
                plot.stage = PLANT_STAGES.GROWING1;
                plot.plant.size = 0.6;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING1) {
                plot.stage = PLANT_STAGES.GROWING2;
                plot.plant.size = 0.9;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING2) {
                plot.stage = PLANT_STAGES.MATURE;
                plot.plant.size = 1.2;
                // Add glow effect for mature plants
                plot.plant.glow = true;
            }
        }
        
        function harvestPlant(plot) {
            if (plot.stage !== PLANT_STAGES.MATURE) return;
            
            const plantType = plot.plantType;
            const plantConfig = PLANT_TYPES[plantType];
            
            // Add to inventory
            inventory[plantType]++;
            
            // Track harvesting for tutorial
            trackTutorialProgress('harvestedPlant', true);
            
            // Add score (dynamic based on weather/season)
            const dynamicValue = getDynamicPrice(plantType, 'sell');
            score += dynamicValue;
            
            // Update objectives
            if (plantType === 'carrot') {
                objectives.carrotsHarvested++;
            }
            objectives.plantsHarvested++;
            
            // Update quest progress
            updateQuestProgress('harvest');
            
            // Reset plot
            plot.stage = PLANT_STAGES.EMPTY;
            plot.plant = null;
            plot.plantType = null;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            
            // Play harvest sound
            playActionSound('harvest');
            
            // Create harvest effect with animation
            createHarvestEffect(plot);
            
            updateUI();
            updateObjectives();
            updateQuestsUI();
            saveGame(); // Auto-save after harvesting
        }
        
        function createHarvestEffect(plot) {
            // Create floating score animation
            const effect = {
                x: plot.x,
                y: plot.y + 2,
                z: plot.z,
                timer: 0,
                duration: 2000,
                type: 'harvest'
            };
            
            // Add to effects array (we'll create this)
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function updateEffects(deltaTime) {
            if (!window.gameEffects) return;
            
            // Update and remove expired effects
            window.gameEffects = window.gameEffects.filter(effect => {
                effect.timer += deltaTime;
                effect.y += deltaTime * 0.001; // Float upward
                
                return effect.timer < effect.duration;
            });
        }
        
        function renderEffects() {
            if (!window.gameEffects) return;
            
            window.gameEffects.forEach(effect => {
                const alpha = 1 - (effect.timer / effect.duration);
                ctx.save();
                ctx.globalAlpha = alpha;
                
                const projected = project3D(effect.x, effect.y, effect.z);
                
                if (effect.type === 'harvest') {
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+1', projected.x, projected.y);
                } else if (effect.type === 'plant' || effect.type === 'water' || effect.type === 'unlock') {
                    // Action effects with emoji
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(effect.emoji, projected.x, projected.y);
                    
                    // Add action name below emoji
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    let actionName = '';
                    if (effect.type === 'plant') actionName = 'Planted!';
                    else if (effect.type === 'water') actionName = 'Watered!';
                    else if (effect.type === 'unlock') actionName = 'Unlocked!';
                    
                    ctx.strokeText(actionName, projected.x, projected.y + 20);
                    ctx.fillText(actionName, projected.x, projected.y + 20);
                }
                
                ctx.restore();
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateUI() {
            // Update score and coins
            document.getElementById('score').textContent = `${t('score')}: ${score}`;
            document.getElementById('coins').textContent = coins;
            
            // Use the new translation-aware UI update functions
            updateInventoryUI();
            updatePlantSelectorUI();
            updateMarketplaceUI();
            updateAnimalsUI();
        }
        
        function updateObjectives() {
            // Use the new translation-aware objectives update function
            updateObjectivesUI();
            
            // Update objective completion states and visibility
            updateObjectiveVisibility();
        }
        
        function updateObjectiveVisibility() {
            // Show or hide objectives based on progress
            const objectives4 = document.getElementById('objective4');
            const objectives5 = document.getElementById('objective5');
            const objectives6 = document.getElementById('objective6');
            const objectives7 = document.getElementById('objective7');
            const objectives8 = document.getElementById('objective8');
            
            // Show advanced objectives when basic ones are complete
            const basicComplete = objectives.carrotsHarvested >= 5 && 
                                   objectives.dayNightCycles >= 2 && 
                                   objectives.coinsEarned >= 20;
            
            if (basicComplete) {
                if (objectives4) objectives4.style.display = 'block';
                if (objectives5) objectives5.style.display = 'block';
                if (objectives6) objectives6.style.display = 'block';
                if (objectives7) objectives7.style.display = 'block';
                if (objectives8) objectives8.style.display = 'block';
                
                // Color completed objectives
                document.getElementById('objective1').style.color = '#4CAF50';
                document.getElementById('objective2').style.color = '#4CAF50';
                document.getElementById('objective3').style.color = '#4CAF50';
            }
            
            if (objectives.plantsHarvested >= 25 && objectives.equipmentBought >= 1) {
                document.getElementById('objective4').style.color = '#4CAF50';
                document.getElementById('objective5').style.color = '#4CAF50';
            }
            
            if (objectives.coinsEarned >= 500) {
                document.getElementById('objective6').style.color = '#4CAF50';
            }
            
            if (objectives.seedsPlanted >= 50) {
                document.getElementById('objective7').style.color = '#4CAF50';
            }
            
            if (objectives.plotsUnlocked >= 25) {
                document.getElementById('objective8').style.color = '#4CAF50';
            }
        }
        
        // Marketplace functions with dynamic pricing
        function getDynamicPrice(plantType, action = 'sell') {
            const basePrice = PLANT_TYPES[plantType].value;
            let priceMultiplier = 1.0;
            
            // Weather effects on prices
            if (currentWeather.type === 'rainy' || currentWeather.type === 'stormy') {
                // High demand during bad weather
                priceMultiplier *= 1.3;
            } else if (currentWeather.type === 'sunny') {
                // Normal demand during good weather
                priceMultiplier *= 1.1;
            }
            
            // Season effects on prices
            if (currentSeason.availableCrops.includes(plantType)) {
                // In-season crops have lower prices (more supply)
                priceMultiplier *= 0.9;
            } else {
                // Out-of-season crops have higher prices (less supply)
                priceMultiplier *= 1.4;
            }
            
            // Different multiplier for seed purchases vs selling
            if (action === 'buy') {
                priceMultiplier *= 1.2; // Seeds cost more than selling price
            }
            
            return Math.ceil(basePrice * priceMultiplier);
        }
        
        function sellAll(plantType) {
            const count = inventory[plantType];
            if (count <= 0) return;
            
            const price = getDynamicPrice(plantType, 'sell');
            const earnings = count * price;
            
            inventory[plantType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            // Update quest progress
            updateQuestProgress('coins', earnings);
            
            updateUI();
            updateObjectives();
            updateMarketplaceUI();
            saveGame(); // Auto-save after selling
        }
        
        function sellAnimalProduct(productType) {
            const count = animalInventory[productType];
            if (count <= 0) return;
            
            let price = 0;
            if (productType === 'eggs') price = 2;
            else if (productType === 'milk') price = 5;
            else if (productType === 'truffles') price = 8;
            
            const earnings = count * price;
            
            animalInventory[productType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            // Update quest progress
            updateQuestProgress('coins', earnings);
            
            updateUI();
            updateObjectives();
            updateMarketplaceUI();
            saveGame(); // Auto-save after selling
        }
        
        function buySeeds(plantType, baseCost) {
            const dynamicCost = getDynamicPrice(plantType, 'buy');
            if (coins >= dynamicCost) {
                coins -= dynamicCost;
                seedInventory[plantType] += 5; // Buy 5 seeds at a time
                updateUI();
                updateMarketplaceUI();
                saveGame(); // Auto-save after buying seeds
            }
        }
        

        
        function buyItem(itemType, cost) {
            if (coins >= cost) {
                coins -= cost;
                equipment[itemType]++;
                objectives.equipmentBought++;
                
                // Special handling for different equipment
                if (itemType === 'sprinkler') {
                    // Player needs to place the sprinkler
                    selectedEquipment = 'sprinkler';
                    canvas.style.cursor = 'crosshair';
                    showInstruction('Click on a plot to place the Auto Sprinkler!', 3000);
                } else if (itemType === 'fertilizer') {
                    // Fertilizer is applied automatically to all plants
                    showInstruction('Fertilizer pack applied! All plants grow 20% faster.', 2000);
                } else if (itemType === 'greenhouse') {
                    // Greenhouse provides passive benefits
                    showInstruction('Mini Greenhouse built! Plants grow better day and night.', 2000);
                }
                
                updateUI();
                updateObjectives();
                saveGame(); // Auto-save after buying equipment
            }
        }
        
        function showInstruction(text, duration) {
            // Create a temporary instruction overlay
            const instruction = document.createElement('div');
            instruction.style.position = 'absolute';
            instruction.style.top = '50%';
            instruction.style.left = '50%';
            instruction.style.transform = 'translate(-50%, -50%)';
            instruction.style.background = 'rgba(0, 0, 0, 0.8)';
            instruction.style.color = 'white';
            instruction.style.padding = '15px 25px';
            instruction.style.borderRadius = '10px';
            instruction.style.fontSize = '18px';
            instruction.style.zIndex = '200';
            instruction.style.border = '2px solid #4CAF50';
            instruction.textContent = text;
            
            document.body.appendChild(instruction);
            
            setTimeout(() => {
                document.body.removeChild(instruction);
            }, duration);
        }
        
        function updateDayNightCycle() {
            const oldProgress = (Math.sin(dayNightCycle) + 1) / 2;
            dayNightCycle += 0.01;
            const newProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Check for day/night cycle completion
            if (oldProgress > 0.5 && newProgress <= 0.5) {
                dayNightCycleCount++;
                objectives.dayNightCycles = dayNightCycleCount;
                updateObjectives();
            }
            
            // Calculate day/night progression
            const dayProgress = newProgress;
            const isDay = dayProgress > 0.5;
            
            // Update time display
            document.getElementById('timeDisplay').textContent = isDay ? 'Day' : 'Night';
            
            // Update background color
            const dayColor = { r: 135, g: 206, b: 235 }; // Sky blue
            const nightColor = { r: 25, g: 25, b: 112 }; // Midnight blue
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }
        
        function updatePlantGrowth(deltaTime) {
            const currentTime = Date.now();
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Auto-sprinkler functionality - deterministic timing
            activeSprinklers.forEach(sprinkler => {
                // Check if 5 seconds have passed since last sprinkle
                if (currentTime - sprinkler.lastSprinkleTime >= 5000) {
                    plots.forEach(plot => {
                        if (plot.stage !== PLANT_STAGES.EMPTY) {
                            const distance = Math.sqrt(
                                Math.pow(plot.x - sprinkler.x, 2) + 
                                Math.pow(plot.z - sprinkler.z, 2)
                            );
                            
                            if (distance <= sprinkler.range && plot.waterLevel < 0.8) {
                                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.3);
                                plot.lastWatered = currentTime;
                                
                                // Create water effect
                                createWaterEffect(plot);
                            }
                        }
                    });
                    
                    // Update last sprinkle time
                    sprinkler.lastSprinkleTime = currentTime;
                }
            });
            
            plots.forEach(plot => {
                if (plot.stage !== PLANT_STAGES.EMPTY && plot.stage !== PLANT_STAGES.MATURE) {
                    // Water decay/gain based on weather
                    const deltaTimeSeconds = deltaTime / 1000;
                    let waterChange = currentWeather.waterDecayMultiplier * waterDecayRate * deltaTimeSeconds;
                    
                    // If weather has negative water decay (rain), plants gain water
                    if (currentWeather.waterDecayMultiplier < 0) {
                        plot.waterLevel = Math.min(1.0, plot.waterLevel - waterChange);
                    } else {
                        plot.waterLevel = Math.max(0, plot.waterLevel - waterChange);
                    }
                    
                    // Get plant configuration
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    
                    // Calculate growth speed based on conditions
                    let growthMultiplier = 1;
                    
                    // Weather effects
                    growthMultiplier *= currentWeather.growthMultiplier;
                    
                    // Season effects
                    const seasonBonus = currentSeason.growthBonus[plot.plantType] || 1.0;
                    growthMultiplier *= seasonBonus;
                    
                    // Equipment bonuses
                    if (equipment.fertilizer > 0) {
                        growthMultiplier *= 1.2; // 20% faster growth with fertilizer
                    }
                    
                    if (equipment.greenhouse > 0) {
                        growthMultiplier *= 1.1; // 10% faster growth with greenhouse
                        // Greenhouse also provides weather protection
                        if (!isDay) growthMultiplier *= 1.2; // Better night growth
                    }
                    
                    // Day/night preference
                    if (plantConfig.dayPreference === isDay) {
                        growthMultiplier *= 1.5;
                    } else {
                        growthMultiplier *= 0.7;
                    }
                    
                    // Water level affects growth
                    if (plot.waterLevel > plantConfig.waterNeed) {
                        growthMultiplier *= 1.2;
                    } else if (plot.waterLevel < plantConfig.waterNeed * 0.5) {
                        growthMultiplier *= 0.5;
                    }
                    
                    // Check for proximity bonus (plants grow faster near other plants)
                    const nearbyPlants = plots.filter(otherPlot => {
                        if (otherPlot === plot || otherPlot.stage === PLANT_STAGES.EMPTY) return false;
                        const distance = Math.sqrt(
                            Math.pow(plot.x - otherPlot.x, 2) + Math.pow(plot.z - otherPlot.z, 2)
                        );
                        return distance <= 4.5; // Adjacent plots
                    });
                    
                    if (nearbyPlants.length > 0) {
                        growthMultiplier *= (1 + nearbyPlants.length * 0.1);
                    }
                    
                    // Apply growth
                    plot.growthTimer += deltaTime * growthMultiplier;
                    
                    // Check if plant should grow
                    if (plot.growthTimer >= plantConfig.growthTime) {
                        growPlant(plot);
                    }
                    
                    // Check if plant should wither due to lack of water
                    if (plot.waterLevel <= 0 && plot.stage !== PLANT_STAGES.WITHERING) {
                        plot.stage = PLANT_STAGES.WITHERING;
                        // Store baseColor if not already stored, then darken
                        if (!plot.plant.baseColor) {
                            plot.plant.baseColor = plot.plant.color;
                        }
                        plot.plant.color = adjustColorBrightness(plot.plant.baseColor, 0.5);
                    }
                }
            });
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground (larger now)
            drawPlane(0, 0, 0, 25, 25, colors.ground);
            
            // Draw plots and plants
            plots.forEach(plot => {
                if (!plot.unlocked) {
                    // Draw locked plot with different color
                    drawCube(plot.x, plot.y + 0.1, plot.z, 2, '#555555');
                    
                    // Draw unlock cost indicator
                    const projected = project3D(plot.x, plot.y + 1, plot.z);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${plot.unlockCost}üí∞`, projected.x, projected.y);
                    return;
                }
                
                // Determine if plot should be highlighted
                const isHovered = hoveredPlot === plot;
                let plotColor = colors.plot;
                
                // Show different colors based on water level
                if (plot.stage !== PLANT_STAGES.EMPTY) {
                    if (plot.waterLevel < 0.3) {
                        plotColor = colors.dryPlot;
                    } else if (plot.waterLevel > 0.8) {
                        plotColor = adjustColorBrightness(colors.plot, 1.2);
                    }
                }
                
                if (isHovered) {
                    plotColor = colors.plotHover;
                }
                
                // Draw plot
                drawCube(plot.x, plot.y + 0.1, plot.z, 2, plotColor);
                
                // Draw plant if exists
                if (plot.plant) {
                    let plantColor = plot.plant.color;
                    
                    // Add glow effect for mature plants
                    if (plot.stage === PLANT_STAGES.MATURE && plot.plant.glow) {
                        const glowIntensity = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
                        plantColor = adjustColorBrightness(plot.plant.color, 1 + glowIntensity * 0.3);
                        
                        // Draw glow effect around mature plants
                        const glowSize = plot.plant.size * 1.3;
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, glowSize, '#FFFF00', false);
                        ctx.restore();
                    }
                    
                    if (isHovered) {
                        plantColor = adjustColorBrightness(plantColor, 1.3);
                    }
                    
                    drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, plot.plant.size, plantColor);
                    
                    // Draw water level indicator for watered plants
                    if (plot.waterLevel > 0.8 && plot.stage !== PLANT_STAGES.EMPTY) {
                        ctx.save();
                        ctx.globalAlpha = 0.4;
                        drawCube(plot.x, plot.y + 0.15, plot.z, 2.2, colors.water, false);
                        ctx.restore();
                    }
                }
            });
            
            // Draw character
            drawCharacter();
            
            // Draw sprinklers
            drawSprinklers();
            
            // Add some decorative elements
            drawDecorations();
            
            // Render visual effects
            renderEffects();
        }
        
        function drawSprinklers() {
            activeSprinklers.forEach(sprinkler => {
                // Draw sprinkler base
                drawCube(sprinkler.x, sprinkler.y, sprinkler.z, 1, '#4169E1');
                
                // Draw sprinkler head
                drawCube(sprinkler.x, sprinkler.y + 0.5, sprinkler.z, 0.6, '#87CEEB');
                
                // Draw water effect if it's working (show for 1 second after sprinkle)
                if (Date.now() - sprinkler.lastSprinkleTime < 1000) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw water spray area
                    const projected = project3D(sprinkler.x, sprinkler.y + 0.8, sprinkler.z);
                    const radiusScale = sprinkler.range * 10; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#87CEEB';
                    ctx.fill();
                    ctx.restore();
                }
            });
        }
        
        function drawDecorations() {
            // Add trees around the farm
            const trees = [
                { x: -12, y: 0, z: -12 },
                { x: 12, y: 0, z: -12 },
                { x: -12, y: 0, z: 12 },
                { x: 12, y: 0, z: 12 }
            ];
            
            trees.forEach(tree => {
                // Tree trunk
                drawCube(tree.x, tree.y + 0.5, tree.z, 1, '#8B4513');
                // Tree leaves
                drawCube(tree.x, tree.y + 1.5, tree.z, 2.5, '#228B22');
            });
            
            // Add rocks
            const rocks = [
                { x: -10, y: 0, z: 0 },
                { x: 10, y: 0, z: 0 },
                { x: 0, y: 0, z: -10 },
                { x: 0, y: 0, z: 10 }
            ];
            
            rocks.forEach(rock => {
                drawCube(rock.x, rock.y + 0.3, rock.z, 1.5, '#696969');
            });
            
            // Draw fences around the unlocked farm area
            const unlockedPlots = plots.filter(p => p.unlocked);
            if (unlockedPlots.length > 0) {
                const minX = Math.min(...unlockedPlots.map(p => p.x)) - 2;
                const maxX = Math.max(...unlockedPlots.map(p => p.x)) + 2;
                const minZ = Math.min(...unlockedPlots.map(p => p.z)) - 2;
                const maxZ = Math.max(...unlockedPlots.map(p => p.z)) + 2;
                
                // Draw fence posts
                for (let x = minX; x <= maxX; x += 4) {
                    drawCube(x, 0.4, minZ, 0.3, '#8B4513'); // North fence
                    drawCube(x, 0.4, maxZ, 0.3, '#8B4513'); // South fence
                }
                for (let z = minZ; z <= maxZ; z += 4) {
                    drawCube(minX, 0.4, z, 0.3, '#8B4513'); // West fence
                    drawCube(maxX, 0.4, z, 0.3, '#8B4513'); // East fence
                }
            }
        }
        
        function updateCharacter(deltaTime) {
            // Handle keyboard input for movement
            let moveX = 0;
            let moveZ = 0;
            
            // Desktop controls
            if (keys[controls.forward] || keys['ArrowUp']) moveZ -= 1;
            if (keys[controls.backward] || keys['ArrowDown']) moveZ += 1;
            if (keys[controls.left] || keys['ArrowLeft']) moveX -= 1;
            if (keys[controls.right] || keys['ArrowRight']) moveX += 1;
            
            // Mobile joystick controls
            if (mobileControlsEnabled && (joystickInput.x !== 0 || joystickInput.y !== 0)) {
                moveX -= joystickInput.x; // Reversed left/right direction for mobile
                moveZ += joystickInput.y; // Note: Y axis is typically inverted for joysticks
            }
            
            // Normalize movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
                
                // Calculate target direction
                character.targetDirection = Math.atan2(moveX, moveZ);
                
                // Set target position
                character.targetX = character.x + moveX * character.speed * deltaTime;
                character.targetZ = character.z + moveZ * character.speed * deltaTime;
                
                // Constrain to farm area
                const maxDistance = 10;
                character.targetX = Math.max(-maxDistance, Math.min(maxDistance, character.targetX));
                character.targetZ = Math.max(-maxDistance, Math.min(maxDistance, character.targetZ));
                
                character.moving = true;
                character.currentAction = 'walking';
            } else {
                character.moving = false;
                if (character.currentAction === 'walking') {
                    character.currentAction = 'idle';
                }
            }
            
            // Smooth movement
            if (character.moving) {
                const lerpFactor = 0.1;
                character.x += (character.targetX - character.x) * lerpFactor;
                character.z += (character.targetZ - character.z) * lerpFactor;
                
                // Track character movement for tutorial
                trackTutorialProgress('characterMoved', true);
            }
            
            // Smooth rotation
            const angleDiff = character.targetDirection - character.direction;
            let adjustedAngleDiff = angleDiff;
            
            // Handle angle wrapping
            if (adjustedAngleDiff > Math.PI) {
                adjustedAngleDiff -= 2 * Math.PI;
            } else if (adjustedAngleDiff < -Math.PI) {
                adjustedAngleDiff += 2 * Math.PI;
            }
            
            character.direction += adjustedAngleDiff * 0.1;
            
            // Update animation frame
            if (character.moving) {
                character.animationFrame += deltaTime * 0.01;
            }
            
            // Update action timer
            if (character.actionTimer > 0) {
                character.actionTimer -= deltaTime;
                if (character.actionTimer <= 0) {
                    character.currentAction = 'idle';
                }
            }
            
            // Update camera to follow character
            if (cameraFollowCharacter) {
                updateCameraFollow();
            }
            
            // Update character status display
            updateCharacterStatusDisplay();
        }
        
        function updateCharacterStatusDisplay() {
            const statusElement = document.getElementById('characterStatus');
            let statusText = `Character: ${character.currentAction.charAt(0).toUpperCase() + character.currentAction.slice(1)}`;
            
            // Add position info
            statusText += ` (${character.x.toFixed(1)}, ${character.z.toFixed(1)})`;
            
            // Add closest plot info
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                if (distance <= 2.5) {
                    statusText += ` - Near plot (${distance.toFixed(1)}m)`;
                    
                    // Track being near plot for tutorial
                    trackTutorialProgress('nearPlot', true);
                } else {
                    // Track being away from plot for tutorial
                    trackTutorialProgress('nearPlot', false);
                }
            }
            
            statusElement.textContent = statusText;
            
            // Color code based on action
            if (character.currentAction === 'walking') {
                statusElement.style.color = '#87CEEB';
            } else if (character.currentAction === 'planting') {
                statusElement.style.color = '#32CD32';
            } else if (character.currentAction === 'watering') {
                statusElement.style.color = '#4169E1';
            } else {
                statusElement.style.color = '#FFD700';
            }
        }
        
        function updateCameraFollow() {
            // Smoothly lerp camera follow position to character position
            cameraFollowX += (character.x - cameraFollowX) * cameraFollowLerp;
            cameraFollowZ += (character.z - cameraFollowZ) * cameraFollowLerp;
        }
        
        function drawCharacter() {
            // Character body
            let characterColor = character.color;
            
            // Apply action-based color changes
            if (character.currentAction === 'planting') {
                characterColor = '#32CD32'; // Green for planting
            } else if (character.currentAction === 'watering') {
                characterColor = '#87CEEB'; // Light blue for watering
            }
            
            // Add walking animation bob
            let yOffset = 0;
            if (character.moving && character.currentAction === 'walking') {
                yOffset = Math.sin(character.animationFrame * 5) * 0.1;
            }
            
            // Draw character body
            drawCube(
                character.x, 
                character.y + character.size/2 + yOffset, 
                character.z, 
                character.size, 
                characterColor
            );
            
            // Draw character head
            drawCube(
                character.x, 
                character.y + character.size * 1.3 + yOffset, 
                character.z, 
                character.size * 0.6, 
                '#FDBCB4' // Skin color
            );
            
            // Draw direction indicator (small arrow)
            const arrowSize = 0.3;
            const arrowDistance = character.size * 0.8;
            const arrowX = character.x + Math.sin(character.direction) * arrowDistance;
            const arrowZ = character.z + Math.cos(character.direction) * arrowDistance;
            
            drawCube(arrowX, character.y + character.size + yOffset, arrowZ, arrowSize, '#FFD700');
            
            // Draw interaction radius for closest plot
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                
                // Draw interaction radius
                if (distance <= 2.5) {
                    // Draw green circle around character to show interaction is possible
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const projected = project3D(character.x, character.y + 0.1, character.z);
                    const radiusScale = 50; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw line to closest plot
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    const plotProjected = project3D(closestPlot.x, closestPlot.y + 0.5, closestPlot.z);
                    ctx.beginPath();
                    ctx.moveTo(projected.x, projected.y);
                    ctx.lineTo(plotProjected.x, plotProjected.y);
                    ctx.stroke();
                    ctx.restore();
                    
                    // Show action hint above character
                    ctx.save();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.lineWidth = 1;
                    
                    let actionText = '';
                    if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to plant`;
                    } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to harvest`;
                    } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to unlock (${closestPlot.unlockCost}üí∞)`;
                    } else if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                        actionText = `üíß ${getKeyDisplayName(controls.water)} to water`;
                    }
                    
                    if (actionText) {
                        const textY = projected.y - 60;
                        ctx.strokeText(actionText, projected.x, textY);
                        ctx.fillText(actionText, projected.x, textY);
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        function performCharacterAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                    // Plant seed
                    plantSeedAtPlot(closestPlot);
                    character.currentAction = 'planting';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create planting effect
                    createActionEffect(character.x, character.y + 1, character.z, 'plant', 'üå±');
                } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                    // Harvest plant
                    harvestPlant(closestPlot);
                    character.currentAction = 'planting'; // Reuse planting animation
                    character.actionTimer = 1000;
                    
                    // Create harvest effect
                    createActionEffect(character.x, character.y + 1, character.z, 'harvest', '‚ú®');
                } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                    // Unlock plot
                    coins -= closestPlot.unlockCost;
                    closestPlot.unlocked = true;
                    objectives.plotsUnlocked++;
                    
                    // Track plot unlocking for tutorial
                    trackTutorialProgress('unlockedPlot', true);
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    character.currentAction = 'planting';
                    character.actionTimer = 1000;
                    
                    // Create unlock effect
                    createActionEffect(character.x, character.y + 1, character.z, 'unlock', 'üîì');
                }
            }
        }
        
        function performWateringAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                    waterPlot(closestPlot);
                    character.currentAction = 'watering';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create watering effect
                    createActionEffect(character.x, character.y + 1, character.z, 'water', 'üíß');
                }
            }
        }
        
        function createActionEffect(x, y, z, type, emoji) {
            const effect = {
                x: x,
                y: y,
                z: z,
                timer: 0,
                duration: 1500,
                type: type,
                emoji: emoji,
                startY: y
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function findClosestPlot() {
            let closestPlot = null;
            let closestDistance = Infinity;
            
            plots.forEach(plot => {
                const distance = getDistanceToPlot(plot);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPlot = plot;
                }
            });
            
            return closestPlot;
        }
        
        function getDistanceToPlot(plot) {
            return Math.sqrt(
                Math.pow(character.x - plot.x, 2) + 
                Math.pow(character.z - plot.z, 2)
            );
        }
        
        function plantSeedAtPlot(plot) {
            if (seedInventory[selectedPlantType] <= 0) {
                return; // No seeds available
            }
            
            plantSeed(plot, selectedPlantType);
        }
        
        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update character
            updateCharacter(deltaTime);
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update new systems
            updateWeather(deltaTime);
            updateSeason(deltaTime);
            updateAnimals(deltaTime);
            
            // Update plant growth with new weather/season effects
            updatePlantGrowth(deltaTime);
            
            // Update visual effects
            updateEffects(deltaTime);
            
            // Render scene
            render();
        }
        
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update mobile controls state
            const isMobile = window.innerWidth <= 768;
            const mobileControls = document.getElementById('mobileControls');
            
            if (isMobile && !mobileControlsEnabled) {
                mobileControlsEnabled = true;
                if (mobileControls) mobileControls.style.display = 'block';
                updateInstructionsForMobile();
            } else if (!isMobile && mobileControlsEnabled) {
                mobileControlsEnabled = false;
                if (mobileControls) mobileControls.style.display = 'none';
                updateInstructionsForDesktop();
            }
            
            // Update joystick center when window resizes
            if (mobileControlsEnabled) {
                setTimeout(updateJoystickCenter, 100);
            }
        }

        function updateInstructionsForMobile() {
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = `
                    üïπÔ∏è Use virtual joystick to move<br>
                    üå± Green button to plant/harvest<br>
                    üíß Blue button to water plants<br>
                    üìπ Purple button to toggle camera<br>
                    üîç Pinch to zoom, drag to rotate camera<br>
                    üìã Tap bottom menu buttons for inventory, plants, etc.<br>
                    üåø Plants grow automatically (3 stages)<br>
                    üîí Get close to plots and tap green button to unlock<br>
                    üåô Watch the day/night cycle!
                `;
            }
        }

        function updateInstructionsForDesktop() {
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = `
                    üå± Move with ZQSD or arrow keys<br>
                    ‚ö° SPACE to plant/harvest at closest plot<br>
                    üíß E to water plants<br>
                    üìπ C to toggle camera mode<br>
                    üåø Plants grow automatically (3 stages)<br>
                    üîí Unlock plots by getting close and pressing SPACE<br>
                    üåô Watch the day/night cycle!<br>
                    üñ±Ô∏è Drag to rotate camera view<br>
                    üîç Scroll wheel to zoom in/out
                `;
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);

        // UI Dragging and Resizing System
        window.uiEditMode = false; // Make global for access
        let draggedPanel = null;
        let resizingPanel = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStartData = { x: 0, y: 0, width: 0, height: 0 };

        // Panel configuration - defines which panels are draggable
        const draggablePanels = [
            { id: 'ui', name: 'Info' },
            { id: 'plantSelector', name: 'Plants' },
            { id: 'inventory', name: 'Inventory' },
            { id: 'marketplace', name: 'Market' },
            { id: 'objectives', name: 'Goals' },
            { id: 'weatherPanel', name: 'Weather' },
            { id: 'seasonPanel', name: 'Season' },
            { id: 'animalsPanel', name: 'Animals' },
            { id: 'questsPanel', name: 'Quests' }
        ];

        function initDraggableUI() {
            // Add UI mode toggle functionality
            const uiModeToggle = document.getElementById('uiModeToggle');
            uiModeToggle.addEventListener('click', toggleUIEditMode);

            // Setup each draggable panel
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    setupDraggablePanel(panel, panelConfig.name);
                }
            });

            // Load saved panel positions and sizes
            loadPanelStates();

            // Add global mouse event listeners
            document.addEventListener('mousemove', handleGlobalMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);
        }

        function setupDraggablePanel(panel, name) {
            // Add draggable class
            panel.classList.add('draggable-panel');

            // Create drag handle
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle';
            dragHandle.textContent = name;
            panel.appendChild(dragHandle);

            // Create resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            panel.appendChild(resizeHandle);

            // Add panel content wrapper if needed
            const children = Array.from(panel.children).filter(child => 
                !child.classList.contains('drag-handle') && !child.classList.contains('resize-handle')
            );
            
            if (children.length > 0 && !panel.querySelector('.panel-content')) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'panel-content';
                children.forEach(child => contentWrapper.appendChild(child));
                panel.appendChild(contentWrapper);
            }

            // Add event listeners
            dragHandle.addEventListener('mousedown', (e) => startDragging(e, panel));
            resizeHandle.addEventListener('mousedown', (e) => startResizing(e, panel));

            // Prevent default drag behavior
            dragHandle.addEventListener('dragstart', (e) => e.preventDefault());
        }

        function toggleUIEditMode() {
            window.uiEditMode = !window.uiEditMode;
            const toggle = document.getElementById('uiModeToggle');
            
            if (window.uiEditMode) {
                toggle.classList.add('active');
                toggle.textContent = '‚úÖ UI Mode';
                document.body.style.cursor = 'default';
                
                // Show all drag handles
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    if (panel) {
                        panel.style.border = '2px dashed rgba(76, 175, 80, 0.5)';
                        const handle = panel.querySelector('.drag-handle');
                        if (handle) {
                            handle.style.opacity = '1';
                            handle.style.visibility = 'visible';
                        }
                        const resizeHandle = panel.querySelector('.resize-handle');
                        if (resizeHandle) {
                            resizeHandle.style.opacity = '1';
                            resizeHandle.style.visibility = 'visible';
                        }
                    }
                });
                
                showInstruction('UI Edit Mode ON - Drag panels by their handles, resize from bottom-right corner', 3000);
            } else {
                toggle.classList.remove('active');
                toggle.textContent = 'üîß UI Mode';
                
                // Hide drag handles
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    if (panel) {
                        panel.style.border = '2px solid transparent';
                        const handle = panel.querySelector('.drag-handle');
                        if (handle) {
                            handle.style.opacity = '0';
                            handle.style.visibility = 'hidden';
                        }
                        const resizeHandle = panel.querySelector('.resize-handle');
                        if (resizeHandle) {
                            resizeHandle.style.opacity = '0';
                            resizeHandle.style.visibility = 'hidden';
                        }
                    }
                });
                
                showInstruction('UI Edit Mode OFF - Panels locked in position', 2000);
                savePanelStates();
            }
        }

        function startDragging(e, panel) {
            if (!window.uiEditMode) return;
            
            e.preventDefault();
            draggedPanel = panel;
            panel.classList.add('dragging');
            
            const rect = panel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            // Bring panel to front
            panel.style.zIndex = '1000';
        }

        function startResizing(e, panel) {
            if (!window.uiEditMode) return;
            
            e.preventDefault();
            resizingPanel = panel;
            
            const rect = panel.getBoundingClientRect();
            resizeStartData = {
                x: e.clientX,
                y: e.clientY,
                width: rect.width,
                height: rect.height
            };
            
            panel.style.transition = 'none';
        }

        function handleGlobalMouseMove(e) {
            if (draggedPanel) {
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Constrain to viewport
                const maxX = window.innerWidth - draggedPanel.offsetWidth;
                const maxY = window.innerHeight - draggedPanel.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(maxX, newX));
                const constrainedY = Math.max(0, Math.min(maxY, newY));
                
                draggedPanel.style.left = constrainedX + 'px';
                draggedPanel.style.top = constrainedY + 'px';
                draggedPanel.style.right = 'auto';
                draggedPanel.style.bottom = 'auto';
            }
            
            if (resizingPanel) {
                const deltaX = e.clientX - resizeStartData.x;
                const deltaY = e.clientY - resizeStartData.y;
                
                const newWidth = Math.max(150, resizeStartData.width + deltaX);
                const newHeight = Math.max(100, resizeStartData.height + deltaY);
                
                // Constrain to viewport
                const rect = resizingPanel.getBoundingClientRect();
                const maxWidth = window.innerWidth - rect.left;
                const maxHeight = window.innerHeight - rect.top;
                
                resizingPanel.style.width = Math.min(newWidth, maxWidth) + 'px';
                resizingPanel.style.height = Math.min(newHeight, maxHeight) + 'px';
            }
        }

        function handleGlobalMouseUp(e) {
            if (draggedPanel) {
                draggedPanel.classList.remove('dragging');
                draggedPanel.style.zIndex = '100';
                draggedPanel = null;
            }
            
            if (resizingPanel) {
                resizingPanel.style.transition = '';
                resizingPanel = null;
            }
        }

        function savePanelStates() {
            const panelStates = {};
            
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    const style = window.getComputedStyle(panel);
                    panelStates[panelConfig.id] = {
                        left: panel.style.left || style.left,
                        top: panel.style.top || style.top,
                        width: panel.style.width || style.width,
                        height: panel.style.height || style.height,
                        right: panel.style.right,
                        bottom: panel.style.bottom
                    };
                }
            });
            
            localStorage.setItem('pixelHarvestPanelStates', JSON.stringify(panelStates));
            console.log('Panel states saved');
        }

        function loadPanelStates() {
            try {
                const savedStates = localStorage.getItem('pixelHarvestPanelStates');
                if (!savedStates) return;
                
                const panelStates = JSON.parse(savedStates);
                
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    const state = panelStates[panelConfig.id];
                    
                    if (panel && state) {
                        // Apply saved position and size
                        if (state.left && state.left !== 'auto') {
                            panel.style.left = state.left;
                            panel.style.right = 'auto';
                        }
                        if (state.top && state.top !== 'auto') {
                            panel.style.top = state.top;
                            panel.style.bottom = 'auto';
                        }
                        if (state.width && state.width !== 'auto') {
                            panel.style.width = state.width;
                        }
                        if (state.height && state.height !== 'auto') {
                            panel.style.height = state.height;
                        }
                    }
                });
                
                console.log('Panel states loaded');
            } catch (e) {
                console.error('Failed to load panel states:', e);
            }
        }

        function resetPanelPositions() {
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    panel.style.left = '';
                    panel.style.top = '';
                    panel.style.right = '';
                    panel.style.bottom = '';
                    panel.style.width = '';
                    panel.style.height = '';
                }
            });
            
            localStorage.removeItem('pixelHarvestPanelStates');
            showInstruction('Panel positions reset to defaults', 2000);
        }

        // Mobile Controls System
        let mobileControlsEnabled = false;
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickRadius = 60;
        let joystickInput = { x: 0, y: 0 };
        let touchStartPos = { x: 0, y: 0 };
        let lastTouchCameraPos = { x: 0, y: 0 };
        let cameraRotationTouch = false;

        function initMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            const joystick = document.getElementById('mobileJoystick');
            const joystickHandle = document.getElementById('joystickHandle');
            const actionBtn = document.getElementById('mobileActionBtn');
            const waterBtn = document.getElementById('mobileWaterBtn');
            const cameraBtn = document.getElementById('mobileCameraBtn');
            const zoomInBtn = document.getElementById('mobileZoomInBtn');
            const zoomOutBtn = document.getElementById('mobileZoomOutBtn');

            // Enhanced mobile device detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                            ('ontouchstart' in window) || 
                            (navigator.maxTouchPoints > 0) ||
                            (window.innerWidth <= 768);

            if (isMobile) {
                mobileControlsEnabled = true;
                mobileControls.style.display = 'block';
                
                // Update instructions for mobile
                updateInstructionsForMobile();
                
                // Add mobile-specific meta tag if not present
                if (!document.querySelector('meta[name="viewport"]')) {
                    const viewport = document.createElement('meta');
                    viewport.name = 'viewport';
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                    document.head.appendChild(viewport);
                }
            }

            // Joystick event handlers
            if (joystick) {
                // Touch events
                joystick.addEventListener('touchstart', startJoystick, { passive: false });
                joystick.addEventListener('touchmove', moveJoystick, { passive: false });
                joystick.addEventListener('touchend', endJoystick, { passive: false });
                
                // Mouse events for testing on desktop
                joystick.addEventListener('mousedown', startJoystickMouse);
                joystick.addEventListener('mousemove', moveJoystickMouse);
                joystick.addEventListener('mouseup', endJoystickMouse);
                joystick.addEventListener('mouseleave', endJoystickMouse);
            }

            // Action button events
            if (actionBtn) {
                actionBtn.addEventListener('touchstart', () => performMobileAction('action'), { passive: true });
                actionBtn.addEventListener('click', () => performMobileAction('action'));
            }

            if (waterBtn) {
                waterBtn.addEventListener('touchstart', () => performMobileAction('water'), { passive: true });
                waterBtn.addEventListener('click', () => performMobileAction('water'));
            }

            if (cameraBtn) {
                cameraBtn.addEventListener('touchstart', () => performMobileAction('camera'), { passive: true });
                cameraBtn.addEventListener('click', () => performMobileAction('camera'));
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('touchstart', () => performMobileAction('zoomIn'), { passive: true });
                zoomInBtn.addEventListener('click', () => performMobileAction('zoomIn'));
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('touchstart', () => performMobileAction('zoomOut'), { passive: true });
                zoomOutBtn.addEventListener('click', () => performMobileAction('zoomOut'));
            }

            // Touch gestures for camera control on canvas
            if (canvas) {
                canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });
            }

            // Update joystick center position
            updateJoystickCenter();
        }

        function updateJoystickCenter() {
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) {
                const rect = joystick.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
                joystickRadius = rect.width / 2 - 20; // Leave some margin
            }
        }

        // Joystick touch handlers
        function startJoystick(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            updateJoystickCenter();
            updateJoystickPosition(touch.clientX, touch.clientY);
            
            // Add visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.add('active');
            
            // Add haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        function moveJoystick(e) {
            e.preventDefault();
            if (!joystickActive) return;
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function endJoystick(e) {
            e.preventDefault();
            joystickActive = false;
            resetJoystickPosition();
            
            // Remove visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.remove('active');
        }

        // Joystick mouse handlers (for desktop testing)
        function startJoystickMouse(e) {
            joystickActive = true;
            updateJoystickCenter();
            updateJoystickPosition(e.clientX, e.clientY);
            
            // Add visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.add('active');
        }

        function moveJoystickMouse(e) {
            if (!joystickActive) return;
            updateJoystickPosition(e.clientX, e.clientY);
        }

        function endJoystickMouse(e) {
            joystickActive = false;
            resetJoystickPosition();
            
            // Remove visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.remove('active');
        }

        function updateJoystickPosition(clientX, clientY) {
            const deltaX = clientX - joystickCenter.x;
            const deltaY = clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance <= joystickRadius) {
                // Inside joystick area
                joystickInput.x = deltaX / joystickRadius;
                joystickInput.y = deltaY / joystickRadius;
                
                const handle = document.getElementById('joystickHandle');
                if (handle) {
                    handle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                }
            } else {
                // Outside joystick area, clamp to edge
                const angle = Math.atan2(deltaY, deltaX);
                const clampedX = Math.cos(angle) * joystickRadius;
                const clampedY = Math.sin(angle) * joystickRadius;
                
                joystickInput.x = clampedX / joystickRadius;
                joystickInput.y = clampedY / joystickRadius;
                
                const handle = document.getElementById('joystickHandle');
                if (handle) {
                    handle.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
                }
            }
        }

        function resetJoystickPosition() {
            joystickInput.x = 0;
            joystickInput.y = 0;
            const handle = document.getElementById('joystickHandle');
            if (handle) {
                handle.style.transform = 'translate(0px, 0px)';
            }
        }

        function toggleCameraMode() {
            freeCameraMode = !freeCameraMode;
            cameraFollowCharacter = !freeCameraMode;
            
            // Track camera toggle for tutorial
            trackTutorialProgress('cameraToggled', true);
            
            // Update camera mode display
            document.getElementById('cameraMode').textContent = 
                freeCameraMode ? 'Camera: Free Camera' : 'Camera: Character Follow';
        }

        function performMobileAction(action) {
            // Add visual feedback
            const button = event.target;
            button.classList.add('touched');
            setTimeout(() => button.classList.remove('touched'), 200);

            // Add haptic feedback if supported
            if (navigator.vibrate) {
                navigator.vibrate(50); // Short vibration feedback
            }

            switch (action) {
                case 'action':
                    performCharacterAction();
                    break;
                case 'water':
                    performWateringAction();
                    break;
                case 'camera':
                    toggleCameraMode();
                    break;
                case 'zoomIn':
                    cameraDistance = Math.max(5, cameraDistance - 1);
                    break;
                case 'zoomOut':
                    cameraDistance = Math.min(20, cameraDistance + 1);
                    break;
            }
        }

        // Canvas touch handlers for camera control
        function handleCanvasTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - start camera rotation
                cameraRotationTouch = true;
                lastTouchCameraPos.x = e.touches[0].clientX;
                lastTouchCameraPos.y = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches - prepare for pinch zoom
                cameraRotationTouch = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartPos.distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }
        }

        function handleCanvasTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && cameraRotationTouch) {
                // Single touch - rotate camera
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchCameraPos.x;
                const deltaY = touch.clientY - lastTouchCameraPos.y;
                
                // Apply camera rotation
                cameraAngleY += deltaX * 0.01;
                cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX + deltaY * 0.01));
                
                lastTouchCameraPos.x = touch.clientX;
                lastTouchCameraPos.y = touch.clientY;
            } else if (e.touches.length === 2) {
                // Two touches - pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                if (touchStartPos.distance) {
                    const scale = currentDistance / touchStartPos.distance;
                    cameraDistance = Math.max(5, Math.min(20, cameraDistance / scale));
                    touchStartPos.distance = currentDistance;
                }
            }
        }

        function handleCanvasTouchEnd(e) {
            e.preventDefault();
            cameraRotationTouch = false;
            touchStartPos.distance = 0;
        }

        // Window resize handler for mobile
        function onWindowResizeMobile() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update mobile controls state
            const isMobile = window.innerWidth <= 768;
            const mobileControls = document.getElementById('mobileControls');
            
            if (isMobile && !mobileControlsEnabled) {
                mobileControlsEnabled = true;
                if (mobileControls) mobileControls.style.display = 'block';
            } else if (!isMobile && mobileControlsEnabled) {
                mobileControlsEnabled = false;
                if (mobileControls) mobileControls.style.display = 'none';
            }
            
            // Update joystick center when window resizes
            if (mobileControlsEnabled) {
                setTimeout(updateJoystickCenter, 100);
            }
        }

        // Initialize draggable UI when the game loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                initDraggableUI();
                initMobileControls();
                initMobileInterface();
            }, 100); // Small delay to ensure game is initialized
        });

        // Mobile Interface System
        let currentMobilePanel = null;

        function initMobileInterface() {
            // Setup mobile navigation buttons
            const navButtons = document.querySelectorAll('.mobile-nav-btn');
            navButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const panelType = btn.dataset.panel;
                    toggleMobilePanel(panelType);
                });
            });

            // Setup mobile panel close buttons
            const closeButtons = document.querySelectorAll('.mobile-panel-close');
            closeButtons.forEach(btn => {
                btn.addEventListener('click', closeMobilePanels);
            });

            // Close panels when clicking outside
            document.addEventListener('click', (e) => {
                if (currentMobilePanel && 
                    !e.target.closest('.mobile-panel') && 
                    !e.target.closest('.mobile-nav-btn')) {
                    closeMobilePanels();
                }
            });

            // Initialize mobile panel content
            updateMobilePanels();
            
            // Update mobile interface periodically
            setInterval(updateMobilePanels, 1000);
        }

        function toggleMobilePanel(panelType) {
            const panelId = `mobile${panelType.charAt(0).toUpperCase() + panelType.slice(1)}Panel`;
            const panel = document.getElementById(panelId);
            
            if (!panel) return;

            // Close current panel if different panel is being opened
            if (currentMobilePanel && currentMobilePanel !== panelId) {
                document.getElementById(currentMobilePanel).classList.remove('active');
            }

            // Toggle the requested panel
            if (currentMobilePanel === panelId) {
                panel.classList.remove('active');
                currentMobilePanel = null;
                
                // Remove active state from navigation button
                document.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
            } else {
                panel.classList.add('active');
                currentMobilePanel = panelId;
                
                // Add active state to navigation button
                document.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
                document.querySelector(`[data-panel="${panelType}"]`).classList.add('active');
                
                // Update panel content
                updateMobilePanelContent(panelType);
            }

            // Add haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        function closeMobilePanels() {
            if (currentMobilePanel) {
                document.getElementById(currentMobilePanel).classList.remove('active');
                currentMobilePanel = null;
                
                // Remove active state from all navigation buttons
                document.querySelectorAll('.mobile-nav-btn').forEach(btn => btn.classList.remove('active'));
            }
        }

        function updateMobilePanels() {
            // Update badges
            updateMobileBadges();
            
            // Update coins display
            const mobileCoins = document.getElementById('mobileCoins');
            if (mobileCoins) mobileCoins.textContent = coins;
            
            // Update active panel content if open
            if (currentMobilePanel) {
                const panelType = currentMobilePanel.replace('mobile', '').replace('Panel', '').toLowerCase();
                updateMobilePanelContent(panelType);
            }
        }

        function updateMobileBadges() {
            // Inventory badge (total items)
            const inventoryTotal = Object.values(inventory).reduce((sum, count) => sum + count, 0) +
                                 Object.values(animalInventory).reduce((sum, count) => sum + count, 0);
            const inventoryBadge = document.getElementById('inventoryBadge');
            if (inventoryBadge) {
                inventoryBadge.textContent = inventoryTotal;
                inventoryBadge.style.display = inventoryTotal > 0 ? 'flex' : 'none';
            }

            // Plants badge (available seeds)
            const seedsTotal = Object.values(seedInventory).reduce((sum, count) => sum + count, 0);
            const plantsBadge = document.getElementById('plantsBadge');
            if (plantsBadge) {
                plantsBadge.textContent = seedsTotal;
            }

            // Animals badge (total animals)
            const animalsTotal = Object.values(animals).reduce((sum, animal) => sum + (animal.count || 0), 0);
            const animalsBadge = document.getElementById('animalsBadge');
            if (animalsBadge) {
                animalsBadge.textContent = animalsTotal;
                animalsBadge.style.display = animalsTotal > 0 ? 'flex' : 'none';
            }

            // Quests badge (available quests)
            const questsBadge = document.getElementById('questsBadge');
            if (questsBadge) {
                questsBadge.textContent = dailyQuests.length;
            }
        }

        function updateMobilePanelContent(panelType) {
            switch(panelType) {
                case 'inventory':
                    updateMobileInventoryContent();
                    break;
                case 'plants':
                    updateMobilePlantsContent();
                    break;
                case 'market':
                    updateMobileMarketContent();
                    break;
                case 'animals':
                    updateMobileAnimalsContent();
                    break;
                case 'quests':
                    updateMobileQuestsContent();
                    break;
            }
        }

        function updateMobileInventoryContent() {
            const content = document.getElementById('mobileInventoryContent');
            if (!content) return;

            let html = '<div class="mobile-grid">';
            
            // Add crops
            Object.keys(inventory).forEach(itemType => {
                const count = inventory[itemType];
                const plantConfig = PLANT_TYPES[itemType];
                if (plantConfig && count > 0) {
                    html += `
                        <div class="mobile-grid-item">
                            <div class="emoji">${plantConfig.emoji}</div>
                            <div class="name">${plantConfig.name}</div>
                            <div class="count">${count}</div>
                        </div>
                    `;
                }
            });

            // Add animal products
            Object.keys(animalInventory).forEach(productType => {
                const count = animalInventory[productType];
                if (count > 0) {
                    const emoji = productType === 'eggs' ? 'ü•ö' : productType === 'milk' ? 'ü•õ' : 'üçÑ';
                    const name = productType.charAt(0).toUpperCase() + productType.slice(1);
                    html += `
                        <div class="mobile-grid-item">
                            <div class="emoji">${emoji}</div>
                            <div class="name">${name}</div>
                            <div class="count">${count}</div>
                        </div>
                    `;
                }
            });

            // Add equipment
            Object.keys(equipment).forEach(equipType => {
                const count = equipment[equipType];
                if (count > 0) {
                    const emoji = equipType === 'sprinkler' ? 'üíß' : equipType === 'fertilizer' ? 'üåø' : 'üè†';
                    const name = equipType.charAt(0).toUpperCase() + equipType.slice(1);
                    html += `
                        <div class="mobile-grid-item">
                            <div class="emoji">${emoji}</div>
                            <div class="name">${name}</div>
                            <div class="count">${count}</div>
                        </div>
                    `;
                }
            });

            html += '</div>';
            
            if (html === '<div class="mobile-grid"></div>') {
                html = '<div style="text-align: center; color: #999; padding: 40px;">Your inventory is empty</div>';
            }

            content.innerHTML = html;
        }

        function updateMobilePlantsContent() {
            const grid = document.getElementById('mobilePlantsGrid');
            if (!grid) return;

            let html = '';
            
            Object.keys(PLANT_TYPES).forEach(plantType => {
                const plantConfig = PLANT_TYPES[plantType];
                const seedCount = seedInventory[plantType] || 0;
                const isSelected = selectedPlantType === plantType;
                const hasSeeds = seedCount > 0;
                
                html += `
                    <div class="mobile-grid-item ${isSelected ? 'selected' : ''} ${!hasSeeds ? 'disabled' : ''}" 
                         onclick="selectMobilePlant('${plantType}')">
                        <div class="emoji">${plantConfig.emoji}</div>
                        <div class="name">${plantConfig.name}</div>
                        <div class="count">Seeds: ${seedCount}</div>
                    </div>
                `;
            });

            grid.innerHTML = html;
        }

        function selectMobilePlant(plantType) {
            if (seedInventory[plantType] > 0) {
                selectedPlantType = plantType;
                updateMobilePlantsContent();
                updateUI();
            }
        }

        function updateMobileMarketContent() {
            const content = document.getElementById('mobileMarketContent');
            if (!content) return;

            let html = `
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">üí∞ Sell Produce</h3>
                    <div class="mobile-grid">
            `;
            
            // Sell items
            Object.keys(inventory).forEach(itemType => {
                const count = inventory[itemType];
                const plantConfig = PLANT_TYPES[itemType];
                if (plantConfig && count > 0) {
                    const price = getDynamicPrice(itemType, 'sell');
                    html += `
                        <div class="mobile-grid-item" onclick="sellAll('${itemType}')">
                            <div class="emoji">${plantConfig.emoji}</div>
                            <div class="name">Sell ${plantConfig.name}s</div>
                            <div class="count">${count} items</div>
                            <div class="price">${price}üí∞ each</div>
                        </div>
                    `;
                }
            });

            html += `
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <h3 style="color: #FFD700; margin-bottom: 15px;">üå± Buy Seeds</h3>
                    <div class="mobile-grid">
            `;

            // Buy seeds
            Object.keys(PLANT_TYPES).forEach(plantType => {
                const plantConfig = PLANT_TYPES[plantType];
                const price = getDynamicPrice(plantType, 'buy');
                const canAfford = coins >= price;
                
                html += `
                    <div class="mobile-grid-item ${!canAfford ? 'disabled' : ''}" 
                         onclick="buySeeds('${plantType}', ${price})">
                        <div class="emoji">${plantConfig.emoji}</div>
                        <div class="name">${plantConfig.name} Seeds</div>
                        <div class="price">${price}üí∞</div>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
                <div>
                    <h3 style="color: #FFD700; margin-bottom: 15px;">üîß Equipment</h3>
                    <div class="mobile-grid">
                        <div class="mobile-grid-item ${coins < 150 ? 'disabled' : ''}" 
                             onclick="buyItem('sprinkler', 150)">
                            <div class="emoji">üíß</div>
                            <div class="name">Auto Sprinkler</div>
                            <div class="price">150üí∞</div>
                        </div>
                        <div class="mobile-grid-item ${coins < 50 ? 'disabled' : ''}" 
                             onclick="buyItem('fertilizer', 50)">
                            <div class="emoji">üåø</div>
                            <div class="name">Fertilizer Pack</div>
                            <div class="price">50üí∞</div>
                        </div>
                        <div class="mobile-grid-item ${coins < 300 ? 'disabled' : ''}" 
                             onclick="buyItem('greenhouse', 300)">
                            <div class="emoji">üè†</div>
                            <div class="name">Mini Greenhouse</div>
                            <div class="price">300üí∞</div>
                        </div>
                    </div>
                </div>
            `;

            content.innerHTML = html;
        }

        function updateMobileAnimalsContent() {
            const content = document.getElementById('mobileAnimalsContent');
            if (!content) return;

            let html = '<div class="mobile-grid">';
            
            // Chickens
            html += `
                <div class="mobile-grid-item" onclick="buyAnimal('chicken', 30)">
                    <div class="emoji">üêî</div>
                    <div class="name">Buy Chicken</div>
                    <div class="count">Owned: ${animals.chicken?.count || 0}</div>
                    <div class="price">30üí∞</div>
                </div>
                <div class="mobile-grid-item ${(animalInventory.eggs || 0) === 0 ? 'disabled' : ''}" 
                     onclick="collectResource('eggs')">
                    <div class="emoji">ü•ö</div>
                    <div class="name">Collect Eggs</div>
                    <div class="count">${animalInventory.eggs || 0} available</div>
                </div>
            `;

            // Cows
            html += `
                <div class="mobile-grid-item ${coins < 100 ? 'disabled' : ''}" onclick="buyAnimal('cow', 100)">
                    <div class="emoji">üêÑ</div>
                    <div class="name">Buy Cow</div>
                    <div class="count">Owned: ${animals.cow?.count || 0}</div>
                    <div class="price">100üí∞</div>
                </div>
                <div class="mobile-grid-item ${(animalInventory.milk || 0) === 0 ? 'disabled' : ''}" 
                     onclick="collectResource('milk')">
                    <div class="emoji">ü•õ</div>
                    <div class="name">Collect Milk</div>
                    <div class="count">${animalInventory.milk || 0} available</div>
                </div>
            `;

            // Pigs
            html += `
                <div class="mobile-grid-item ${coins < 150 ? 'disabled' : ''}" onclick="buyAnimal('pig', 150)">
                    <div class="emoji">üê∑</div>
                    <div class="name">Buy Pig</div>
                    <div class="count">Owned: ${animals.pig?.count || 0}</div>
                    <div class="price">150üí∞</div>
                </div>
                <div class="mobile-grid-item ${(animalInventory.truffles || 0) === 0 ? 'disabled' : ''}" 
                     onclick="collectResource('truffles')">
                    <div class="emoji">üçÑ</div>
                    <div class="name">Collect Truffles</div>
                    <div class="count">${animalInventory.truffles || 0} available</div>
                </div>
            `;

            html += '</div>';
            content.innerHTML = html;
        }

        function updateMobileQuestsContent() {
            const content = document.getElementById('mobileQuestsContent');
            if (!content) return;

            let html = '';
            
            // Function to get quest icon based on quest type
            function getQuestIcon(questType) {
                switch(questType) {
                    case 'harvest': return 'üåæ';
                    case 'plant': return 'üå±';
                    case 'coins': return 'üí∞';
                    case 'collect': return 'üêÑ';
                    case 'water': return 'üíß';
                    default: return 'üìã';
                }
            }
            
            dailyQuests.forEach((quest, index) => {
                const progressPercent = Math.min(100, (quest.progress / quest.target) * 100);
                const isCompleted = quest.progress >= quest.target;
                const questIcon = getQuestIcon(quest.type);
                
                html += `
                    <div class="mobile-grid-item ${isCompleted ? 'completed' : ''}" style="min-height: 120px; width: 100%; margin-bottom: 15px;">
                        <div class="emoji">${questIcon}</div>
                        <div class="name">${quest.name}</div>
                        <div class="count">${quest.description}</div>
                        <div style="width: 100%; background: rgba(255,255,255,0.2); height: 8px; border-radius: 4px; margin: 8px 0; overflow: hidden;">
                            <div style="width: ${progressPercent}%; height: 100%; background: #4CAF50; transition: width 0.3s ease;"></div>
                        </div>
                        <div style="font-size: 12px; opacity: 0.8;">
                            Progress: ${quest.progress}/${quest.target} | Reward: ${quest.reward}üí∞
                        </div>
                    </div>
                `;
            });

            if (dailyQuests.length === 0) {
                html = '<div style="text-align: center; color: #999; padding: 40px;">No active quests</div>';
            }

            html += `
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="resetDailyQuests()" 
                            style="background: #FF9800; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-size: 14px; cursor: pointer;">
                        üîÑ New Quests (50üí∞)
                    </button>
                </div>
            `;

            content.innerHTML = html;
        }

        // Initialize draggable UI when the game loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                initDraggableUI();
                initMobileControls();
                initMobileInterface();
            }, 100); // Small delay to ensure game is initialized
        });
    </script>
</body>
</html>