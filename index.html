<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Harvest - 3D Farming Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #score {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 16px;
            opacity: 0.9;
            max-width: 300px;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        #plantSelector {
            position: absolute;
            top: 20px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
        }

        .plant-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .plant-btn:hover {
            background: #45a049;
        }

        .plant-btn.selected {
            background: #2196F3;
        }

        #marketplace {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        .market-btn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .market-btn:hover {
            background: #e68900;
        }

        #objectives {
            position: absolute;
            top: 120px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }
        
        #canvas {
            display: block;
            border: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        #dayNightIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="loading" id="loading">Loading Pixel-Harvest...</div>
        <div id="ui" style="display: none;">
            <div id="score">Score: 0</div>
            <div id="instructions">
                üå± Click plots to plant selected seed<br>
                üåø Plants grow automatically (3 stages)<br>
                üåæ Click mature plants to harvest<br>
                üíß Right-click to water plants<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view<br>
                üîç Scroll wheel to zoom in/out
            </div>
        </div>
        <div id="plantSelector" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üå± Plant Types:</div>
            <button class="plant-btn selected" data-plant="carrot">ü•ï Carrot (Fast)</button><br>
            <button class="plant-btn" data-plant="tomato">üçÖ Tomato (Normal)</button><br>
            <button class="plant-btn" data-plant="rare">‚ú® Rare Plant (Slow)</button>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.8;">
                üí∞ Coins: <span id="coins">10</span>
            </div>
        </div>
        <div id="inventory" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üì¶ Inventory:</div>
            <div id="carrotCount">ü•ï Carrots: 0</div>
            <div id="tomatoCount">üçÖ Tomatoes: 0</div>
            <div id="rareCount">‚ú® Rare Plants: 0</div>
        </div>
        <div id="marketplace" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üè™ Marketplace:</div>
            <button class="market-btn" onclick="sellAll('carrot')">Sell Carrots (1üí∞)</button><br>
            <button class="market-btn" onclick="sellAll('tomato')">Sell Tomatoes (3üí∞)</button><br>
            <button class="market-btn" onclick="sellAll('rare')">Sell Rare (10üí∞)</button><br>
            <hr style="margin: 10px 0;">
            <button class="market-btn" onclick="buySeeds('carrot', 1)">Buy Carrot Seeds (1üí∞)</button><br>
            <button class="market-btn" onclick="buySeeds('tomato', 2)">Buy Tomato Seeds (2üí∞)</button><br>
            <button class="market-btn" onclick="buySeeds('rare', 5)">Buy Rare Seeds (5üí∞)</button>
        </div>
        <div id="objectives" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üéØ Objectives:</div>
            <div id="objective1" class="objective">ü•ï Harvest 5 carrots (0/5)</div>
            <div id="objective2" class="objective">üåô Survive 2 day/night cycles (0/2)</div>
            <div id="objective3" class="objective">üí∞ Earn 20 coins (0/20)</div>
        </div>
        <div id="dayNightIndicator" style="display: none;">
            <div id="timeDisplay">Day</div>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // Game state
        let canvas, ctx;
        let score = 0;
        let coins = 10;
        let dayNightCycle = 0;
        let dayNightCycleCount = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraDistance = 10;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredPlot = null;
        let selectedPlantType = 'carrot';
        
        // Game objects
        let plots = [];
        let inventory = {
            carrot: 0,
            tomato: 0,
            rare: 0
        };
        let seedInventory = {
            carrot: 5,
            tomato: 2,
            rare: 1
        };
        let objectives = {
            carrotsHarvested: 0,
            dayNightCycles: 0,
            coinsEarned: 0
        };
        
        // Plant types configuration
        const PLANT_TYPES = {
            carrot: {
                name: 'Carrot',
                emoji: 'ü•ï',
                growthTime: 2000, // 2 seconds per stage
                value: 1,
                seedCost: 1,
                color: '#FFA500',
                waterNeed: 0.3,
                dayPreference: true
            },
            tomato: {
                name: 'Tomato',
                emoji: 'üçÖ',
                growthTime: 4000, // 4 seconds per stage
                value: 3,
                seedCost: 2,
                color: '#FF6347',
                waterNeed: 0.5,
                dayPreference: false
            },
            rare: {
                name: 'Rare Plant',
                emoji: '‚ú®',
                growthTime: 8000, // 8 seconds per stage
                value: 10,
                seedCost: 5,
                color: '#9370DB',
                waterNeed: 0.8,
                dayPreference: false
            }
        };
        
        // Colors
        const colors = {
            ground: '#228B22',
            plot: '#8B4513',
            seed: '#654321',
            plantStage1: '#90EE90',
            plantStage2: '#32CD32',
            plantStage3: '#006400',
            plotHover: '#CD853F',
            plantHover: '#228B22',
            water: '#87CEEB',
            dryPlot: '#8B7355'
        };
        
        // Plant growth stages
        const PLANT_STAGES = {
            EMPTY: 0,
            PLANTED: 1,
            GROWING1: 2,
            GROWING2: 3,
            MATURE: 4,
            WITHERING: 5
        };
        
        // 3D projection and rendering functions
        function project3D(x, y, z) {
            // Simple perspective projection with zoom support
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Apply camera rotation
            const cosX = Math.cos(cameraAngleX);
            const sinX = Math.sin(cameraAngleX);
            const cosY = Math.cos(cameraAngleY);
            const sinY = Math.sin(cameraAngleY);
            
            // Rotate around Y axis then X axis
            const x1 = x * cosY - z * sinY;
            const z1 = x * sinY + z * cosY;
            const y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX + cameraDistance; // Use cameraDistance for zoom
            
            if (z2 <= 0) z2 = 0.1; // Prevent division by zero
            
            const scale = canvas.width / z2;
            return {
                x: cx + x1 * scale,
                y: cy - y1 * scale,
                z: z2,
                scale: scale
            };
        }
        
        function drawCube(x, y, z, size, color, outline = true) {
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            const projected = vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
            
            // Define faces (front, back, top, bottom, left, right)
            const faces = [
                [0, 1, 2, 3], // front
                [5, 4, 7, 6], // back
                [4, 5, 1, 0], // bottom
                [3, 2, 6, 7], // top
                [4, 0, 3, 7], // left
                [1, 5, 6, 2]  // right
            ];
            
            // Sort faces by average z-depth for proper rendering
            const faceDepths = faces.map(face => {
                const avgZ = face.reduce((sum, i) => sum + projected[i].z, 0) / face.length;
                return { face, depth: avgZ };
            });
            faceDepths.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faceDepths.forEach(({ face }, faceIndex) => {
                ctx.beginPath();
                ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                }
                ctx.closePath();
                
                // Apply lighting based on face orientation and day/night cycle
                const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
                const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
                const faceLight = 0.7 + faceIndex * 0.05; // Different faces have different lighting
                const finalLight = lightIntensity * faceLight;
                
                ctx.fillStyle = adjustColorBrightness(color, finalLight);
                ctx.fill();
                
                if (outline) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
            
            return projected; // Return projected vertices for click detection
        }
        
        function getProjectedCube(x, y, z, size) {
            // Calculate cube projection without drawing - for click detection only
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            return vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
        }
        
        function drawPlane(x, y, z, width, height, color) {
            // Draw ground plane
            const hw = width / 2;
            const hh = height / 2;
            
            const corners = [
                project3D(x - hw, y, z - hh),
                project3D(x + hw, y, z - hh),
                project3D(x + hw, y, z + hh),
                project3D(x - hw, y, z + hh)
            ];
            
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
            ctx.closePath();
            
            // Apply day/night lighting
            const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
            const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
            ctx.fillStyle = adjustColorBrightness(color, lightIntensity);
            ctx.fill();
            
            // Grid lines
            ctx.strokeStyle = adjustColorBrightness('#000', lightIntensity * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            return corners;
        }
        
        function adjustColorBrightness(color, factor) {
            // Convert hex color to RGB and adjust brightness
            const hex = color.replace('#', '');
            const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function isPointInProjectedQuad(point, quad) {
            // Simple point-in-polygon test for click detection
            let inside = false;
            for (let i = 0, j = quad.length - 1; i < quad.length; j = i++) {
                if (((quad[i].y > point.y) !== (quad[j].y > point.y)) &&
                    (point.x < (quad[j].x - quad[i].x) * (point.y - quad[i].y) / (quad[j].y - quad[i].y) + quad[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize camera
            cameraAngleX = -0.3; // Look down slightly
            cameraAngleY = 0;
            
            // Create farming plots
            createPlots();
            
            // Add event listeners
            addEventListeners();
            
            // Initialize UI
            setupUI();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('dayNightIndicator').style.display = 'block';
            document.getElementById('plantSelector').style.display = 'block';
            document.getElementById('inventory').style.display = 'block';
            document.getElementById('marketplace').style.display = 'block';
            document.getElementById('objectives').style.display = 'block';
            
            // Start game loop
            animate();
        }
        
        function createPlots() {
            // Create a 3x3 grid of farming plots
            plots = [];
            for (let x = -4; x <= 4; x += 4) {
                for (let z = -4; z <= 4; z += 4) {
                    const plot = {
                        x: x,
                        y: 0,
                        z: z,
                        stage: PLANT_STAGES.EMPTY,
                        plant: null,
                        plantType: null,
                        growthTimer: 0,
                        waterLevel: 1.0,
                        lastWatered: Date.now(),
                        unlocked: true // All plots start unlocked for now
                    };
                    plots.push(plot);
                }
            }
        }
        
        function setupUI() {
            // Plant selector buttons
            document.querySelectorAll('.plant-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedPlantType = e.target.dataset.plant;
                });
            });
            
            updateUI();
        }
        
        function addEventListeners() {
            // Mouse controls
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('contextmenu', onRightClick);
            canvas.addEventListener('wheel', onMouseWheel);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (mouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                // Clear hover state when dragging
                hoveredPlot = null;
            } else {
                // Check for plot hover
                hoveredPlot = null;
                plots.forEach(plot => {
                    const plotProjected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
                    const minX = Math.min(...plotProjected.map(p => p.x));
                    const maxX = Math.max(...plotProjected.map(p => p.x));
                    const minY = Math.min(...plotProjected.map(p => p.y));
                    const maxY = Math.max(...plotProjected.map(p => p.y));
                    
                    if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                        hoveredPlot = plot;
                    }
                });
                
                // Update cursor based on hover state
                canvas.style.cursor = hoveredPlot ? 'pointer' : 'crosshair';
            }
        }
        
        function onMouseUp(event) {
            mouseDown = false;
        }
        
        function onMouseLeave(event) {
            mouseDown = false; // Reset mouse state when leaving canvas
        }
        
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling
            
            // Zoom in/out based on wheel direction
            const zoomSpeed = 0.5;
            const zoomDirection = event.deltaY > 0 ? 1 : -1; // Positive = zoom out, negative = zoom in
            
            cameraDistance += zoomDirection * zoomSpeed;
            
            // Limit zoom range
            cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Min: 3, Max: 20
        }
        
        function onRightClick(event) {
            event.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks for watering
            plots.forEach(plot => {
                const plotProjected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
                
                const minX = Math.min(...plotProjected.map(p => p.x));
                const maxX = Math.max(...plotProjected.map(p => p.x));
                const minY = Math.min(...plotProjected.map(p => p.y));
                const maxY = Math.max(...plotProjected.map(p => p.y));
                
                if (clickX >= minX && clickX <= maxX && clickY >= minY && clickY <= maxY) {
                    waterPlot(plot);
                }
            });
        }
        
        function waterPlot(plot) {
            if (plot.stage !== PLANT_STAGES.EMPTY) {
                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.5);
                plot.lastWatered = Date.now();
                
                // Visual feedback for watering
                createWaterEffect(plot);
            }
        }
        
        function createWaterEffect(plot) {
            // Simple visual effect for watering (could be enhanced with particles)
            const originalColor = plot.plant ? plot.plant.color : colors.plot;
            // This effect would be more visible with actual particle system
        }
        
        function onMouseClick(event) {
            if (mouseDown) return; // Ignore clicks during drag
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks without drawing
            plots.forEach(plot => {
                const plotProjected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
                
                // Create a simple bounding rectangle for click detection
                const minX = Math.min(...plotProjected.map(p => p.x));
                const maxX = Math.max(...plotProjected.map(p => p.x));
                const minY = Math.min(...plotProjected.map(p => p.y));
                const maxY = Math.max(...plotProjected.map(p => p.y));
                
                if (clickX >= minX && clickX <= maxX && clickY >= minY && clickY <= maxY) {
                    handlePlotClick(plot);
                }
            });
        }
        
        function handlePlotClick(plot) {
            if (plot.stage === PLANT_STAGES.EMPTY) {
                plantSeed(plot, selectedPlantType);
            } else if (plot.stage === PLANT_STAGES.MATURE) {
                harvestPlant(plot);
            }
        }
        
        function plantSeed(plot, plantType) {
            if (seedInventory[plantType] <= 0) {
                return; // No seeds available
            }
            
            const plantConfig = PLANT_TYPES[plantType];
            seedInventory[plantType]--;
            
            plot.stage = PLANT_STAGES.PLANTED;
            plot.plantType = plantType;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            plot.lastWatered = Date.now();
            plot.plant = {
                size: 0.3,
                color: plantConfig.color,
                baseColor: plantConfig.color
            };
            
            updateUI();
        }
        
        function growPlant(plot) {
            const plantConfig = PLANT_TYPES[plot.plantType];
            
            if (plot.stage === PLANT_STAGES.PLANTED) {
                plot.stage = PLANT_STAGES.GROWING1;
                plot.plant.size = 0.6;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING1) {
                plot.stage = PLANT_STAGES.GROWING2;
                plot.plant.size = 0.9;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING2) {
                plot.stage = PLANT_STAGES.MATURE;
                plot.plant.size = 1.2;
                // Add glow effect for mature plants
                plot.plant.glow = true;
            }
        }
        
        function harvestPlant(plot) {
            if (plot.stage !== PLANT_STAGES.MATURE) return;
            
            const plantType = plot.plantType;
            const plantConfig = PLANT_TYPES[plantType];
            
            // Add to inventory
            inventory[plantType]++;
            
            // Add score
            score += plantConfig.value;
            
            // Update objectives
            if (plantType === 'carrot') {
                objectives.carrotsHarvested++;
            }
            
            // Reset plot
            plot.stage = PLANT_STAGES.EMPTY;
            plot.plant = null;
            plot.plantType = null;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            
            // Create harvest effect
            createHarvestEffect(plot);
            
            updateUI();
            updateObjectives();
        }
        
        function createHarvestEffect(plot) {
            // Simple visual feedback (could be enhanced with particle effects)
            // For now, this is a placeholder for the effect
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateUI() {
            // Update score and coins
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('coins').textContent = coins;
            
            // Update inventory
            document.getElementById('carrotCount').textContent = `ü•ï Carrots: ${inventory.carrot}`;
            document.getElementById('tomatoCount').textContent = `üçÖ Tomatoes: ${inventory.tomato}`;
            document.getElementById('rareCount').textContent = `‚ú® Rare Plants: ${inventory.rare}`;
            
            // Update plant buttons availability
            document.querySelectorAll('.plant-btn').forEach(btn => {
                const plantType = btn.dataset.plant;
                const hasSeeds = seedInventory[plantType] > 0;
                btn.disabled = !hasSeeds;
                btn.style.opacity = hasSeeds ? '1' : '0.5';
                
                // Update button text with seed count
                const plantConfig = PLANT_TYPES[plantType];
                btn.textContent = `${plantConfig.emoji} ${plantConfig.name} (${seedInventory[plantType]})`;
            });
        }
        
        function updateObjectives() {
            // Update objective displays
            document.getElementById('objective1').textContent = 
                `ü•ï Harvest 5 carrots (${Math.min(objectives.carrotsHarvested, 5)}/5)`;
            document.getElementById('objective2').textContent = 
                `üåô Survive 2 day/night cycles (${Math.min(objectives.dayNightCycles, 2)}/2)`;
            document.getElementById('objective3').textContent = 
                `üí∞ Earn 20 coins (${Math.min(coins, 20)}/20)`;
                
            // Check for completed objectives
            if (objectives.carrotsHarvested >= 5) {
                document.getElementById('objective1').style.color = '#4CAF50';
            }
            if (objectives.dayNightCycles >= 2) {
                document.getElementById('objective2').style.color = '#4CAF50';
            }
            if (coins >= 20) {
                document.getElementById('objective3').style.color = '#4CAF50';
            }
        }
        
        // Marketplace functions
        function sellAll(plantType) {
            const count = inventory[plantType];
            if (count <= 0) return;
            
            const plantConfig = PLANT_TYPES[plantType];
            const earnings = count * plantConfig.value;
            
            inventory[plantType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            updateUI();
            updateObjectives();
        }
        
        function buySeeds(plantType, cost) {
            if (coins >= cost) {
                coins -= cost;
                seedInventory[plantType] += 5; // Buy 5 seeds at a time
                updateUI();
            }
        }
        
        function updateDayNightCycle() {
            const oldProgress = (Math.sin(dayNightCycle) + 1) / 2;
            dayNightCycle += 0.01;
            const newProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Check for day/night cycle completion
            if (oldProgress > 0.5 && newProgress <= 0.5) {
                dayNightCycleCount++;
                objectives.dayNightCycles = dayNightCycleCount;
                updateObjectives();
            }
            
            // Calculate day/night progression
            const dayProgress = newProgress;
            const isDay = dayProgress > 0.5;
            
            // Update time display
            document.getElementById('timeDisplay').textContent = isDay ? 'Day' : 'Night';
            
            // Update background color
            const dayColor = { r: 135, g: 206, b: 235 }; // Sky blue
            const nightColor = { r: 25, g: 25, b: 112 }; // Midnight blue
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }
        
        function updatePlantGrowth(deltaTime) {
            const currentTime = Date.now();
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            plots.forEach(plot => {
                if (plot.stage !== PLANT_STAGES.EMPTY && plot.stage !== PLANT_STAGES.MATURE) {
                    // Update water level (plants lose water over time)
                    const timeSinceWatered = currentTime - plot.lastWatered;
                    const waterDecay = timeSinceWatered / 10000; // Lose water over 10 seconds
                    plot.waterLevel = Math.max(0, plot.waterLevel - waterDecay * deltaTime / 1000);
                    
                    // Get plant configuration
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    
                    // Calculate growth speed based on conditions
                    let growthMultiplier = 1;
                    
                    // Day/night preference
                    if (plantConfig.dayPreference === isDay) {
                        growthMultiplier *= 1.5;
                    } else {
                        growthMultiplier *= 0.7;
                    }
                    
                    // Water level affects growth
                    if (plot.waterLevel > plantConfig.waterNeed) {
                        growthMultiplier *= 1.2;
                    } else if (plot.waterLevel < plantConfig.waterNeed * 0.5) {
                        growthMultiplier *= 0.5;
                    }
                    
                    // Check for proximity bonus (plants grow faster near other plants)
                    const nearbyPlants = plots.filter(otherPlot => {
                        if (otherPlot === plot || otherPlot.stage === PLANT_STAGES.EMPTY) return false;
                        const distance = Math.sqrt(
                            Math.pow(plot.x - otherPlot.x, 2) + Math.pow(plot.z - otherPlot.z, 2)
                        );
                        return distance <= 4.5; // Adjacent plots
                    });
                    
                    if (nearbyPlants.length > 0) {
                        growthMultiplier *= (1 + nearbyPlants.length * 0.1);
                    }
                    
                    // Apply growth
                    plot.growthTimer += deltaTime * growthMultiplier;
                    
                    // Check if plant should grow
                    if (plot.growthTimer >= plantConfig.growthTime) {
                        growPlant(plot);
                    }
                    
                    // Check if plant should wither due to lack of water
                    if (plot.waterLevel <= 0 && plot.stage !== PLANT_STAGES.WITHERING) {
                        plot.stage = PLANT_STAGES.WITHERING;
                        plot.plant.color = adjustColorBrightness(plot.plant.baseColor, 0.5);
                    }
                }
            });
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            drawPlane(0, 0, 0, 15, 15, colors.ground);
            
            // Draw plots and plants
            plots.forEach(plot => {
                // Determine if plot should be highlighted
                const isHovered = hoveredPlot === plot;
                let plotColor = colors.plot;
                
                // Show different colors based on water level
                if (plot.stage !== PLANT_STAGES.EMPTY) {
                    if (plot.waterLevel < 0.3) {
                        plotColor = colors.dryPlot;
                    } else if (plot.waterLevel > 0.8) {
                        plotColor = adjustColorBrightness(colors.plot, 1.2);
                    }
                }
                
                if (isHovered) {
                    plotColor = colors.plotHover;
                }
                
                // Draw plot
                drawCube(plot.x, plot.y + 0.1, plot.z, 2, plotColor);
                
                // Draw plant if exists
                if (plot.plant) {
                    let plantColor = plot.plant.color;
                    
                    // Add glow effect for mature plants
                    if (plot.stage === PLANT_STAGES.MATURE && plot.plant.glow) {
                        const glowIntensity = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
                        plantColor = adjustColorBrightness(plot.plant.color, 1 + glowIntensity * 0.3);
                    }
                    
                    if (isHovered) {
                        plantColor = adjustColorBrightness(plantColor, 1.3);
                    }
                    
                    drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, plot.plant.size, plantColor);
                    
                    // Draw water level indicator for watered plants
                    if (plot.waterLevel > 0.8 && plot.stage !== PLANT_STAGES.EMPTY) {
                        drawCube(plot.x, plot.y + 0.15, plot.z, 2.2, colors.water, false);
                    }
                }
            });
        }
        
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update plant growth
            updatePlantGrowth(deltaTime);
            
            // Render scene
            render();
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>