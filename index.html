<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Harvest - 3D Farming Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #score {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 16px;
            opacity: 0.9;
            max-width: 300px;
        }
        
        #canvas {
            display: block;
            border: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        #dayNightIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="loading" id="loading">Loading Pixel-Harvest...</div>
        <div id="ui" style="display: none;">
            <div id="score">Score: 0</div>
            <div id="instructions">
                üå± Click brown plots to plant seeds<br>
                üåø Plants grow automatically (3 stages)<br>
                üåæ Click mature plants to harvest<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view
            </div>
        </div>
        <div id="dayNightIndicator" style="display: none;">
            <div id="timeDisplay">Day</div>
        </div>
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // Game state
        let canvas, ctx;
        let score = 0;
        let dayNightCycle = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredPlot = null; // Track which plot is being hovered
        
        // Game objects
        let plots = [];
        
        // Colors
        const colors = {
            ground: '#228B22',
            plot: '#8B4513',
            seed: '#654321',
            plantStage1: '#90EE90',
            plantStage2: '#32CD32',
            plantStage3: '#006400',
            plotHover: '#CD853F', // Sandy brown for hover effect
            plantHover: '#228B22'  // Forest green for plant hover
        };
        
        // Plant growth stages
        const PLANT_STAGES = {
            EMPTY: 0,
            PLANTED: 1,
            GROWING1: 2,
            GROWING2: 3,
            MATURE: 4
        };
        
        // 3D projection and rendering functions
        function project3D(x, y, z) {
            // Simple perspective projection
            const distance = 10;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Apply camera rotation
            const cosX = Math.cos(cameraAngleX);
            const sinX = Math.sin(cameraAngleX);
            const cosY = Math.cos(cameraAngleY);
            const sinY = Math.sin(cameraAngleY);
            
            // Rotate around Y axis then X axis
            const x1 = x * cosY - z * sinY;
            const z1 = x * sinY + z * cosY;
            const y1 = y * cosX - z1 * sinX;
            const z2 = y * sinX + z1 * cosX + distance;
            
            if (z2 <= 0) z2 = 0.1; // Prevent division by zero
            
            const scale = canvas.width / z2;
            return {
                x: cx + x1 * scale,
                y: cy - y1 * scale,
                z: z2,
                scale: scale
            };
        }
        
        function drawCube(x, y, z, size, color, outline = true) {
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            const projected = vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
            
            // Define faces (front, back, top, bottom, left, right)
            const faces = [
                [0, 1, 2, 3], // front
                [5, 4, 7, 6], // back
                [4, 5, 1, 0], // bottom
                [3, 2, 6, 7], // top
                [4, 0, 3, 7], // left
                [1, 5, 6, 2]  // right
            ];
            
            // Sort faces by average z-depth for proper rendering
            const faceDepths = faces.map(face => {
                const avgZ = face.reduce((sum, i) => sum + projected[i].z, 0) / face.length;
                return { face, depth: avgZ };
            });
            faceDepths.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faceDepths.forEach(({ face }, faceIndex) => {
                ctx.beginPath();
                ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                }
                ctx.closePath();
                
                // Apply lighting based on face orientation and day/night cycle
                const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
                const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
                const faceLight = 0.7 + faceIndex * 0.05; // Different faces have different lighting
                const finalLight = lightIntensity * faceLight;
                
                ctx.fillStyle = adjustColorBrightness(color, finalLight);
                ctx.fill();
                
                if (outline) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
            
            return projected; // Return projected vertices for click detection
        }
        
        function getProjectedCube(x, y, z, size) {
            // Calculate cube projection without drawing - for click detection only
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            return vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
        }
        
        function drawPlane(x, y, z, width, height, color) {
            // Draw ground plane
            const hw = width / 2;
            const hh = height / 2;
            
            const corners = [
                project3D(x - hw, y, z - hh),
                project3D(x + hw, y, z - hh),
                project3D(x + hw, y, z + hh),
                project3D(x - hw, y, z + hh)
            ];
            
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
            ctx.closePath();
            
            // Apply day/night lighting
            const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
            const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
            ctx.fillStyle = adjustColorBrightness(color, lightIntensity);
            ctx.fill();
            
            // Grid lines
            ctx.strokeStyle = adjustColorBrightness('#000', lightIntensity * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            return corners;
        }
        
        function adjustColorBrightness(color, factor) {
            // Convert hex color to RGB and adjust brightness
            const hex = color.replace('#', '');
            const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function isPointInProjectedQuad(point, quad) {
            // Simple point-in-polygon test for click detection
            let inside = false;
            for (let i = 0, j = quad.length - 1; i < quad.length; j = i++) {
                if (((quad[i].y > point.y) !== (quad[j].y > point.y)) &&
                    (point.x < (quad[j].x - quad[i].x) * (point.y - quad[i].y) / (quad[j].y - quad[i].y) + quad[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize camera
            cameraAngleX = -0.3; // Look down slightly
            cameraAngleY = 0;
            
            // Create farming plots
            createPlots();
            
            // Add event listeners
            addEventListeners();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('dayNightIndicator').style.display = 'block';
            
            // Start game loop
            animate();
        }
        
        function createPlots() {
            // Create a 3x3 grid of farming plots
            plots = [];
            for (let x = -4; x <= 4; x += 4) {
                for (let z = -4; z <= 4; z += 4) {
                    const plot = {
                        x: x,
                        y: 0,
                        z: z,
                        stage: PLANT_STAGES.EMPTY,
                        plant: null,
                        growthTimer: 0
                    };
                    plots.push(plot);
                }
            }
        }
        
        function addEventListeners() {
            // Mouse controls
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('click', onMouseClick);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
            
            // Prevent context menu
            canvas.addEventListener('contextmenu', e => e.preventDefault());
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (mouseDown) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                // Clear hover state when dragging
                hoveredPlot = null;
            } else {
                // Check for plot hover
                hoveredPlot = null;
                plots.forEach(plot => {
                    const plotProjected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
                    const minX = Math.min(...plotProjected.map(p => p.x));
                    const maxX = Math.max(...plotProjected.map(p => p.x));
                    const minY = Math.min(...plotProjected.map(p => p.y));
                    const maxY = Math.max(...plotProjected.map(p => p.y));
                    
                    if (mouseX >= minX && mouseX <= maxX && mouseY >= minY && mouseY <= maxY) {
                        hoveredPlot = plot;
                    }
                });
                
                // Update cursor based on hover state
                canvas.style.cursor = hoveredPlot ? 'pointer' : 'crosshair';
            }
        }
        
        function onMouseUp(event) {
            mouseDown = false;
        }
        
        function onMouseLeave(event) {
            mouseDown = false; // Reset mouse state when leaving canvas
        }
        
        function onMouseClick(event) {
            if (mouseDown) return; // Ignore clicks during drag
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks without drawing
            plots.forEach(plot => {
                const plotProjected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
                
                // Create a simple bounding rectangle for click detection
                const minX = Math.min(...plotProjected.map(p => p.x));
                const maxX = Math.max(...plotProjected.map(p => p.x));
                const minY = Math.min(...plotProjected.map(p => p.y));
                const maxY = Math.max(...plotProjected.map(p => p.y));
                
                if (clickX >= minX && clickX <= maxX && clickY >= minY && clickY <= maxY) {
                    handlePlotClick(plot);
                }
            });
        }
        
        function handlePlotClick(plot) {
            if (plot.stage === PLANT_STAGES.EMPTY) {
                plantSeed(plot);
            } else if (plot.stage === PLANT_STAGES.MATURE) {
                harvestPlant(plot);
            }
        }
        
        function plantSeed(plot) {
            plot.stage = PLANT_STAGES.PLANTED;
            plot.growthTimer = 0;
            plot.plant = {
                size: 0.3,
                color: colors.seed
            };
        }
        
        function growPlant(plot) {
            if (plot.stage === PLANT_STAGES.PLANTED) {
                plot.stage = PLANT_STAGES.GROWING1;
                plot.plant.size = 0.6;
                plot.plant.color = colors.plantStage1;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING1) {
                plot.stage = PLANT_STAGES.GROWING2;
                plot.plant.size = 0.9;
                plot.plant.color = colors.plantStage2;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING2) {
                plot.stage = PLANT_STAGES.MATURE;
                plot.plant.size = 1.2;
                plot.plant.color = colors.plantStage3;
            }
        }
        
        function harvestPlant(plot) {
            plot.stage = PLANT_STAGES.EMPTY;
            plot.plant = null;
            plot.growthTimer = 0;
            
            // Increase score
            score++;
            updateScore();
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateDayNightCycle() {
            dayNightCycle += 0.01;
            
            // Calculate day/night progression
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Update time display
            document.getElementById('timeDisplay').textContent = isDay ? 'Day' : 'Night';
            
            // Update background color
            const dayColor = { r: 135, g: 206, b: 235 }; // Sky blue
            const nightColor = { r: 25, g: 25, b: 112 }; // Midnight blue
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }
        
        function updatePlantGrowth(deltaTime) {
            plots.forEach(plot => {
                if (plot.stage !== PLANT_STAGES.EMPTY && plot.stage !== PLANT_STAGES.MATURE) {
                    plot.growthTimer += deltaTime;
                    
                    // Plants grow every 3 seconds
                    if (plot.growthTimer >= 3000) {
                        growPlant(plot);
                    }
                }
            });
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground
            drawPlane(0, 0, 0, 15, 15, colors.ground);
            
            // Draw plots and plants
            plots.forEach(plot => {
                // Determine if plot should be highlighted
                const isHovered = hoveredPlot === plot;
                let plotColor = colors.plot;
                
                if (isHovered) {
                    plotColor = colors.plotHover;
                }
                
                // Draw plot
                drawCube(plot.x, plot.y + 0.1, plot.z, 2, plotColor);
                
                // Draw plant if exists
                if (plot.plant) {
                    let plantColor = plot.plant.color;
                    if (isHovered) {
                        // Brighten the plant color when hovered
                        plantColor = adjustColorBrightness(plot.plant.color, 1.3);
                    }
                    drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, plot.plant.size, plantColor);
                }
            });
        }
        
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update plant growth
            updatePlantGrowth(deltaTime);
            
            // Render scene
            render();
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>