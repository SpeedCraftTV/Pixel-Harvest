<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Harvest - 3D Farming Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        #score {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 16px;
            opacity: 0.9;
            max-width: 300px;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        #plantSelector {
            position: absolute;
            top: 20px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
        }

        .plant-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .plant-btn:hover {
            background: #45a049;
        }

        .plant-btn.selected {
            background: #2196F3;
        }

        #marketplace {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .market-category {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .market-category:last-child {
            border-bottom: none;
        }

        .market-category h3 {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .market-btn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .market-btn:hover {
            background: #e68900;
        }

        #objectives {
            position: absolute;
            top: 120px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            min-width: 400px;
            display: none;
            border: 2px solid #4CAF50;
        }

        #settingsMenu h2 {
            margin-top: 0;
            text-align: center;
            color: #4CAF50;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .control-label {
            font-weight: bold;
            min-width: 120px;
        }

        .key-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            min-width: 60px;
        }

        .key-button:hover {
            background: #1976D2;
        }

        .key-button.recording {
            background: #FF5722;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .preset-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .preset-btn:hover {
            background: #7B1FA2;
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .menu-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .menu-btn:hover {
            background: #45a049;
        }

        .cancel-btn {
            background: #f44336;
        }

        .cancel-btn:hover {
            background: #da190b;
        }

        #settingsButton {
            position: absolute;
            top: 20px;
            right: 280px;
            z-index: 100;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #settingsButton:hover {
            background: #45a049;
        }
        
        #newGameButton {
            position: absolute;
            top: 20px;
            right: 410px;
            z-index: 100;
            background: #FF5722;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #newGameButton:hover {
            background: #D84315;
        }
        
        #canvas {
            display: block;
            border: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        #dayNightIndicator {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="loading" id="loading">Loading Pixel-Harvest...</div>
        <div id="ui" style="display: none;">
            <div id="score">Score: 0</div>
            <div id="instructions">
                üå± Move with WASD or arrow keys<br>
                ‚ö° SPACE to plant/harvest at closest plot<br>
                üíß E to water plants<br>
                üìπ C to toggle camera mode<br>
                üåø Plants grow automatically (3 stages)<br>
                üîí Unlock plots by getting close and pressing SPACE<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view<br>
                üîç Scroll wheel to zoom in/out
            </div>
        </div>
        <div id="plantSelector" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üå± Plant Types:</div>
            <button class="plant-btn selected" data-plant="carrot">ü•ï Carrot (Fast)</button><br>
            <button class="plant-btn" data-plant="tomato">üçÖ Tomato (Normal)</button><br>
            <button class="plant-btn" data-plant="rare">‚ú® Rare Plant (Slow)</button>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.8;">
                üí∞ Coins: <span id="coins">10</span>
            </div>
        </div>
        <div id="inventory" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üì¶ Inventory:</div>
            <div id="carrotCount">ü•ï Carrots: 0</div>
            <div id="tomatoCount">üçÖ Tomatoes: 0</div>
            <div id="rareCount">‚ú® Rare Plants: 0</div>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <div style="font-weight: bold; margin-bottom: 5px;">üîß Equipment:</div>
            <div id="sprinklerCount">üíß Auto Sprinklers: 0</div>
            <div id="fertilizerCount">üåø Fertilizer: 0</div>
            <div id="greenhouseCount">üè† Greenhouses: 0</div>
        </div>
        <div id="marketplace" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üè™ Marketplace:</div>
            
            <div class="market-category">
                <h3>üí∞ Sell Produce</h3>
                <button class="market-btn" onclick="sellAll('carrot')">Sell Carrots (1üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('tomato')">Sell Tomatoes (3üí∞)</button><br>
                <button class="market-btn" onclick="sellAll('rare')">Sell Rare (10üí∞)</button>
            </div>
            
            <div class="market-category">
                <h3>üå± Seeds</h3>
                <button class="market-btn" onclick="buySeeds('carrot', 1)">Buy Carrot Seeds (1üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('tomato', 2)">Buy Tomato Seeds (2üí∞)</button><br>
                <button class="market-btn" onclick="buySeeds('rare', 5)">Buy Rare Seeds (5üí∞)</button>
            </div>
            
            <div class="market-category">
                <h3>üîß Equipment</h3>
                <button class="market-btn" onclick="buyItem('sprinkler', 150)" id="sprinklerBtn">Auto Sprinkler (150üí∞)</button><br>
                <button class="market-btn" onclick="buyItem('fertilizer', 50)" id="fertilizerBtn">Fertilizer Pack (50üí∞)</button><br>
                <button class="market-btn" onclick="buyItem('greenhouse', 300)" id="greenhouseBtn">Mini Greenhouse (300üí∞)</button>
            </div>
        </div>
        <div id="objectives" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">üéØ Objectives:</div>
            <div id="objective1" class="objective">ü•ï Harvest 5 carrots (0/5)</div>
            <div id="objective2" class="objective">üåô Survive 2 day/night cycles (0/2)</div>
            <div id="objective3" class="objective">üí∞ Earn 20 coins (0/20)</div>
            <div id="objective4" class="objective" style="display: none;">üåæ Harvest 25 total plants (0/25)</div>
            <div id="objective5" class="objective" style="display: none;">üîß Buy any equipment (0/1)</div>
            <div id="objective6" class="objective" style="display: none;">üí∞ Earn 500 coins (0/500)</div>
            <div id="objective7" class="objective" style="display: none;">üå± Plant 50 seeds (0/50)</div>
            <div id="objective8" class="objective" style="display: none;">üèÜ Unlock all plots (0/25)</div>
        </div>
        <div id="dayNightIndicator" style="display: none;">
            <div id="timeDisplay">Day</div>
            <div id="cameraMode" style="margin-top: 10px; font-size: 14px;">Camera: Character Follow</div>
            <div id="characterStatus" style="margin-top: 10px; font-size: 12px; color: #FFD700;">
                Character: Idle
            </div>
        </div>
        <button id="settingsButton" style="display: none;">‚öôÔ∏è Controls</button>
        <button id="newGameButton" style="display: none;">üÜï New Game</button>
        
        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2>‚öôÔ∏è Control Settings</h2>
            
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setControlPreset('azerty')">AZERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('qwerty')">QWERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('arrows')">Arrow Keys</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Forward:</span>
                <button class="key-button" id="key-forward" onclick="recordKey('forward')">Z</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Left:</span>
                <button class="key-button" id="key-left" onclick="recordKey('left')">Q</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Backward:</span>
                <button class="key-button" id="key-backward" onclick="recordKey('backward')">S</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Right:</span>
                <button class="key-button" id="key-right" onclick="recordKey('right')">D</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Plant/Harvest:</span>
                <button class="key-button" id="key-action" onclick="recordKey('action')">SPACE</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Water Plants:</span>
                <button class="key-button" id="key-water" onclick="recordKey('water')">E</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Toggle Camera:</span>
                <button class="key-button" id="key-camera" onclick="recordKey('camera')">C</button>
            </div>
            
            <div class="menu-buttons">
                <button class="menu-btn" onclick="saveControls()">Save</button>
                <button class="menu-btn cancel-btn" onclick="cancelControls()">Cancel</button>
                <button class="menu-btn" onclick="resetControls()">Reset to Default</button>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // Game state
        let canvas, ctx;
        let score = 0;
        let coins = 50; // Balanced starting amount
        let dayNightCycle = 0;
        let dayNightCycleCount = 0;
        
        // Audio system
        let audioContext;
        let sounds = {
            plant: null,
            harvest: null,
            water: null,
            unlock: null,
            wind: null,
            birds: null
        };
        let windGain, windOscillator;
        let lastBirdSound = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraDistance = 10;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredPlot = null;
        let selectedPlantType = 'carrot';
        let selectedEquipment = null;
        let cameraFollowCharacter = true;
        let freeCameraMode = false;
        
        // Camera follow variables for smooth following
        let cameraFollowX = 0;
        let cameraFollowZ = 0;
        const cameraFollowLerp = 0.1;
        
        // Water decay rate (per second)
        const waterDecayRate = 0.02;
        
        // Auto-save interval (10 seconds)
        let autoSaveInterval;
        
        // Character system
        let character = {
            x: 0,
            y: 0,
            z: 0,
            size: 1,
            color: '#4169E1', // Royal blue
            targetX: 0,
            targetZ: 0,
            moving: false,
            speed: 0.05, // Movement speed
            animationFrame: 0,
            currentAction: 'idle', // idle, walking, planting, watering
            actionTimer: 0,
            direction: 0, // rotation in radians
            targetDirection: 0
        };
        
        // Keyboard state
        let keys = {};
        
        // Control mappings (AZERTY by default)
        let controls = {
            forward: 'KeyZ',
            left: 'KeyQ', 
            backward: 'KeyS',
            right: 'KeyD',
            action: 'Space',
            water: 'KeyE',
            camera: 'KeyC'
        };
        
        // Backup controls for cancelling changes
        let backupControls = {};
        
        // Key recording state
        let recordingKey = null;
        
        // Game objects
        let plots = [];
        let inventory = {
            carrot: 0,
            tomato: 0,
            rare: 0
        };
        let seedInventory = {
            carrot: 5,
            tomato: 2,
            rare: 1
        };
        let equipment = {
            sprinkler: 0,
            fertilizer: 0,
            greenhouse: 0
        };
        let activeSprinklers = []; // Array of sprinkler positions
        let objectives = {
            carrotsHarvested: 0,
            dayNightCycles: 0,
            coinsEarned: 0,
            plantsHarvested: 0,
            equipmentBought: 0,
            seedsPlanted: 0,
            plotsUnlocked: 9 // Start with 9 plots unlocked (3x3 center)
        };
        
        // Plant types configuration
        const PLANT_TYPES = {
            carrot: {
                name: 'Carrot',
                emoji: 'ü•ï',
                growthTime: 2000, // 2 seconds per stage
                value: 1,
                seedCost: 1,
                color: '#FFA500',
                waterNeed: 0.3,
                dayPreference: true
            },
            tomato: {
                name: 'Tomato',
                emoji: 'üçÖ',
                growthTime: 4000, // 4 seconds per stage
                value: 3,
                seedCost: 2,
                color: '#FF6347',
                waterNeed: 0.5,
                dayPreference: false
            },
            rare: {
                name: 'Rare Plant',
                emoji: '‚ú®',
                growthTime: 8000, // 8 seconds per stage
                value: 10,
                seedCost: 5,
                color: '#9370DB',
                waterNeed: 0.8,
                dayPreference: false
            }
        };
        
        // Colors
        const colors = {
            ground: '#228B22',
            plot: '#8B4513',
            seed: '#654321',
            plantStage1: '#90EE90',
            plantStage2: '#32CD32',
            plantStage3: '#006400',
            plotHover: '#CD853F',
            plantHover: '#228B22',
            water: '#87CEEB',
            dryPlot: '#8B7355'
        };
        
        // Plant growth stages
        const PLANT_STAGES = {
            EMPTY: 0,
            PLANTED: 1,
            GROWING1: 2,
            GROWING2: 3,
            MATURE: 4,
            WITHERING: 5
        };
        
        // 3D projection and rendering functions
        function project3D(x, y, z) {
            // Simple perspective projection with zoom support
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Apply camera offset when following character
            let offsetX = 0;
            let offsetZ = 0;
            if (cameraFollowCharacter) {
                offsetX = -cameraFollowX;
                offsetZ = -cameraFollowZ;
            }
            
            // Apply camera rotation
            const cosX = Math.cos(cameraAngleX);
            const sinX = Math.sin(cameraAngleX);
            const cosY = Math.cos(cameraAngleY);
            const sinY = Math.sin(cameraAngleY);
            
            // Apply offset for character following
            const x1_offset = x + offsetX;
            const z1_offset = z + offsetZ;
            
            // Rotate around Y axis then X axis
            const x1 = x1_offset * cosY - z1_offset * sinY;
            const z1 = x1_offset * sinY + z1_offset * cosY;
            const y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX + cameraDistance; // Use cameraDistance for zoom
            
            if (z2 <= 0) z2 = 0.1; // Prevent division by zero
            
            const scale = canvas.width / z2;
            return {
                x: cx + x1 * scale,
                y: cy - y1 * scale,
                z: z2,
                scale: scale
            };
        }
        
        function drawCube(x, y, z, size, color, outline = true) {
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            const projected = vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
            
            // Define faces (front, back, top, bottom, left, right)
            const faces = [
                [0, 1, 2, 3], // front
                [5, 4, 7, 6], // back
                [4, 5, 1, 0], // bottom
                [3, 2, 6, 7], // top
                [4, 0, 3, 7], // left
                [1, 5, 6, 2]  // right
            ];
            
            // Sort faces by average z-depth for proper rendering
            const faceDepths = faces.map(face => {
                const avgZ = face.reduce((sum, i) => sum + projected[i].z, 0) / face.length;
                return { face, depth: avgZ };
            });
            faceDepths.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faceDepths.forEach(({ face }, faceIndex) => {
                ctx.beginPath();
                ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                }
                ctx.closePath();
                
                // Apply lighting based on face orientation and day/night cycle
                const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
                const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
                const faceLight = 0.7 + faceIndex * 0.05; // Different faces have different lighting
                const finalLight = lightIntensity * faceLight;
                
                ctx.fillStyle = adjustColorBrightness(color, finalLight);
                ctx.fill();
                
                if (outline) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
            
            return projected; // Return projected vertices for click detection
        }
        
        function getProjectedCube(x, y, z, size) {
            // Calculate cube projection without drawing - for click detection only
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            return vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
        }
        
        function drawPlane(x, y, z, width, height, color) {
            // Draw ground plane
            const hw = width / 2;
            const hh = height / 2;
            
            const corners = [
                project3D(x - hw, y, z - hh),
                project3D(x + hw, y, z - hh),
                project3D(x + hw, y, z + hh),
                project3D(x - hw, y, z + hh)
            ];
            
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
            ctx.closePath();
            
            // Apply day/night lighting
            const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
            const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
            ctx.fillStyle = adjustColorBrightness(color, lightIntensity);
            ctx.fill();
            
            // Grid lines
            ctx.strokeStyle = adjustColorBrightness('#000', lightIntensity * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            return corners;
        }
        
        function adjustColorBrightness(color, factor) {
            // Convert hex color to RGB and adjust brightness
            const hex = color.replace('#', '');
            const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function isPointInProjectedQuad(point, quad) {
            // Simple point-in-polygon test for click detection
            let inside = false;
            for (let i = 0, j = quad.length - 1; i < quad.length; j = i++) {
                if (((quad[i].y > point.y) !== (quad[j].y > point.y)) &&
                    (point.x < (quad[j].x - quad[i].x) * (point.y - quad[i].y) / (quad[j].y - quad[i].y) + quad[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function plotContainsScreenPoint(x, y, plot) {
            // Use the "top" face of the cube for precise click detection
            const projected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
            
            // Top face vertices are indices [3,2,6,7] of the projected cube
            const topQuad = [
                projected[3], // top-left
                projected[2], // top-right
                projected[6], // bottom-right
                projected[7]  // bottom-left
            ];
            
            return isPointInProjectedQuad({x: x, y: y}, topQuad);
        }
        
        // Save/Load Game System
        function saveGame() {
            const gameState = {
                score: score,
                coins: coins,
                inventory: inventory,
                seedInventory: seedInventory,
                equipment: equipment,
                plots: plots.map(plot => ({
                    x: plot.x,
                    y: plot.y,
                    z: plot.z,
                    stage: plot.stage,
                    plantType: plot.plantType,
                    growthTimer: plot.growthTimer,
                    waterLevel: plot.waterLevel,
                    lastWatered: plot.lastWatered,
                    unlocked: plot.unlocked,
                    unlockCost: plot.unlockCost
                })),
                activeSprinklers: activeSprinklers,
                objectives: objectives,
                dayNightCycle: dayNightCycle,
                dayNightCycleCount: dayNightCycleCount,
                cameraFollowX: cameraFollowX,
                cameraFollowZ: cameraFollowZ
            };
            
            try {
                localStorage.setItem('pixelHarvestSave', JSON.stringify(gameState));
                console.log('Game saved successfully');
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }
        
        function loadGame() {
            try {
                const savedData = localStorage.getItem('pixelHarvestSave');
                if (!savedData) return false;
                
                const gameState = JSON.parse(savedData);
                
                // Restore basic game state
                score = gameState.score || 0;
                coins = gameState.coins || 50;
                inventory = gameState.inventory || { carrot: 0, tomato: 0, rare: 0 };
                seedInventory = gameState.seedInventory || { carrot: 5, tomato: 2, rare: 1 };
                equipment = gameState.equipment || { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
                objectives = gameState.objectives || {
                    carrotsHarvested: 0,
                    dayNightCycles: 0,
                    coinsEarned: 0,
                    plantsHarvested: 0,
                    equipmentBought: 0,
                    seedsPlanted: 0,
                    plotsUnlocked: 9
                };
                dayNightCycle = gameState.dayNightCycle || 0;
                dayNightCycleCount = gameState.dayNightCycleCount || 0;
                cameraFollowX = gameState.cameraFollowX || 0;
                cameraFollowZ = gameState.cameraFollowZ || 0;
                
                // Restore sprinklers
                activeSprinklers = gameState.activeSprinklers || [];
                
                // Restore plots with plant reconstruction
                if (gameState.plots) {
                    plots = gameState.plots.map(savedPlot => {
                        const plot = {
                            x: savedPlot.x,
                            y: savedPlot.y,
                            z: savedPlot.z,
                            stage: savedPlot.stage,
                            plantType: savedPlot.plantType,
                            growthTimer: savedPlot.growthTimer,
                            waterLevel: savedPlot.waterLevel,
                            lastWatered: savedPlot.lastWatered,
                            unlocked: savedPlot.unlocked,
                            unlockCost: savedPlot.unlockCost,
                            plant: null
                        };
                        
                        // Reconstruct plant object if needed
                        if (plot.stage > PLANT_STAGES.EMPTY && plot.plantType) {
                            const plantConfig = PLANT_TYPES[plot.plantType];
                            let size = 0.3;
                            if (plot.stage === PLANT_STAGES.GROWING1) size = 0.6;
                            else if (plot.stage === PLANT_STAGES.GROWING2) size = 0.9;
                            else if (plot.stage === PLANT_STAGES.MATURE) size = 1.2;
                            
                            plot.plant = {
                                size: size,
                                color: plantConfig.color,
                                baseColor: plantConfig.color
                            };
                            
                            if (plot.stage === PLANT_STAGES.MATURE) {
                                plot.plant.glow = true;
                            }
                            
                            // Handle withered plants
                            if (plot.stage === PLANT_STAGES.WITHERING) {
                                plot.plant.color = adjustColorBrightness(plantConfig.color, 0.5);
                            }
                        }
                        
                        return plot;
                    });
                }
                
                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }
        
        function newGame() {
            // Clear save data
            localStorage.removeItem('pixelHarvestSave');
            
            // Reset all game state
            score = 0;
            coins = 50;
            dayNightCycle = 0;
            dayNightCycleCount = 0;
            cameraFollowX = 0;
            cameraFollowZ = 0;
            
            inventory = { carrot: 0, tomato: 0, rare: 0 };
            seedInventory = { carrot: 5, tomato: 2, rare: 1 };
            equipment = { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
            activeSprinklers = [];
            objectives = {
                carrotsHarvested: 0,
                dayNightCycles: 0,
                coinsEarned: 0,
                plantsHarvested: 0,
                equipmentBought: 0,
                seedsPlanted: 0,
                plotsUnlocked: 9
            };
            
            // Recreate plots
            createPlots();
            
            // Update UI
            updateUI();
            updateObjectives();
            
            // Clear any effects
            if (window.gameEffects) window.gameEffects = [];
            
            console.log('New game started');
        }
        
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize audio
            initAudio();
            
            // Load saved controls
            loadSavedControls();
            
            // Try to load saved game, otherwise create new game
            if (!loadGame()) {
                // Initialize camera
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
                
                // Create farming plots
                createPlots();
            } else {
                // Initialize camera for loaded game
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
            }
            
            // Add event listeners
            addEventListeners();
            
            // Initialize UI
            setupUI();
            
            // Update instructions with current controls
            updateInstructions();
            
            // Set up auto-save (every 10 seconds)
            autoSaveInterval = setInterval(saveGame, 10000);
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('dayNightIndicator').style.display = 'block';
            document.getElementById('plantSelector').style.display = 'block';
            document.getElementById('inventory').style.display = 'block';
            document.getElementById('marketplace').style.display = 'block';
            document.getElementById('objectives').style.display = 'block';
            document.getElementById('settingsButton').style.display = 'block';
            document.getElementById('newGameButton').style.display = 'block';
            
            // Start game loop
            animate();
        }
        
        // Audio system functions
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Initialize wind ambience
                initWindAmbience();
                
                // Schedule bird sounds
                scheduleBirdSounds();
                
            } catch (e) {
                console.log('Web Audio API not supported', e);
            }
        }
        
        function initWindAmbience() {
            if (!audioContext) return;
            
            // Create wind sound using brown noise
            const bufferSize = audioContext.sampleRate * 2; // 2 seconds
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 0.1; // Lower volume
            }
            
            const windSource = audioContext.createBufferSource();
            windSource.buffer = buffer;
            windSource.loop = true;
            
            windGain = audioContext.createGain();
            windGain.gain.value = 0.1;
            
            // Create an irregular wind pattern
            const lfo = audioContext.createOscillator();
            lfo.frequency.value = 0.3; // Very slow modulation
            lfo.type = 'sine';
            
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 0.05;
            
            lfo.connect(lfoGain);
            lfoGain.connect(windGain.gain);
            
            windSource.connect(windGain);
            windGain.connect(audioContext.destination);
            
            // Start the wind with proper audio context handling
            const startAudio = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        try {
                            windSource.start();
                            lfo.start();
                        } catch (e) {
                            console.log('Audio already started', e);
                        }
                    });
                } else {
                    try {
                        windSource.start();
                        lfo.start();
                    } catch (e) {
                        console.log('Audio already started', e);
                    }
                }
            };
            
            // Try to start immediately, or wait for user interaction
            if (audioContext.state === 'running') {
                startAudio();
            } else {
                document.addEventListener('click', startAudio, { once: true });
                document.addEventListener('keydown', startAudio, { once: true });
            }
        }
        
        function scheduleBirdSounds() {
            if (!audioContext) return;
            
            const playBirdSound = () => {
                if (Date.now() - lastBirdSound > 15000) { // At least 15 seconds between bird sounds
                    createBirdSound();
                    lastBirdSound = Date.now();
                }
                
                // Schedule next bird sound randomly between 20-60 seconds
                const nextDelay = 20000 + Math.random() * 40000;
                setTimeout(playBirdSound, nextDelay);
            };
            
            // Start first bird sound after 10 seconds
            setTimeout(playBirdSound, 10000);
        }
        
        function createBirdSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Random bird chirp frequency
            const baseFreq = 800 + Math.random() * 1200;
            oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, audioContext.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, audioContext.currentTime + 0.2);
            
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function playActionSound(action) {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                switch (action) {
                    case 'plant':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'triangle';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'harvest':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.1);
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'water':
                        // Water splash sound
                        const whiteNoise = audioContext.createBufferSource();
                        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < buffer.length; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }
                        whiteNoise.buffer = buffer;
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 1000;
                        
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        whiteNoise.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        whiteNoise.start(audioContext.currentTime);
                        whiteNoise.stop(audioContext.currentTime + 0.3);
                        return; // Don't use oscillator for water sound
                        
                    case 'unlock':
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        oscillator.frequency.exponentialRampToValueAtTime(900, audioContext.currentTime + 0.2);
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime);
            } catch (e) {
                console.log('Audio playback error:', e);
            }
        }
        
        function createPlots() {
            // Create a 5x5 grid of farming plots (some locked initially)
            plots = [];
            for (let x = -8; x <= 8; x += 4) {
                for (let z = -8; z <= 8; z += 4) {
                    const distanceFromCenter = Math.sqrt(x*x + z*z);
                    const plot = {
                        x: x,
                        y: 0,
                        z: z,
                        stage: PLANT_STAGES.EMPTY,
                        plant: null,
                        plantType: null,
                        growthTimer: 0,
                        waterLevel: 1.0,
                        lastWatered: Date.now(),
                        unlocked: distanceFromCenter <= 6, // Inner 3x3 grid unlocked initially
                        unlockCost: Math.floor(distanceFromCenter * 2)
                    };
                    plots.push(plot);
                }
            }
        }
        
        function setupUI() {
            // Plant selector buttons
            document.querySelectorAll('.plant-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedPlantType = e.target.dataset.plant;
                });
            });
            
            // Settings button
            document.getElementById('settingsButton').addEventListener('click', openSettings);
            
            // New Game button
            document.getElementById('newGameButton').addEventListener('click', () => {
                if (confirm('Are you sure you want to start a new game? This will delete your current progress.')) {
                    newGame();
                }
            });
            
            updateUI();
        }
        
        function addEventListeners() {
            // Mouse controls
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('contextmenu', onRightClick);
            canvas.addEventListener('wheel', onMouseWheel);
            
            // Keyboard controls
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onKeyDown(event) {
            // Handle key recording
            if (recordingKey) {
                event.preventDefault();
                const keyCode = event.code;
                
                // Update the control mapping
                controls[recordingKey] = keyCode;
                
                // Update the button display
                document.getElementById(`key-${recordingKey}`).textContent = getKeyDisplayName(keyCode);
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                
                // Stop recording
                recordingKey = null;
                
                // Update instructions
                updateInstructions();
                return;
            }
            
            keys[event.code] = true;
            
            // Toggle camera mode
            if (event.code === controls.camera) {
                freeCameraMode = !freeCameraMode;
                cameraFollowCharacter = !freeCameraMode;
                
                // Update camera mode display
                document.getElementById('cameraMode').textContent = 
                    freeCameraMode ? 'Camera: Free Mode' : 'Camera: Character Follow';
            }
            
            // Action keys
            if (event.code === controls.action) {
                event.preventDefault();
                performCharacterAction();
            }
            
            if (event.code === controls.water) {
                event.preventDefault();
                performWateringAction();
            }
            
            // Open settings with Escape key
            if (event.code === 'Escape') {
                event.preventDefault();
                if (document.getElementById('settingsMenu').style.display === 'block') {
                    cancelControls();
                } else {
                    openSettings();
                }
            }
        }
        
        function updateInstructions() {
            const forwardKey = getKeyDisplayName(controls.forward);
            const leftKey = getKeyDisplayName(controls.left);
            const backwardKey = getKeyDisplayName(controls.backward);
            const rightKey = getKeyDisplayName(controls.right);
            const actionKey = getKeyDisplayName(controls.action);
            const waterKey = getKeyDisplayName(controls.water);
            const cameraKey = getKeyDisplayName(controls.camera);
            
            document.getElementById('instructions').innerHTML = `
                üå± Move with ${forwardKey}${leftKey}${backwardKey}${rightKey} or arrow keys<br>
                ‚ö° ${actionKey} to plant/harvest at closest plot<br>
                üíß ${waterKey} to water plants<br>
                üìπ ${cameraKey} to toggle camera mode<br>
                üåø Plants grow automatically (3 stages)<br>
                üîí Unlock plots by getting close and pressing ${actionKey}<br>
                üåô Watch the day/night cycle!<br>
                üñ±Ô∏è Drag to rotate camera view<br>
                üîç Scroll wheel to zoom in/out<br>
                ‚öôÔ∏è ESC to open settings
            `;
        }
        
        function getKeyDisplayName(keyCode) {
            const keyMap = {
                'KeyZ': 'Z', 'KeyQ': 'Q', 'KeyS': 'S', 'KeyD': 'D',
                'KeyW': 'W', 'KeyA': 'A', 'KeyE': 'E', 'KeyC': 'C',
                'Space': 'SPACE', 'ArrowUp': '‚Üë', 'ArrowDown': '‚Üì',
                'ArrowLeft': '‚Üê', 'ArrowRight': '‚Üí', 'ShiftLeft': 'SHIFT',
                'ControlLeft': 'CTRL', 'AltLeft': 'ALT'
            };
            return keyMap[keyCode] || keyCode.replace('Key', '').replace('Digit', '');
        }
        
        // Settings menu functions
        function openSettings() {
            // Backup current controls
            backupControls = {...controls};
            
            // Update button displays
            updateControlButtons();
            
            // Show settings menu
            document.getElementById('settingsMenu').style.display = 'block';
        }
        
        function updateControlButtons() {
            Object.keys(controls).forEach(action => {
                const button = document.getElementById(`key-${action}`);
                if (button) {
                    button.textContent = getKeyDisplayName(controls[action]);
                }
            });
        }
        
        function recordKey(action) {
            if (recordingKey === action) {
                // Cancel recording
                document.getElementById(`key-${action}`).classList.remove('recording');
                recordingKey = null;
                return;
            }
            
            // Stop any current recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
            }
            
            // Start recording for this action
            recordingKey = action;
            document.getElementById(`key-${action}`).classList.add('recording');
            document.getElementById(`key-${action}`).textContent = 'Press key...';
        }
        
        function setControlPreset(preset) {
            // Stop any recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
            
            switch(preset) {
                case 'azerty':
                    controls.forward = 'KeyZ';
                    controls.left = 'KeyQ';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'qwerty':
                    controls.forward = 'KeyW';
                    controls.left = 'KeyA';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'arrows':
                    controls.forward = 'ArrowUp';
                    controls.left = 'ArrowLeft';
                    controls.backward = 'ArrowDown';
                    controls.right = 'ArrowRight';
                    break;
            }
            
            updateControlButtons();
        }
        
        function saveControls() {
            // Save to localStorage
            localStorage.setItem('pixelHarvestControls', JSON.stringify(controls));
            
            // Update instructions
            updateInstructions();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            recordingKey = null;
        }
        
        function cancelControls() {
            // Restore backup controls
            controls = {...backupControls};
            
            // Update button displays
            updateControlButtons();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
        }
        
        function resetControls() {
            // Reset to AZERTY default
            controls = {
                forward: 'KeyZ',
                left: 'KeyQ',
                backward: 'KeyS',
                right: 'KeyD',
                action: 'Space',
                water: 'KeyE',
                camera: 'KeyC'
            };
            updateControlButtons();
        }
        
        function loadSavedControls() {
            const saved = localStorage.getItem('pixelHarvestControls');
            if (saved) {
                try {
                    controls = JSON.parse(saved);
                } catch (e) {
                    console.log('Failed to load saved controls, using defaults');
                }
            }
        }
        
        function onKeyUp(event) {
            keys[event.code] = false;
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (mouseDown && freeCameraMode) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                // Clear hover state when dragging
                hoveredPlot = null;
            } else if (mouseDown && !freeCameraMode) {
                // In character follow mode, still allow some camera control
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.005; // Reduced sensitivity
                cameraAngleX += deltaY * 0.005;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            } else {
                // Check for plot hover only in free camera mode
                if (freeCameraMode) {
                    hoveredPlot = null;
                    plots.forEach(plot => {
                        if (plotContainsScreenPoint(mouseX, mouseY, plot)) {
                            hoveredPlot = plot;
                        }
                    });
                }
                
                // Update cursor based on hover state and camera mode
                if (freeCameraMode) {
                    canvas.style.cursor = hoveredPlot ? 'pointer' : 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        }
        
        function onMouseUp(event) {
            mouseDown = false;
        }
        
        function onMouseLeave(event) {
            mouseDown = false; // Reset mouse state when leaving canvas
        }
        
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling
            
            // Zoom in/out based on wheel direction
            const zoomSpeed = 0.5;
            const zoomDirection = event.deltaY > 0 ? 1 : -1; // Positive = zoom out, negative = zoom in
            
            cameraDistance += zoomDirection * zoomSpeed;
            
            // Limit zoom range
            cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Min: 3, Max: 20
        }
        
        function onRightClick(event) {
            event.preventDefault();
            
            if (!freeCameraMode) return; // Only allow right-click watering in free camera mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks for watering
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    waterPlot(plot);
                }
            });
        }
        
        function waterPlot(plot) {
            if (plot.stage !== PLANT_STAGES.EMPTY) {
                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.5);
                plot.lastWatered = Date.now();
                
                // Play water sound
                playActionSound('water');
                
                // Revive withered plants when watered
                if (plot.stage === PLANT_STAGES.WITHERING && plot.waterLevel > 0.3) {
                    // Determine what stage the plant should return to based on its growth timer
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    const growthProgress = Math.floor(plot.growthTimer / plantConfig.growthTime);
                    
                    if (growthProgress >= 2) {
                        plot.stage = PLANT_STAGES.GROWING2;
                    } else if (growthProgress >= 1) {
                        plot.stage = PLANT_STAGES.GROWING1;
                    } else {
                        plot.stage = PLANT_STAGES.PLANTED;
                    }
                    
                    // Restore plant color
                    if (plot.plant) {
                        plot.plant.color = plot.plant.baseColor || PLANT_TYPES[plot.plantType].color;
                    }
                }
                
                // Visual feedback for watering
                createWaterEffect(plot);
                saveGame(); // Auto-save after watering
            }
        }
        
        function createWaterEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'water',
                emoji: 'üíß'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function onMouseClick(event) {
            if (mouseDown || !freeCameraMode) return; // Ignore clicks during drag or in character mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks without drawing
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    handlePlotClick(plot);
                }
            });
        }
        
        function handlePlotClick(plot) {
            // Handle equipment placement
            if (selectedEquipment === 'sprinkler' && plot.unlocked) {
                // Check if there's already a sprinkler here
                const existingSprinkler = activeSprinklers.find(s => s.x === plot.x && s.z === plot.z);
                if (!existingSprinkler) {
                    activeSprinklers.push({
                        x: plot.x,
                        y: plot.y + 1,
                        z: plot.z,
                        range: 6, // Affects plots within 6 units
                        lastSprinkleTime: 0  // Initialize to 0 for immediate first sprinkle
                    });
                    
                    equipment.sprinkler--; // Remove from inventory
                    selectedEquipment = null;
                    canvas.style.cursor = 'crosshair';
                    
                    showInstruction('Auto Sprinkler placed! It will water nearby plants automatically.', 2000);
                    updateUI();
                    saveGame(); // Auto-save after placing sprinkler
                }
                return;
            }
            
            if (!plot.unlocked) {
                // Try to unlock the plot
                if (coins >= plot.unlockCost) {
                    coins -= plot.unlockCost;
                    plot.unlocked = true;
                    objectives.plotsUnlocked++; // Increment unlocked plots counter
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    
                    // Create unlock effect
                    createUnlockEffect(plot);
                }
                return;
            }
            
            if (plot.stage === PLANT_STAGES.EMPTY) {
                plantSeed(plot, selectedPlantType);
            } else if (plot.stage === PLANT_STAGES.MATURE) {
                harvestPlant(plot);
            }
        }
        
        function createUnlockEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'unlock',
                emoji: 'üîì'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function plantSeed(plot, plantType) {
            if (seedInventory[plantType] <= 0) {
                return; // No seeds available
            }
            
            const plantConfig = PLANT_TYPES[plantType];
            seedInventory[plantType]--;
            objectives.seedsPlanted++;
            
            plot.stage = PLANT_STAGES.PLANTED;
            plot.plantType = plantType;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            plot.lastWatered = Date.now();
            plot.plant = {
                size: 0.3,
                color: plantConfig.color,
                baseColor: plantConfig.color
            };
            
            // Play plant sound
            playActionSound('plant');
            
            updateUI();
            updateObjectives();
            saveGame(); // Auto-save after planting
        }
        
        function growPlant(plot) {
            const plantConfig = PLANT_TYPES[plot.plantType];
            
            if (plot.stage === PLANT_STAGES.PLANTED) {
                plot.stage = PLANT_STAGES.GROWING1;
                plot.plant.size = 0.6;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING1) {
                plot.stage = PLANT_STAGES.GROWING2;
                plot.plant.size = 0.9;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING2) {
                plot.stage = PLANT_STAGES.MATURE;
                plot.plant.size = 1.2;
                // Add glow effect for mature plants
                plot.plant.glow = true;
            }
        }
        
        function harvestPlant(plot) {
            if (plot.stage !== PLANT_STAGES.MATURE) return;
            
            const plantType = plot.plantType;
            const plantConfig = PLANT_TYPES[plantType];
            
            // Add to inventory
            inventory[plantType]++;
            
            // Add score
            score += plantConfig.value;
            
            // Update objectives
            if (plantType === 'carrot') {
                objectives.carrotsHarvested++;
            }
            objectives.plantsHarvested++;
            
            // Reset plot
            plot.stage = PLANT_STAGES.EMPTY;
            plot.plant = null;
            plot.plantType = null;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            
            // Play harvest sound
            playActionSound('harvest');
            
            // Create harvest effect with animation
            createHarvestEffect(plot);
            
            updateUI();
            updateObjectives();
            saveGame(); // Auto-save after harvesting
        }
        
        function createHarvestEffect(plot) {
            // Create floating score animation
            const effect = {
                x: plot.x,
                y: plot.y + 2,
                z: plot.z,
                timer: 0,
                duration: 2000,
                type: 'harvest'
            };
            
            // Add to effects array (we'll create this)
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function updateEffects(deltaTime) {
            if (!window.gameEffects) return;
            
            // Update and remove expired effects
            window.gameEffects = window.gameEffects.filter(effect => {
                effect.timer += deltaTime;
                effect.y += deltaTime * 0.001; // Float upward
                
                return effect.timer < effect.duration;
            });
        }
        
        function renderEffects() {
            if (!window.gameEffects) return;
            
            window.gameEffects.forEach(effect => {
                const alpha = 1 - (effect.timer / effect.duration);
                ctx.save();
                ctx.globalAlpha = alpha;
                
                const projected = project3D(effect.x, effect.y, effect.z);
                
                if (effect.type === 'harvest') {
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+1', projected.x, projected.y);
                } else if (effect.type === 'plant' || effect.type === 'water' || effect.type === 'unlock') {
                    // Action effects with emoji
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(effect.emoji, projected.x, projected.y);
                    
                    // Add action name below emoji
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    let actionName = '';
                    if (effect.type === 'plant') actionName = 'Planted!';
                    else if (effect.type === 'water') actionName = 'Watered!';
                    else if (effect.type === 'unlock') actionName = 'Unlocked!';
                    
                    ctx.strokeText(actionName, projected.x, projected.y + 20);
                    ctx.fillText(actionName, projected.x, projected.y + 20);
                }
                
                ctx.restore();
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateUI() {
            // Update score and coins
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('coins').textContent = coins;
            
            // Update inventory
            document.getElementById('carrotCount').textContent = `ü•ï Carrots: ${inventory.carrot}`;
            document.getElementById('tomatoCount').textContent = `üçÖ Tomatoes: ${inventory.tomato}`;
            document.getElementById('rareCount').textContent = `‚ú® Rare Plants: ${inventory.rare}`;
            
            // Update equipment inventory
            document.getElementById('sprinklerCount').textContent = `üíß Auto Sprinklers: ${equipment.sprinkler}`;
            document.getElementById('fertilizerCount').textContent = `üåø Fertilizer: ${equipment.fertilizer}`;
            document.getElementById('greenhouseCount').textContent = `üè† Greenhouses: ${equipment.greenhouse}`;
            
            // Update plant buttons availability
            document.querySelectorAll('.plant-btn').forEach(btn => {
                const plantType = btn.dataset.plant;
                const hasSeeds = seedInventory[plantType] > 0;
                btn.disabled = !hasSeeds;
                btn.style.opacity = hasSeeds ? '1' : '0.5';
                
                // Update button text with seed count
                const plantConfig = PLANT_TYPES[plantType];
                btn.textContent = `${plantConfig.emoji} ${plantConfig.name} (${seedInventory[plantType]})`;
            });
            
            // Update equipment buttons availability
            const sprinklerBtn = document.getElementById('sprinklerBtn');
            const fertilizerBtn = document.getElementById('fertilizerBtn');
            const greenhouseBtn = document.getElementById('greenhouseBtn');
            
            if (sprinklerBtn) {
                sprinklerBtn.disabled = coins < 150;
                sprinklerBtn.style.opacity = coins >= 150 ? '1' : '0.5';
            }
            if (fertilizerBtn) {
                fertilizerBtn.disabled = coins < 50;
                fertilizerBtn.style.opacity = coins >= 50 ? '1' : '0.5';
            }
            if (greenhouseBtn) {
                greenhouseBtn.disabled = coins < 300;
                greenhouseBtn.style.opacity = coins >= 300 ? '1' : '0.5';
            }
        }
        
        function updateObjectives() {
            // Update objective displays
            document.getElementById('objective1').textContent = 
                `ü•ï Harvest 5 carrots (${Math.min(objectives.carrotsHarvested, 5)}/5)`;
            document.getElementById('objective2').textContent = 
                `üåô Survive 2 day/night cycles (${Math.min(objectives.dayNightCycles, 2)}/2)`;
            document.getElementById('objective3').textContent = 
                `üí∞ Earn 20 coins (${Math.min(objectives.coinsEarned, 20)}/20)`;
            document.getElementById('objective4').textContent = 
                `üåæ Harvest 25 total plants (${Math.min(objectives.plantsHarvested, 25)}/25)`;
            document.getElementById('objective5').textContent = 
                `üîß Buy any equipment (${Math.min(objectives.equipmentBought, 1)}/1)`;
            document.getElementById('objective6').textContent = 
                `üí∞ Earn 500 coins (${Math.min(objectives.coinsEarned, 500)}/500)`;
            document.getElementById('objective7').textContent = 
                `üå± Plant 50 seeds (${Math.min(objectives.seedsPlanted, 50)}/50)`;
            document.getElementById('objective8').textContent = 
                `üèÜ Unlock all plots (${Math.min(objectives.plotsUnlocked, 25)}/25)`;
                
            // Check for completed objectives and show new ones
            if (objectives.carrotsHarvested >= 5 && objectives.dayNightCycles >= 2 && objectives.coinsEarned >= 20) {
                document.getElementById('objective1').style.color = '#4CAF50';
                document.getElementById('objective2').style.color = '#4CAF50';
                document.getElementById('objective3').style.color = '#4CAF50';
                
                // Show next tier objectives
                document.getElementById('objective4').style.display = 'block';
                document.getElementById('objective5').style.display = 'block';
            }
            
            if (objectives.plantsHarvested >= 25 && objectives.equipmentBought >= 1) {
                document.getElementById('objective4').style.color = '#4CAF50';
                document.getElementById('objective5').style.color = '#4CAF50';
                
                // Show final tier objectives
                document.getElementById('objective6').style.display = 'block';
                document.getElementById('objective7').style.display = 'block';
                document.getElementById('objective8').style.display = 'block';
            }
            
            if (objectives.coinsEarned >= 500) {
                document.getElementById('objective6').style.color = '#4CAF50';
            }
            if (objectives.seedsPlanted >= 50) {
                document.getElementById('objective7').style.color = '#4CAF50';
            }
            if (objectives.plotsUnlocked >= 25) {
                document.getElementById('objective8').style.color = '#4CAF50';
            }
        }
        
        // Marketplace functions
        function sellAll(plantType) {
            const count = inventory[plantType];
            if (count <= 0) return;
            
            const plantConfig = PLANT_TYPES[plantType];
            const earnings = count * plantConfig.value;
            
            inventory[plantType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            updateUI();
            updateObjectives();
            saveGame(); // Auto-save after selling
        }
        
        function buySeeds(plantType, cost) {
            if (coins >= cost) {
                coins -= cost;
                seedInventory[plantType] += 5; // Buy 5 seeds at a time
                updateUI();
                saveGame(); // Auto-save after buying seeds
            }
        }
        
        function buyItem(itemType, cost) {
            if (coins >= cost) {
                coins -= cost;
                equipment[itemType]++;
                objectives.equipmentBought++;
                
                // Special handling for different equipment
                if (itemType === 'sprinkler') {
                    // Player needs to place the sprinkler
                    selectedEquipment = 'sprinkler';
                    canvas.style.cursor = 'crosshair';
                    showInstruction('Click on a plot to place the Auto Sprinkler!', 3000);
                } else if (itemType === 'fertilizer') {
                    // Fertilizer is applied automatically to all plants
                    showInstruction('Fertilizer pack applied! All plants grow 20% faster.', 2000);
                } else if (itemType === 'greenhouse') {
                    // Greenhouse provides passive benefits
                    showInstruction('Mini Greenhouse built! Plants grow better day and night.', 2000);
                }
                
                updateUI();
                updateObjectives();
                saveGame(); // Auto-save after buying equipment
            }
        }
        
        function showInstruction(text, duration) {
            // Create a temporary instruction overlay
            const instruction = document.createElement('div');
            instruction.style.position = 'absolute';
            instruction.style.top = '50%';
            instruction.style.left = '50%';
            instruction.style.transform = 'translate(-50%, -50%)';
            instruction.style.background = 'rgba(0, 0, 0, 0.8)';
            instruction.style.color = 'white';
            instruction.style.padding = '15px 25px';
            instruction.style.borderRadius = '10px';
            instruction.style.fontSize = '18px';
            instruction.style.zIndex = '200';
            instruction.style.border = '2px solid #4CAF50';
            instruction.textContent = text;
            
            document.body.appendChild(instruction);
            
            setTimeout(() => {
                document.body.removeChild(instruction);
            }, duration);
        }
        
        function updateDayNightCycle() {
            const oldProgress = (Math.sin(dayNightCycle) + 1) / 2;
            dayNightCycle += 0.01;
            const newProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Check for day/night cycle completion
            if (oldProgress > 0.5 && newProgress <= 0.5) {
                dayNightCycleCount++;
                objectives.dayNightCycles = dayNightCycleCount;
                updateObjectives();
            }
            
            // Calculate day/night progression
            const dayProgress = newProgress;
            const isDay = dayProgress > 0.5;
            
            // Update time display
            document.getElementById('timeDisplay').textContent = isDay ? 'Day' : 'Night';
            
            // Update background color
            const dayColor = { r: 135, g: 206, b: 235 }; // Sky blue
            const nightColor = { r: 25, g: 25, b: 112 }; // Midnight blue
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }
        
        function updatePlantGrowth(deltaTime) {
            const currentTime = Date.now();
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Auto-sprinkler functionality - deterministic timing
            activeSprinklers.forEach(sprinkler => {
                // Check if 5 seconds have passed since last sprinkle
                if (currentTime - sprinkler.lastSprinkleTime >= 5000) {
                    plots.forEach(plot => {
                        if (plot.stage !== PLANT_STAGES.EMPTY) {
                            const distance = Math.sqrt(
                                Math.pow(plot.x - sprinkler.x, 2) + 
                                Math.pow(plot.z - sprinkler.z, 2)
                            );
                            
                            if (distance <= sprinkler.range && plot.waterLevel < 0.8) {
                                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.3);
                                plot.lastWatered = currentTime;
                                
                                // Create water effect
                                createWaterEffect(plot);
                            }
                        }
                    });
                    
                    // Update last sprinkle time
                    sprinkler.lastSprinkleTime = currentTime;
                }
            });
            
            plots.forEach(plot => {
                if (plot.stage !== PLANT_STAGES.EMPTY && plot.stage !== PLANT_STAGES.MATURE) {
                    // Water decay - simple time-based model
                    const deltaTimeSeconds = deltaTime / 1000;
                    plot.waterLevel = Math.max(0, plot.waterLevel - waterDecayRate * deltaTimeSeconds);
                    
                    // Get plant configuration
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    
                    // Calculate growth speed based on conditions
                    let growthMultiplier = 1;
                    
                    // Equipment bonuses
                    if (equipment.fertilizer > 0) {
                        growthMultiplier *= 1.2; // 20% faster growth with fertilizer
                    }
                    
                    if (equipment.greenhouse > 0) {
                        growthMultiplier *= 1.1; // 10% faster growth with greenhouse
                        // Greenhouse also provides weather protection
                        if (!isDay) growthMultiplier *= 1.2; // Better night growth
                    }
                    
                    // Day/night preference
                    if (plantConfig.dayPreference === isDay) {
                        growthMultiplier *= 1.5;
                    } else {
                        growthMultiplier *= 0.7;
                    }
                    
                    // Water level affects growth
                    if (plot.waterLevel > plantConfig.waterNeed) {
                        growthMultiplier *= 1.2;
                    } else if (plot.waterLevel < plantConfig.waterNeed * 0.5) {
                        growthMultiplier *= 0.5;
                    }
                    
                    // Check for proximity bonus (plants grow faster near other plants)
                    const nearbyPlants = plots.filter(otherPlot => {
                        if (otherPlot === plot || otherPlot.stage === PLANT_STAGES.EMPTY) return false;
                        const distance = Math.sqrt(
                            Math.pow(plot.x - otherPlot.x, 2) + Math.pow(plot.z - otherPlot.z, 2)
                        );
                        return distance <= 4.5; // Adjacent plots
                    });
                    
                    if (nearbyPlants.length > 0) {
                        growthMultiplier *= (1 + nearbyPlants.length * 0.1);
                    }
                    
                    // Apply growth
                    plot.growthTimer += deltaTime * growthMultiplier;
                    
                    // Check if plant should grow
                    if (plot.growthTimer >= plantConfig.growthTime) {
                        growPlant(plot);
                    }
                    
                    // Check if plant should wither due to lack of water
                    if (plot.waterLevel <= 0 && plot.stage !== PLANT_STAGES.WITHERING) {
                        plot.stage = PLANT_STAGES.WITHERING;
                        // Store baseColor if not already stored, then darken
                        if (!plot.plant.baseColor) {
                            plot.plant.baseColor = plot.plant.color;
                        }
                        plot.plant.color = adjustColorBrightness(plot.plant.baseColor, 0.5);
                    }
                }
            });
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground (larger now)
            drawPlane(0, 0, 0, 25, 25, colors.ground);
            
            // Draw plots and plants
            plots.forEach(plot => {
                if (!plot.unlocked) {
                    // Draw locked plot with different color
                    drawCube(plot.x, plot.y + 0.1, plot.z, 2, '#555555');
                    
                    // Draw unlock cost indicator
                    const projected = project3D(plot.x, plot.y + 1, plot.z);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${plot.unlockCost}üí∞`, projected.x, projected.y);
                    return;
                }
                
                // Determine if plot should be highlighted
                const isHovered = hoveredPlot === plot;
                let plotColor = colors.plot;
                
                // Show different colors based on water level
                if (plot.stage !== PLANT_STAGES.EMPTY) {
                    if (plot.waterLevel < 0.3) {
                        plotColor = colors.dryPlot;
                    } else if (plot.waterLevel > 0.8) {
                        plotColor = adjustColorBrightness(colors.plot, 1.2);
                    }
                }
                
                if (isHovered) {
                    plotColor = colors.plotHover;
                }
                
                // Draw plot
                drawCube(plot.x, plot.y + 0.1, plot.z, 2, plotColor);
                
                // Draw plant if exists
                if (plot.plant) {
                    let plantColor = plot.plant.color;
                    
                    // Add glow effect for mature plants
                    if (plot.stage === PLANT_STAGES.MATURE && plot.plant.glow) {
                        const glowIntensity = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
                        plantColor = adjustColorBrightness(plot.plant.color, 1 + glowIntensity * 0.3);
                        
                        // Draw glow effect around mature plants
                        const glowSize = plot.plant.size * 1.3;
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, glowSize, '#FFFF00', false);
                        ctx.restore();
                    }
                    
                    if (isHovered) {
                        plantColor = adjustColorBrightness(plantColor, 1.3);
                    }
                    
                    drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, plot.plant.size, plantColor);
                    
                    // Draw water level indicator for watered plants
                    if (plot.waterLevel > 0.8 && plot.stage !== PLANT_STAGES.EMPTY) {
                        ctx.save();
                        ctx.globalAlpha = 0.4;
                        drawCube(plot.x, plot.y + 0.15, plot.z, 2.2, colors.water, false);
                        ctx.restore();
                    }
                }
            });
            
            // Draw character
            drawCharacter();
            
            // Draw sprinklers
            drawSprinklers();
            
            // Add some decorative elements
            drawDecorations();
            
            // Render visual effects
            renderEffects();
        }
        
        function drawSprinklers() {
            activeSprinklers.forEach(sprinkler => {
                // Draw sprinkler base
                drawCube(sprinkler.x, sprinkler.y, sprinkler.z, 1, '#4169E1');
                
                // Draw sprinkler head
                drawCube(sprinkler.x, sprinkler.y + 0.5, sprinkler.z, 0.6, '#87CEEB');
                
                // Draw water effect if it's working (show for 1 second after sprinkle)
                if (Date.now() - sprinkler.lastSprinkleTime < 1000) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw water spray area
                    const projected = project3D(sprinkler.x, sprinkler.y + 0.8, sprinkler.z);
                    const radiusScale = sprinkler.range * 10; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#87CEEB';
                    ctx.fill();
                    ctx.restore();
                }
            });
        }
        
        function drawDecorations() {
            // Add trees around the farm
            const trees = [
                { x: -12, y: 0, z: -12 },
                { x: 12, y: 0, z: -12 },
                { x: -12, y: 0, z: 12 },
                { x: 12, y: 0, z: 12 }
            ];
            
            trees.forEach(tree => {
                // Tree trunk
                drawCube(tree.x, tree.y + 0.5, tree.z, 1, '#8B4513');
                // Tree leaves
                drawCube(tree.x, tree.y + 1.5, tree.z, 2.5, '#228B22');
            });
            
            // Add rocks
            const rocks = [
                { x: -10, y: 0, z: 0 },
                { x: 10, y: 0, z: 0 },
                { x: 0, y: 0, z: -10 },
                { x: 0, y: 0, z: 10 }
            ];
            
            rocks.forEach(rock => {
                drawCube(rock.x, rock.y + 0.3, rock.z, 1.5, '#696969');
            });
            
            // Draw fences around the unlocked farm area
            const unlockedPlots = plots.filter(p => p.unlocked);
            if (unlockedPlots.length > 0) {
                const minX = Math.min(...unlockedPlots.map(p => p.x)) - 2;
                const maxX = Math.max(...unlockedPlots.map(p => p.x)) + 2;
                const minZ = Math.min(...unlockedPlots.map(p => p.z)) - 2;
                const maxZ = Math.max(...unlockedPlots.map(p => p.z)) + 2;
                
                // Draw fence posts
                for (let x = minX; x <= maxX; x += 4) {
                    drawCube(x, 0.4, minZ, 0.3, '#8B4513'); // North fence
                    drawCube(x, 0.4, maxZ, 0.3, '#8B4513'); // South fence
                }
                for (let z = minZ; z <= maxZ; z += 4) {
                    drawCube(minX, 0.4, z, 0.3, '#8B4513'); // West fence
                    drawCube(maxX, 0.4, z, 0.3, '#8B4513'); // East fence
                }
            }
        }
        
        function updateCharacter(deltaTime) {
            // Handle keyboard input for movement
            let moveX = 0;
            let moveZ = 0;
            
            if (keys[controls.forward] || keys['ArrowUp']) moveZ -= 1;
            if (keys[controls.backward] || keys['ArrowDown']) moveZ += 1;
            if (keys[controls.left] || keys['ArrowLeft']) moveX -= 1;
            if (keys[controls.right] || keys['ArrowRight']) moveX += 1;
            
            // Normalize movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
                
                // Calculate target direction
                character.targetDirection = Math.atan2(moveX, moveZ);
                
                // Set target position
                character.targetX = character.x + moveX * character.speed * deltaTime;
                character.targetZ = character.z + moveZ * character.speed * deltaTime;
                
                // Constrain to farm area
                const maxDistance = 10;
                character.targetX = Math.max(-maxDistance, Math.min(maxDistance, character.targetX));
                character.targetZ = Math.max(-maxDistance, Math.min(maxDistance, character.targetZ));
                
                character.moving = true;
                character.currentAction = 'walking';
            } else {
                character.moving = false;
                if (character.currentAction === 'walking') {
                    character.currentAction = 'idle';
                }
            }
            
            // Smooth movement
            if (character.moving) {
                const lerpFactor = 0.1;
                character.x += (character.targetX - character.x) * lerpFactor;
                character.z += (character.targetZ - character.z) * lerpFactor;
            }
            
            // Smooth rotation
            const angleDiff = character.targetDirection - character.direction;
            let adjustedAngleDiff = angleDiff;
            
            // Handle angle wrapping
            if (adjustedAngleDiff > Math.PI) {
                adjustedAngleDiff -= 2 * Math.PI;
            } else if (adjustedAngleDiff < -Math.PI) {
                adjustedAngleDiff += 2 * Math.PI;
            }
            
            character.direction += adjustedAngleDiff * 0.1;
            
            // Update animation frame
            if (character.moving) {
                character.animationFrame += deltaTime * 0.01;
            }
            
            // Update action timer
            if (character.actionTimer > 0) {
                character.actionTimer -= deltaTime;
                if (character.actionTimer <= 0) {
                    character.currentAction = 'idle';
                }
            }
            
            // Update camera to follow character
            if (cameraFollowCharacter) {
                updateCameraFollow();
            }
            
            // Update character status display
            updateCharacterStatusDisplay();
        }
        
        function updateCharacterStatusDisplay() {
            const statusElement = document.getElementById('characterStatus');
            let statusText = `Character: ${character.currentAction.charAt(0).toUpperCase() + character.currentAction.slice(1)}`;
            
            // Add position info
            statusText += ` (${character.x.toFixed(1)}, ${character.z.toFixed(1)})`;
            
            // Add closest plot info
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                if (distance <= 2.5) {
                    statusText += ` - Near plot (${distance.toFixed(1)}m)`;
                }
            }
            
            statusElement.textContent = statusText;
            
            // Color code based on action
            if (character.currentAction === 'walking') {
                statusElement.style.color = '#87CEEB';
            } else if (character.currentAction === 'planting') {
                statusElement.style.color = '#32CD32';
            } else if (character.currentAction === 'watering') {
                statusElement.style.color = '#4169E1';
            } else {
                statusElement.style.color = '#FFD700';
            }
        }
        
        function updateCameraFollow() {
            // Smoothly lerp camera follow position to character position
            cameraFollowX += (character.x - cameraFollowX) * cameraFollowLerp;
            cameraFollowZ += (character.z - cameraFollowZ) * cameraFollowLerp;
        }
        
        function drawCharacter() {
            // Character body
            let characterColor = character.color;
            
            // Apply action-based color changes
            if (character.currentAction === 'planting') {
                characterColor = '#32CD32'; // Green for planting
            } else if (character.currentAction === 'watering') {
                characterColor = '#87CEEB'; // Light blue for watering
            }
            
            // Add walking animation bob
            let yOffset = 0;
            if (character.moving && character.currentAction === 'walking') {
                yOffset = Math.sin(character.animationFrame * 5) * 0.1;
            }
            
            // Draw character body
            drawCube(
                character.x, 
                character.y + character.size/2 + yOffset, 
                character.z, 
                character.size, 
                characterColor
            );
            
            // Draw character head
            drawCube(
                character.x, 
                character.y + character.size * 1.3 + yOffset, 
                character.z, 
                character.size * 0.6, 
                '#FDBCB4' // Skin color
            );
            
            // Draw direction indicator (small arrow)
            const arrowSize = 0.3;
            const arrowDistance = character.size * 0.8;
            const arrowX = character.x + Math.sin(character.direction) * arrowDistance;
            const arrowZ = character.z + Math.cos(character.direction) * arrowDistance;
            
            drawCube(arrowX, character.y + character.size + yOffset, arrowZ, arrowSize, '#FFD700');
            
            // Draw interaction radius for closest plot
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                
                // Draw interaction radius
                if (distance <= 2.5) {
                    // Draw green circle around character to show interaction is possible
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const projected = project3D(character.x, character.y + 0.1, character.z);
                    const radiusScale = 50; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw line to closest plot
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    const plotProjected = project3D(closestPlot.x, closestPlot.y + 0.5, closestPlot.z);
                    ctx.beginPath();
                    ctx.moveTo(projected.x, projected.y);
                    ctx.lineTo(plotProjected.x, plotProjected.y);
                    ctx.stroke();
                    ctx.restore();
                    
                    // Show action hint above character
                    ctx.save();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.lineWidth = 1;
                    
                    let actionText = '';
                    if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to plant`;
                    } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to harvest`;
                    } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                        actionText = `‚ö° ${getKeyDisplayName(controls.action)} to unlock (${closestPlot.unlockCost}üí∞)`;
                    } else if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                        actionText = `üíß ${getKeyDisplayName(controls.water)} to water`;
                    }
                    
                    if (actionText) {
                        const textY = projected.y - 60;
                        ctx.strokeText(actionText, projected.x, textY);
                        ctx.fillText(actionText, projected.x, textY);
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        function performCharacterAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                    // Plant seed
                    plantSeedAtPlot(closestPlot);
                    character.currentAction = 'planting';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create planting effect
                    createActionEffect(character.x, character.y + 1, character.z, 'plant', 'üå±');
                } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                    // Harvest plant
                    harvestPlant(closestPlot);
                    character.currentAction = 'planting'; // Reuse planting animation
                    character.actionTimer = 1000;
                    
                    // Create harvest effect
                    createActionEffect(character.x, character.y + 1, character.z, 'harvest', '‚ú®');
                } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                    // Unlock plot
                    coins -= closestPlot.unlockCost;
                    closestPlot.unlocked = true;
                    objectives.plotsUnlocked++;
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    character.currentAction = 'planting';
                    character.actionTimer = 1000;
                    
                    // Create unlock effect
                    createActionEffect(character.x, character.y + 1, character.z, 'unlock', 'üîì');
                }
            }
        }
        
        function performWateringAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                    waterPlot(closestPlot);
                    character.currentAction = 'watering';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create watering effect
                    createActionEffect(character.x, character.y + 1, character.z, 'water', 'üíß');
                }
            }
        }
        
        function createActionEffect(x, y, z, type, emoji) {
            const effect = {
                x: x,
                y: y,
                z: z,
                timer: 0,
                duration: 1500,
                type: type,
                emoji: emoji,
                startY: y
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function findClosestPlot() {
            let closestPlot = null;
            let closestDistance = Infinity;
            
            plots.forEach(plot => {
                const distance = getDistanceToPlot(plot);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPlot = plot;
                }
            });
            
            return closestPlot;
        }
        
        function getDistanceToPlot(plot) {
            return Math.sqrt(
                Math.pow(character.x - plot.x, 2) + 
                Math.pow(character.z - plot.z, 2)
            );
        }
        
        function plantSeedAtPlot(plot) {
            if (seedInventory[selectedPlantType] <= 0) {
                return; // No seeds available
            }
            
            plantSeed(plot, selectedPlantType);
        }
        
        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update character
            updateCharacter(deltaTime);
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update plant growth
            updatePlantGrowth(deltaTime);
            
            // Update visual effects
            updateEffects(deltaTime);
            
            // Render scene
            render();
        }
        
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>