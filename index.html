<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel-Harvest - 3D Farming Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #87CEEB, #4682B4);
            overflow: hidden;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            max-width: 300px;
        }
        
        #score {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        #instructions {
            font-size: 16px;
            opacity: 0.9;
            max-width: 300px;
        }

        #inventory {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        #plantSelector {
            position: absolute;
            top: 20px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 180px;
        }

        .plant-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .plant-btn:hover {
            background: #45a049;
        }

        .plant-btn.selected {
            background: #2196F3;
        }

        #marketplace {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
        }

        .market-category {
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 10px;
        }

        .market-category:last-child {
            border-bottom: none;
        }

        .market-category h3 {
            margin: 0 0 8px 0;
            color: #FFD700;
            font-size: 14px;
        }

        .market-btn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .market-btn:hover {
            background: #e68900;
        }

        #objectives {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 250px;
            max-height: 180px;
            overflow-y: auto;
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            color: white;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            min-width: 400px;
            display: none;
            border: 2px solid #4CAF50;
        }

        #settingsMenu h2 {
            margin-top: 0;
            text-align: center;
            color: #4CAF50;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .control-label {
            font-weight: bold;
            min-width: 120px;
        }

        .key-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            min-width: 60px;
        }

        .key-button:hover {
            background: #1976D2;
        }

        .key-button.recording {
            background: #FF5722;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .preset-btn {
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .preset-btn:hover {
            background: #7B1FA2;
        }

        .menu-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
        }

        .menu-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        .menu-btn:hover {
            background: #45a049;
        }

        .cancel-btn {
            background: #f44336;
        }

        .cancel-btn:hover {
            background: #da190b;
        }

        #settingsButton {
            position: absolute;
            top: 20px;
            right: 280px;
            z-index: 100;
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #settingsButton:hover {
            background: #45a049;
        }
        
        #newGameButton {
            position: absolute;
            top: 20px;
            right: 410px;
            z-index: 100;
            background: #FF5722;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #newGameButton:hover {
            background: #D84315;
        }
        
        #profileButton {
            position: absolute;
            top: 20px;
            right: 540px;
            z-index: 100;
            background: #9C27B0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        #profileButton:hover {
            background: #7B1FA2;
        }
        
        #canvas {
            display: block;
            border: none;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        #dayNightIndicator {
            position: absolute;
            top: 20px;
            right: 530px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }

        /* Weather and Season Panels */
        #weatherPanel {
            position: absolute;
            top: 80px;
            left: 350px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 2px solid #87CEEB;
        }

        #seasonPanel {
            position: absolute;
            top: 80px;
            left: 570px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 180px;
            border: 2px solid #32CD32;
        }

        /* Animals Panel */
        #animalsPanel {
            position: absolute;
            top: 280px;
            left: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 280px;
            max-height: 280px;
            overflow-y: auto;
            border: 2px solid #FFD700;
        }

        /* Daily Quests Panel */
        #questsPanel {
            position: absolute;
            top: 280px;
            right: 20px;
            z-index: 100;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 300px;
            max-height: 280px;
            overflow-y: auto;
            border: 2px solid #FF6347;
        }

        .weather-icon {
            font-size: 32px;
            text-align: center;
            margin-bottom: 10px;
        }

        .season-icon {
            font-size: 32px;
            text-align: center;
            margin-bottom: 10px;
        }

        .animal-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .animal-btn {
            background: #FFD700;
            color: black;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-left: 5px;
        }

        .animal-btn:hover {
            background: #FFA500;
        }

        .animal-btn:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
        }

        .quest-item {
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            border-left: 4px solid #FF6347;
        }

        .quest-completed {
            border-left-color: #4CAF50;
            opacity: 0.7;
        }

        .quest-progress {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
            margin: 5px 0;
            overflow: hidden;
        }

        .quest-progress-bar {
            height: 100%;
            background: #4CAF50;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .weather-effect {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }

        /* Responsive layout for smaller screens */
        @media (max-width: 1200px) {
            #weatherPanel, #seasonPanel {
                display: none; /* Hide on smaller screens to prevent overlap */
            }
            
            #dayNightIndicator {
                right: 20px; /* Move back to original position when panels are hidden */
            }
        }

        @media (max-width: 800px) {
            #animalsPanel, #questsPanel {
                position: relative;
                width: 90%;
                margin: 10px auto;
                top: auto;
                left: auto;
                right: auto;
                max-height: 200px;
            }
            
            #ui, #plantSelector, #objectives, #marketplace, #inventory {
                position: relative;
                width: 90%;
                margin: 10px auto;
                top: auto;
                left: auto;
                right: auto;
            }
        }

        @media (max-height: 600px) {
            #animalsPanel, #questsPanel, #objectives, #marketplace {
                max-height: 150px;
            }
        }

        /* Draggable and Resizable Panel Styles */
        .draggable-panel {
            border: 2px solid transparent;
            transition: border-color 0.2s ease;
            resize: both;
            overflow: auto;
            min-width: 150px;
            min-height: 100px;
        }

        .draggable-panel:hover {
            border-color: rgba(76, 175, 80, 0.5);
        }

        .draggable-panel.dragging {
            border-color: #4CAF50;
            z-index: 1000;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }

        .drag-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 25px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.8), rgba(67, 160, 71, 0.8));
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            border-radius: 8px 8px 0 0;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .draggable-panel:hover .drag-handle {
            opacity: 1;
            visibility: visible;
        }

        .draggable-panel.dragging .drag-handle {
            opacity: 1;
            visibility: visible;
        }

        .drag-handle::before {
            content: "⋮⋮⋮";
            font-size: 16px;
            line-height: 1;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: se-resize;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            background: linear-gradient(135deg, transparent 40%, rgba(76, 175, 80, 0.8) 40%);
            border-radius: 0 0 8px 0;
        }

        .draggable-panel:hover .resize-handle {
            opacity: 1;
            visibility: visible;
        }

        .resize-handle::after {
            content: "";
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-bottom: 8px solid rgba(255, 255, 255, 0.8);
        }

        .ui-mode-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: #673AB7;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .ui-mode-toggle:hover {
            background: #5E35B1;
        }

        .ui-mode-toggle.active {
            background: #4CAF50;
        }

        .panel-content {
            padding-top: 10px;
        }

        /* Tutorial System Styles */
        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .tutorial-content {
            background: rgba(30, 30, 30, 0.95);
            border: 3px solid #4CAF50;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            color: white;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .tutorial-content h2 {
            color: #4CAF50;
            margin-top: 0;
            font-size: 28px;
        }

        .tutorial-step {
            margin: 20px 0;
            padding: 15px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 10px;
            border-left: 4px solid #4CAF50;
        }

        .tutorial-highlight {
            position: absolute;
            border: 3px solid #FFD700;
            border-radius: 10px;
            background: rgba(255, 215, 0, 0.2);
            pointer-events: none;
            z-index: 999;
            display: none;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            animation: tutorialPulse 2s infinite;
        }

        @keyframes tutorialPulse {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.05);
            }
        }

        .tutorial-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 25px;
        }

        .tutorial-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .tutorial-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .tutorial-btn.secondary {
            background: #2196F3;
        }

        .tutorial-btn.secondary:hover {
            background: #1976D2;
        }

        .tutorial-btn.skip {
            background: #f44336;
        }

        .tutorial-btn.skip:hover {
            background: #da190b;
        }

        /* Profile System Styles */
        #profileOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .profile-content {
            background: rgba(30, 30, 30, 0.95);
            border: 3px solid #4CAF50;
            border-radius: 15px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            color: white;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .profile-content h2 {
            color: #4CAF50;
            margin-top: 0;
        }

        .profile-form {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }

        .profile-form input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4CAF50;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 16px;
        }

        .profile-form input[type="text"]:focus {
            outline: none;
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        .character-selection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .character-option {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            font-size: 32px;
            transition: all 0.2s ease;
        }

        .character-option:hover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
        }

        .character-option.selected {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
        }

        /* Adjust existing panels to work with draggable system */
        .draggable-panel .drag-handle + * {
            margin-top: 25px;
        }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 160px;
            background: rgba(0, 0, 0, 0.1);
            pointer-events: none;
            z-index: 200;
            display: none;
        }

        .mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            pointer-events: all;
            touch-action: none;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: all 0.1s ease;
        }

        .mobile-joystick:active,
        .mobile-joystick.active {
            background: rgba(0, 0, 0, 0.4);
            border-color: rgba(76, 175, 80, 0.6);
            transform: scale(1.05);
        }

        .mobile-joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            border: 2px solid rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .mobile-joystick.active .mobile-joystick-handle {
            background: rgba(76, 175, 80, 0.9);
            border-color: rgba(76, 175, 80, 0.8);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
        }

        .mobile-action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: all;
            z-index: 201;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(76, 175, 80, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            transform: scale(0.95);
            background: rgba(76, 175, 80, 1);
        }

        .mobile-btn.secondary {
            background: rgba(33, 150, 243, 0.9);
        }

        .mobile-btn.secondary:active {
            background: rgba(33, 150, 243, 1);
        }

        .mobile-camera-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 10px;
            pointer-events: all;
            z-index: 201;
        }

        .mobile-camera-btn {
            width: 50px;
            height: 50px;
            background: rgba(156, 39, 176, 0.9);
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }

        .mobile-camera-btn:active {
            transform: scale(0.95);
            background: rgba(156, 39, 176, 1);
        }

        /* Mobile responsive improvements */
        @media (max-width: 768px) {
            #mobileControls {
                display: block;
            }

            /* Hide some less critical panels on mobile to reduce clutter */
            #weatherPanel, #seasonPanel {
                display: none !important;
            }

            /* Adjust UI panels for mobile */
            #ui, #plantSelector, #inventory, #marketplace, #objectives, #animalsPanel, #questsPanel {
                position: fixed !important;
                max-width: calc(100vw - 40px);
                max-height: 40vh;
                font-size: 14px;
                overflow-y: auto;
            }

            /* Make buttons larger for touch */
            .plant-btn, .market-btn, .animal-btn {
                padding: 12px 16px;
                font-size: 14px;
                margin: 4px 2px;
                min-height: 44px;
                touch-action: manipulation;
            }

            /* Adjust top buttons for mobile */
            #settingsButton, #newGameButton, #uiModeToggle {
                position: fixed;
                top: 10px;
                font-size: 12px;
                padding: 8px 12px;
                z-index: 150;
            }

            #settingsButton {
                right: 10px;
            }

            #newGameButton {
                right: 80px;
            }

            #uiModeToggle {
                right: 150px;
            }

            /* Adjust day/night indicator */
            #dayNightIndicator {
                position: fixed;
                top: 10px;
                left: 10px;
                font-size: 14px;
                z-index: 150;
            }

            /* Touch-friendly scrollbars */
            .draggable-panel {
                scrollbar-width: thick;
            }

            .draggable-panel::-webkit-scrollbar {
                width: 12px;
            }

            .draggable-panel::-webkit-scrollbar-track {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 6px;
            }

            .draggable-panel::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 6px;
            }

            .draggable-panel::-webkit-scrollbar-thumb:active {
                background: rgba(255, 255, 255, 0.5);
            }
        }

        @media (max-height: 600px) {
            #mobileControls {
                height: 120px;
            }

            .mobile-joystick {
                width: 100px;
                height: 100px;
            }

            .mobile-joystick-handle {
                width: 35px;
                height: 35px;
            }

            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            /* Further reduce panel heights on very short screens */
            #ui, #plantSelector, #inventory, #marketplace, #objectives, #animalsPanel, #questsPanel {
                max-height: 30vh;
            }
        }

        /* Touch feedback animations */
        @keyframes touchFeedback {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: rgba(76, 175, 80, 1); }
            100% { transform: scale(1); }
        }

        .mobile-btn.touched {
            animation: touchFeedback 0.2s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="loading" id="loading">Loading Pixel-Harvest...</div>
        <div id="ui" style="display: none;">
            <div id="playerInfo" style="margin-bottom: 10px; color: #FFD700; font-weight: bold;">Player: Guest</div>
            <div id="score">Score: 0</div>
            <div id="instructions">
                🌱 Move with WASD or arrow keys<br>
                ⚡ SPACE to plant/harvest at closest plot<br>
                💧 E to water plants<br>
                📹 C to toggle camera mode<br>
                🌿 Plants grow automatically (3 stages)<br>
                🔒 Unlock plots by getting close and pressing SPACE<br>
                🌙 Watch the day/night cycle!<br>
                🖱️ Drag to rotate camera view<br>
                🔍 Scroll wheel to zoom in/out
            </div>
        </div>
        <div id="plantSelector" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">🌱 Plant Types:</div>
            <button class="plant-btn selected" data-plant="carrot">🥕 Carrot (Fast)</button><br>
            <button class="plant-btn" data-plant="tomato">🍅 Tomato (Normal)</button><br>
            <button class="plant-btn" data-plant="rare">✨ Rare Plant (Slow)</button><br>
            <button class="plant-btn" data-plant="potato">🥔 Potato (Medium)</button><br>
            <button class="plant-btn" data-plant="cabbage">🥬 Cabbage (Medium)</button><br>
            <button class="plant-btn" data-plant="corn">🌽 Corn (Slow)</button><br>
            <button class="plant-btn" data-plant="watermelon">🍉 Watermelon (Slow)</button><br>
            <button class="plant-btn" data-plant="pumpkin">🎃 Pumpkin (Slow)</button><br>
            <button class="plant-btn" data-plant="apple">🍎 Apple Tree (Very Slow)</button>
            <div style="font-size: 12px; margin-top: 10px; opacity: 0.8;">
                💰 Coins: <span id="coins">10</span>
            </div>
        </div>
        <div id="inventory" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">📦 Inventory:</div>
            <div id="carrotCount">🥕 Carrots: 0</div>
            <div id="tomatoCount">🍅 Tomatoes: 0</div>
            <div id="rareCount">✨ Rare Plants: 0</div>
            <div id="potatoCount">🥔 Potatoes: 0</div>
            <div id="cabbageCount">🥬 Cabbages: 0</div>
            <div id="cornCount">🌽 Corn: 0</div>
            <div id="watermelonCount">🍉 Watermelons: 0</div>
            <div id="pumpkinCount">🎃 Pumpkins: 0</div>
            <div id="appleCount">🍎 Apples: 0</div>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <div style="font-weight: bold; margin-bottom: 5px;">🔧 Equipment:</div>
            <div id="sprinklerCount">💧 Auto Sprinklers: 0</div>
            <div id="fertilizerCount">🌿 Fertilizer: 0</div>
            <div id="greenhouseCount">🏠 Greenhouses: 0</div>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <div style="font-weight: bold; margin-bottom: 5px;">🐄 Animal Products:</div>
            <div id="eggInventory">🥚 Eggs: 0</div>
            <div id="milkInventory">🥛 Milk: 0</div>
            <div id="truffleInventory">🍄 Truffles: 0</div>
        </div>
        <div id="marketplace" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">🏪 Marketplace:</div>
            
            <div class="market-category">
                <h3>💰 Sell Produce</h3>
                <button class="market-btn" onclick="sellAll('carrot')" id="sellCarrotBtn">Sell Carrots (1💰)</button><br>
                <button class="market-btn" onclick="sellAll('tomato')" id="sellTomatoBtn">Sell Tomatoes (3💰)</button><br>
                <button class="market-btn" onclick="sellAll('rare')" id="sellRareBtn">Sell Rare (10💰)</button><br>
                <button class="market-btn" onclick="sellAll('potato')" id="sellPotatoBtn">Sell Potatoes (2💰)</button><br>
                <button class="market-btn" onclick="sellAll('cabbage')" id="sellCabbageBtn">Sell Cabbages (4💰)</button><br>
                <button class="market-btn" onclick="sellAll('corn')" id="sellCornBtn">Sell Corn (5💰)</button><br>
                <button class="market-btn" onclick="sellAll('watermelon')" id="sellWatermelonBtn">Sell Watermelons (8💰)</button><br>
                <button class="market-btn" onclick="sellAll('pumpkin')" id="sellPumpkinBtn">Sell Pumpkins (6💰)</button><br>
                <button class="market-btn" onclick="sellAll('apple')" id="sellAppleBtn">Sell Apples (12💰)</button>
            </div>
            
            <div class="market-category">
                <h3>🐄 Sell Animal Products</h3>
                <button class="market-btn" onclick="sellAnimalProduct('eggs')" id="sellEggsBtn">Sell Eggs (2💰 each)</button><br>
                <button class="market-btn" onclick="sellAnimalProduct('milk')" id="sellMilkBtn">Sell Milk (5💰 each)</button><br>
                <button class="market-btn" onclick="sellAnimalProduct('truffles')" id="sellTrufflesBtn">Sell Truffles (8💰 each)</button>
            </div>
            
            <div class="market-category">
                <h3>🌱 Seeds</h3>
                <button class="market-btn" onclick="buySeeds('carrot', 1)" id="buyCarrotSeedsBtn">Buy Carrot Seeds (1💰)</button><br>
                <button class="market-btn" onclick="buySeeds('tomato', 2)" id="buyTomatoSeedsBtn">Buy Tomato Seeds (2💰)</button><br>
                <button class="market-btn" onclick="buySeeds('rare', 5)" id="buyRareSeedsBtn">Buy Rare Seeds (5💰)</button><br>
                <button class="market-btn" onclick="buySeeds('potato', 2)" id="buyPotatoSeedsBtn">Buy Potato Seeds (2💰)</button><br>
                <button class="market-btn" onclick="buySeeds('cabbage', 3)" id="buyCabbageSeedsBtn">Buy Cabbage Seeds (3💰)</button><br>
                <button class="market-btn" onclick="buySeeds('corn', 3)" id="buyCornSeedsBtn">Buy Corn Seeds (3💰)</button><br>
                <button class="market-btn" onclick="buySeeds('watermelon', 4)" id="buyWatermelonSeedsBtn">Buy Watermelon Seeds (4💰)</button><br>
                <button class="market-btn" onclick="buySeeds('pumpkin', 4)" id="buyPumpkinSeedsBtn">Buy Pumpkin Seeds (4💰)</button><br>
                <button class="market-btn" onclick="buySeeds('apple', 6)" id="buyAppleSeedsBtn">Buy Apple Seeds (6💰)</button>
            </div>
            
            <div class="market-category">
                <h3>🔧 Equipment</h3>
                <button class="market-btn" onclick="buyItem('sprinkler', 150)" id="sprinklerBtn">Auto Sprinkler (150💰)</button><br>
                <button class="market-btn" onclick="buyItem('fertilizer', 50)" id="fertilizerBtn">Fertilizer Pack (50💰)</button><br>
                <button class="market-btn" onclick="buyItem('greenhouse', 300)" id="greenhouseBtn">Mini Greenhouse (300💰)</button>
            </div>
        </div>
        <div id="objectives" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px;">🎯 Objectives:</div>
            <div id="objective1" class="objective">🥕 Harvest 5 carrots (0/5)</div>
            <div id="objective2" class="objective">🌙 Survive 2 day/night cycles (0/2)</div>
            <div id="objective3" class="objective">💰 Earn 20 coins (0/20)</div>
            <div id="objective4" class="objective" style="display: none;">🌾 Harvest 25 total plants (0/25)</div>
            <div id="objective5" class="objective" style="display: none;">🔧 Buy any equipment (0/1)</div>
            <div id="objective6" class="objective" style="display: none;">💰 Earn 500 coins (0/500)</div>
            <div id="objective7" class="objective" style="display: none;">🌱 Plant 50 seeds (0/50)</div>
            <div id="objective8" class="objective" style="display: none;">🏆 Unlock all plots (0/25)</div>
        </div>
        <div id="dayNightIndicator" style="display: none;">
            <div id="timeDisplay">Day</div>
            <div id="cameraMode" style="margin-top: 10px; font-size: 14px;">Camera: Character Follow</div>
            <div id="characterStatus" style="margin-top: 10px; font-size: 12px; color: #FFD700;">
                Character: Idle
            </div>
        </div>
        
        <!-- Weather Panel -->
        <div id="weatherPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">🌤️ Weather</div>
            <div class="weather-icon" id="weatherIcon">☀️</div>
            <div id="weatherName" style="text-align: center; margin-bottom: 5px;">Sunny</div>
            <div id="weatherEffect" style="font-size: 12px; text-align: center; opacity: 0.8;">Plants grow normally</div>
        </div>

        <!-- Season Panel -->
        <div id="seasonPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">🍂 Season</div>
            <div class="season-icon" id="seasonIcon">🌸</div>
            <div id="seasonName" style="text-align: center; margin-bottom: 5px;">Spring</div>
            <div id="seasonDay" style="font-size: 12px; text-align: center; opacity: 0.8;">Day 1 of 20</div>
        </div>

        <!-- Animals Panel -->
        <div id="animalsPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">🐄 Farm Animals</div>
            
            <div class="animal-item">
                <div>
                    <div>🐔 Chickens: <span id="chickenCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="eggCount">0</span> 🥚</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('chicken', 30)" id="buyChickenBtn">Buy (30💰)</button>
                    <button class="animal-btn" onclick="collectResource('eggs')" id="collectEggsBtn">Collect</button>
                </div>
            </div>

            <div class="animal-item">
                <div>
                    <div>🐄 Cows: <span id="cowCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="milkCount">0</span> 🥛</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('cow', 100)" id="buyCowBtn">Buy (100💰)</button>
                    <button class="animal-btn" onclick="collectResource('milk')" id="collectMilkBtn">Collect</button>
                </div>
            </div>

            <div class="animal-item">
                <div>
                    <div>🐷 Pigs: <span id="pigCount">0</span></div>
                    <div style="font-size: 11px; opacity: 0.8;">Produce: <span id="truffleCount">0</span> 🍄</div>
                </div>
                <div>
                    <button class="animal-btn" onclick="buyAnimal('pig', 150)" id="buyPigBtn">Buy (150💰)</button>
                    <button class="animal-btn" onclick="collectResource('truffles')" id="collectTrufflesBtn">Collect</button>
                </div>
            </div>
        </div>

        <!-- Daily Quests Panel -->
        <div id="questsPanel" style="display: none;">
            <div style="font-weight: bold; margin-bottom: 10px; text-align: center;">📋 Daily Quests</div>
            <div id="questList">
                <!-- Quests will be populated dynamically -->
            </div>
            <div style="margin-top: 15px; text-align: center; font-size: 12px; opacity: 0.8;">
                <button class="market-btn" onclick="resetDailyQuests()" style="font-size: 11px; padding: 5px 10px;">🔄 New Quests (50💰)</button>
            </div>
        </div>
        <button id="settingsButton" style="display: none;">⚙️ Controls</button>
        <button id="newGameButton" style="display: none;">🆕 New Game</button>
        <button id="profileButton" style="display: none;">👤 Profile</button>
        <button id="uiModeToggle" class="ui-mode-toggle" style="display: none;">🔧 UI Mode</button>
        
        <!-- Tutorial System -->
        <div id="tutorialOverlay">
            <div class="tutorial-content">
                <h2 id="tutorialTitle">🌱 Welcome to Pixel-Harvest!</h2>
                <div id="tutorialText">
                    <div class="tutorial-step">
                        Welcome to your new farm! This tutorial will guide you through all the game features.
                        Let's start by learning the basics of farming.
                    </div>
                </div>
                <div class="tutorial-buttons">
                    <button class="tutorial-btn" id="tutorialNext">Start Tutorial</button>
                    <button class="tutorial-btn skip" id="tutorialSkip">Skip Tutorial</button>
                </div>
            </div>
        </div>
        
        <!-- Tutorial Highlight -->
        <div id="tutorialHighlight" class="tutorial-highlight"></div>
        
        <!-- Profile System -->
        <div id="profileOverlay">
            <div class="profile-content">
                <h2>👤 Create Your Profile</h2>
                <div class="profile-form">
                    <input type="text" id="usernameInput" placeholder="Enter your username..." maxlength="20">
                    
                    <div>
                        <label style="color: #4CAF50; font-weight: bold; margin-bottom: 10px; display: block;">Choose your character:</label>
                        <div class="character-selection">
                            <div class="character-option" data-character="farmer">👨‍🌾</div>
                            <div class="character-option" data-character="girl">👩‍🌾</div>
                            <div class="character-option" data-character="boy">🧑‍🌾</div>
                            <div class="character-option" data-character="old">🧓</div>
                        </div>
                    </div>
                    
                    <div>
                        <label style="color: #4CAF50; font-weight: bold; margin-bottom: 10px; display: block;">Character color:</label>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <div class="character-option" data-color="#4169E1" style="background: #4169E1; font-size: 16px;">💙</div>
                            <div class="character-option" data-color="#32CD32" style="background: #32CD32; font-size: 16px;">💚</div>
                            <div class="character-option" data-color="#FF6347" style="background: #FF6347; font-size: 16px;">❤️</div>
                            <div class="character-option" data-color="#FFD700" style="background: #FFD700; font-size: 16px;">💛</div>
                            <div class="character-option" data-color="#9370DB" style="background: #9370DB; font-size: 16px;">💜</div>
                        </div>
                    </div>
                </div>
                
                <div class="tutorial-buttons">
                    <button class="tutorial-btn" id="createProfileBtn">Create Profile</button>
                    <button class="tutorial-btn secondary" id="loadProfileBtn">Load Existing</button>
                </div>
            </div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="mobileControls">
            <!-- Virtual Joystick for Movement -->
            <div class="mobile-joystick" id="mobileJoystick">
                <div class="mobile-joystick-handle" id="joystickHandle"></div>
            </div>
            
            <!-- Action Buttons -->
            <div class="mobile-action-buttons">
                <button class="mobile-btn" id="mobileActionBtn" title="Plant/Harvest">🌱</button>
                <button class="mobile-btn secondary" id="mobileWaterBtn" title="Water">💧</button>
            </div>
            
            <!-- Camera Controls -->
            <div class="mobile-camera-controls">
                <button class="mobile-camera-btn" id="mobileCameraBtn" title="Toggle Camera">📹</button>
                <button class="mobile-camera-btn" id="mobileZoomInBtn" title="Zoom In">🔍</button>
                <button class="mobile-camera-btn" id="mobileZoomOutBtn" title="Zoom Out">🔍</button>
            </div>
        </div>
        
        <!-- Settings Menu -->
        <div id="settingsMenu">
            <h2>⚙️ Control Settings</h2>
            
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setControlPreset('azerty')">AZERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('qwerty')">QWERTY Preset</button>
                <button class="preset-btn" onclick="setControlPreset('arrows')">Arrow Keys</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Forward:</span>
                <button class="key-button" id="key-forward" onclick="recordKey('forward')">Z</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Left:</span>
                <button class="key-button" id="key-left" onclick="recordKey('left')">Q</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Backward:</span>
                <button class="key-button" id="key-backward" onclick="recordKey('backward')">S</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Move Right:</span>
                <button class="key-button" id="key-right" onclick="recordKey('right')">D</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Plant/Harvest:</span>
                <button class="key-button" id="key-action" onclick="recordKey('action')">SPACE</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Water Plants:</span>
                <button class="key-button" id="key-water" onclick="recordKey('water')">E</button>
            </div>
            
            <div class="control-row">
                <span class="control-label">Toggle Camera:</span>
                <button class="key-button" id="key-camera" onclick="recordKey('camera')">C</button>
            </div>
            
            <div class="menu-buttons">
                <button class="menu-btn" onclick="saveControls()">Save</button>
                <button class="menu-btn cancel-btn" onclick="cancelControls()">Cancel</button>
                <button class="menu-btn" onclick="resetControls()">Reset to Default</button>
            </div>
        </div>
        
        <canvas id="canvas"></canvas>
    </div>

    <script>
        // Game state
        let canvas, ctx;
        let score = 0;
        let coins = 50; // Balanced starting amount
        let dayNightCycle = 0;
        let dayNightCycleCount = 0;
        
        // Tutorial System
        let tutorialActive = false;
        let tutorialStep = 0;
        let tutorialSteps = [
            {
                title: "🌱 Welcome to Pixel-Harvest!",
                text: "Welcome to your new farm! This tutorial will guide you through all the game features. Let's start by learning the basics of farming.",
                target: null,
                action: "continue"
            },
            {
                title: "📊 Game Information",
                text: "This panel shows your current score and basic controls. Your score increases as you harvest crops and complete objectives.",
                target: "#ui",
                action: "highlight"
            },
            {
                title: "🌱 Plant Selection",
                text: "Here you can choose which type of plant to grow. Different plants have different growth times and values. Try clicking on a plant type!",
                target: "#plantSelector",
                action: "wait_interaction",
                element: ".plant-btn"
            },
            {
                title: "📦 Your Inventory",
                text: "This shows all the items you've collected. Harvested crops, equipment, and animal products are stored here.",
                target: "#inventory",
                action: "highlight"
            },
            {
                title: "🏪 Marketplace",
                text: "Use the marketplace to sell your crops for coins, buy new seeds, and purchase equipment to improve your farm.",
                target: "#marketplace",
                action: "highlight"
            },
            {
                title: "🎯 Objectives",
                text: "Complete these objectives to progress and earn rewards. They help guide your farming activities.",
                target: "#objectives",
                action: "highlight"
            },
            {
                title: "🌤️ Weather & Seasons",
                text: "Weather affects plant growth and water consumption. Seasons change which crops grow best. Plan accordingly!",
                target: "#weatherPanel",
                action: "highlight"
            },
            {
                title: "🐄 Farm Animals",
                text: "Buy animals to produce eggs, milk, and truffles. These provide passive income and additional objectives.",
                target: "#animalsPanel",
                action: "highlight"
            },
            {
                title: "📋 Daily Quests",
                text: "Complete daily quests for extra rewards. They reset regularly and provide bonus coins.",
                target: "#questsPanel",
                action: "highlight"
            },
            {
                title: "🎮 Movement Controls",
                text: "Use ZQSD or arrow keys to move your character around the farm. Get close to plots to interact with them.",
                target: null,
                action: "movement_demo"
            },
            {
                title: "🌱 Planting & Harvesting",
                text: "Press SPACE when near a plot to plant seeds or harvest mature crops. Press E to water your plants. Try planting your first crop!",
                target: null,
                action: "wait_plant"
            },
            {
                title: "🎉 Tutorial Complete!",
                text: "Great job! You now know the basics of Pixel-Harvest. Keep farming, complete objectives, and build the ultimate farm!",
                target: null,
                action: "complete"
            }
        ];

        // Profile System
        let currentProfile = {
            username: "",
            character: "farmer",
            characterColor: "#4169E1",
            highScore: 0,
            totalCoins: 0,
            created: Date.now()
        };
        let profiles = [];
        
        // Supabase Integration (will be implemented)
        let supabaseUrl = 'https://your-project.supabase.co';
        let supabaseKey = 'your-anon-key';
        let supabaseClient = null;
        
        // Weather System
        let currentWeather = {
            type: 'sunny',
            name: 'Sunny',
            icon: '☀️',
            effect: 'Plants grow normally',
            growthMultiplier: 1.0,
            waterDecayMultiplier: 1.0,
            duration: 0,
            maxDuration: 30000 // 30 seconds per weather
        };
        
        const WEATHER_TYPES = {
            sunny: {
                name: 'Sunny',
                icon: '☀️',
                effect: 'Plants grow faster',
                growthMultiplier: 1.2,
                waterDecayMultiplier: 1.2,
                bgColor: { r: 135, g: 206, b: 235 },
                probability: 0.3
            },
            cloudy: {
                name: 'Cloudy',
                icon: '☁️',
                effect: 'Normal growth, less water loss',
                growthMultiplier: 1.0,
                waterDecayMultiplier: 0.7,
                bgColor: { r: 105, g: 105, b: 105 },
                probability: 0.25
            },
            rainy: {
                name: 'Rainy',
                icon: '🌧️',
                effect: 'Slower growth, plants auto-watered',
                growthMultiplier: 0.8,
                waterDecayMultiplier: -0.5, // Negative means plants gain water
                bgColor: { r: 70, g: 130, b: 180 },
                probability: 0.25
            },
            stormy: {
                name: 'Stormy',
                icon: '⛈️',
                effect: 'Much slower growth, auto-watered',
                growthMultiplier: 0.5,
                waterDecayMultiplier: -0.8,
                bgColor: { r: 47, g: 79, b: 79 },
                probability: 0.2
            }
        };
        
        // Season System  
        let currentSeason = {
            type: 'spring',
            name: 'Spring',
            icon: '🌸',
            day: 1,
            maxDays: 20,
            availableCrops: ['carrot', 'tomato'],
            growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
        };
        
        const SEASON_TYPES = {
            spring: {
                name: 'Spring',
                icon: '🌸',
                availableCrops: ['carrot', 'tomato', 'potato'],
                growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8, potato: 1.1, cabbage: 0.9, corn: 0.8, watermelon: 0.7, pumpkin: 0.8, apple: 0.9 },
                bgTint: { r: 1.1, g: 1.0, b: 1.0 }
            },
            summer: {
                name: 'Summer',
                icon: '☀️',
                availableCrops: ['tomato', 'corn', 'watermelon', 'rare'],
                growthBonus: { carrot: 0.8, tomato: 1.3, rare: 1.1, potato: 0.7, cabbage: 0.6, corn: 1.4, watermelon: 1.3, pumpkin: 0.8, apple: 1.0 },
                bgTint: { r: 1.2, g: 1.1, b: 0.9 }
            },
            autumn: {
                name: 'Autumn',
                icon: '🍂',
                availableCrops: ['carrot', 'potato', 'pumpkin', 'apple', 'rare'],
                growthBonus: { carrot: 1.1, tomato: 0.8, rare: 1.2, potato: 1.0, cabbage: 1.1, corn: 0.6, watermelon: 0.5, pumpkin: 1.3, apple: 1.4 },
                bgTint: { r: 1.1, g: 0.9, b: 0.8 }
            },
            winter: {
                name: 'Winter',
                icon: '❄️',
                availableCrops: ['potato', 'cabbage', 'rare'],
                growthBonus: { carrot: 0.6, tomato: 0.6, rare: 1.0, potato: 1.2, cabbage: 1.3, corn: 0.4, watermelon: 0.3, pumpkin: 0.7, apple: 0.8 },
                bgTint: { r: 0.9, g: 0.9, b: 1.1 }
            }
        };
        
        // Animals System
        let animals = {
            chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 }, // 8 seconds
            cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 }, // 15 seconds  
            pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 } // 20 seconds
        };
        
        const ANIMAL_COSTS = {
            chicken: 30,
            cow: 100,
            pig: 150
        };
        
        const ANIMAL_PRODUCTS = {
            chicken: { name: 'eggs', emoji: '🥚', value: 2 },
            cow: { name: 'milk', emoji: '🥛', value: 5 },
            pig: { name: 'truffles', emoji: '🍄', value: 8 }
        };
        
        // Daily Quests System
        let dailyQuests = [];
        let questProgress = {};
        let lastQuestReset = Date.now();
        
        const QUEST_TYPES = [
            {
                id: 'harvest_plants',
                name: 'Harvest {target} plants',
                description: 'Harvest any type of plant',
                target: [5, 10, 15],
                reward: [15, 25, 40],
                type: 'harvest'
            },
            {
                id: 'plant_seeds',
                name: 'Plant {target} seeds',
                description: 'Plant any type of seed',
                target: [3, 8, 12],
                reward: [10, 20, 35],
                type: 'plant'
            },
            {
                id: 'earn_coins',
                name: 'Earn {target} coins',
                description: 'Earn coins by selling items',
                target: [25, 50, 100],
                reward: [20, 35, 60],
                type: 'coins'
            },
            {
                id: 'collect_animal_products',
                name: 'Collect {target} animal products',
                description: 'Collect eggs, milk, or truffles',
                target: [2, 5, 8],
                reward: [15, 30, 50],
                type: 'collect'
            },
            {
                id: 'water_plants',
                name: 'Water {target} plants',
                description: 'Water growing plants',
                target: [5, 10, 15],
                reward: [10, 18, 30],
                type: 'water'
            }
        ];
        
        // Audio system
        let audioContext;
        let sounds = {
            plant: null,
            harvest: null,
            water: null,
            unlock: null,
            wind: null,
            birds: null
        };
        let windGain, windOscillator;
        let lastBirdSound = 0;
        let cameraAngleX = 0;
        let cameraAngleY = 0;
        let cameraDistance = 10;
        let mouseDown = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let hoveredPlot = null;
        let selectedPlantType = 'carrot';
        let selectedEquipment = null;
        let cameraFollowCharacter = true;
        let freeCameraMode = false;
        
        // Camera follow variables for smooth following
        let cameraFollowX = 0;
        let cameraFollowZ = 0;
        const cameraFollowLerp = 0.1;
        
        // Water decay rate (per second)
        const waterDecayRate = 0.02;
        
        // Auto-save interval (10 seconds)
        let autoSaveInterval;
        
        // Character system
        let character = {
            x: 0,
            y: 0,
            z: 0,
            size: 1,
            color: '#4169E1', // Royal blue
            targetX: 0,
            targetZ: 0,
            moving: false,
            speed: 0.05, // Movement speed
            animationFrame: 0,
            currentAction: 'idle', // idle, walking, planting, watering
            actionTimer: 0,
            direction: 0, // rotation in radians
            targetDirection: 0
        };
        
        // Keyboard state
        let keys = {};
        
        // Control mappings (AZERTY by default)
        let controls = {
            forward: 'KeyZ',
            left: 'KeyQ', 
            backward: 'KeyS',
            right: 'KeyD',
            action: 'Space',
            water: 'KeyE',
            camera: 'KeyC'
        };
        
        // Backup controls for cancelling changes
        let backupControls = {};
        
        // Key recording state
        let recordingKey = null;
        
        // Game objects
        let plots = [];
        let inventory = {
            carrot: 0,
            tomato: 0,
            rare: 0,
            potato: 0,
            cabbage: 0,
            corn: 0,
            watermelon: 0,
            pumpkin: 0,
            apple: 0
        };
        let seedInventory = {
            carrot: 5,
            tomato: 2,
            rare: 1,
            potato: 3,
            cabbage: 2,
            corn: 1,
            watermelon: 1,
            pumpkin: 2,
            apple: 1
        };
        let equipment = {
            sprinkler: 0,
            fertilizer: 0,
            greenhouse: 0
        };
        let animalInventory = {
            eggs: 0,
            milk: 0,
            truffles: 0
        };
        let activeSprinklers = []; // Array of sprinkler positions
        let objectives = {
            carrotsHarvested: 0,
            dayNightCycles: 0,
            coinsEarned: 0,
            plantsHarvested: 0,
            equipmentBought: 0,
            seedsPlanted: 0,
            plotsUnlocked: 9 // Start with 9 plots unlocked (3x3 center)
        };
        
        // Plant types configuration
        const PLANT_TYPES = {
            carrot: {
                name: 'Carrot',
                emoji: '🥕',
                growthTime: 2000, // 2 seconds per stage
                value: 1,
                seedCost: 1,
                color: '#FFA500',
                waterNeed: 0.3,
                dayPreference: true
            },
            tomato: {
                name: 'Tomato',
                emoji: '🍅',
                growthTime: 4000, // 4 seconds per stage
                value: 3,
                seedCost: 2,
                color: '#FF6347',
                waterNeed: 0.5,
                dayPreference: false
            },
            rare: {
                name: 'Rare Plant',
                emoji: '✨',
                growthTime: 8000, // 8 seconds per stage
                value: 10,
                seedCost: 5,
                color: '#9370DB',
                waterNeed: 0.8,
                dayPreference: false
            },
            // New winter plants
            potato: {
                name: 'Potato',
                emoji: '🥔',
                growthTime: 3000, // 3 seconds per stage
                value: 2,
                seedCost: 2,
                color: '#8B4513',
                waterNeed: 0.4,
                dayPreference: false
            },
            cabbage: {
                name: 'Cabbage',
                emoji: '🥬',
                growthTime: 5000, // 5 seconds per stage
                value: 4,
                seedCost: 3,
                color: '#228B22',
                waterNeed: 0.6,
                dayPreference: false
            },
            // New summer plants
            corn: {
                name: 'Corn',
                emoji: '🌽',
                growthTime: 6000, // 6 seconds per stage
                value: 5,
                seedCost: 3,
                color: '#FFD700',
                waterNeed: 0.7,
                dayPreference: true
            },
            watermelon: {
                name: 'Watermelon',
                emoji: '🍉',
                growthTime: 7000, // 7 seconds per stage
                value: 8,
                seedCost: 4,
                color: '#FF69B4',
                waterNeed: 0.9,
                dayPreference: true
            },
            // New autumn plants
            pumpkin: {
                name: 'Pumpkin',
                emoji: '🎃',
                growthTime: 6500, // 6.5 seconds per stage
                value: 6,
                seedCost: 4,
                color: '#FF7F00',
                waterNeed: 0.5,
                dayPreference: false
            },
            apple: {
                name: 'Apple Tree',
                emoji: '🍎',
                growthTime: 9000, // 9 seconds per stage
                value: 12,
                seedCost: 6,
                color: '#FF0000',
                waterNeed: 0.4,
                dayPreference: false
            }
        };
        
        // Colors
        const colors = {
            ground: '#228B22',
            plot: '#8B4513',
            seed: '#654321',
            plantStage1: '#90EE90',
            plantStage2: '#32CD32',
            plantStage3: '#006400',
            plotHover: '#CD853F',
            plantHover: '#228B22',
            water: '#87CEEB',
            dryPlot: '#8B7355'
        };
        
        // Plant growth stages
        const PLANT_STAGES = {
            EMPTY: 0,
            PLANTED: 1,
            GROWING1: 2,
            GROWING2: 3,
            MATURE: 4,
            WITHERING: 5
        };
        
        // 3D projection and rendering functions
        function project3D(x, y, z) {
            // Simple perspective projection with zoom support
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            
            // Apply camera offset when following character
            let offsetX = 0;
            let offsetZ = 0;
            if (cameraFollowCharacter) {
                offsetX = -cameraFollowX;
                offsetZ = -cameraFollowZ;
            }
            
            // Apply camera rotation
            const cosX = Math.cos(cameraAngleX);
            const sinX = Math.sin(cameraAngleX);
            const cosY = Math.cos(cameraAngleY);
            const sinY = Math.sin(cameraAngleY);
            
            // Apply offset for character following
            const x1_offset = x + offsetX;
            const z1_offset = z + offsetZ;
            
            // Rotate around Y axis then X axis
            const x1 = x1_offset * cosY - z1_offset * sinY;
            const z1 = x1_offset * sinY + z1_offset * cosY;
            const y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX + cameraDistance; // Use cameraDistance for zoom
            
            if (z2 <= 0) z2 = 0.1; // Prevent division by zero
            
            const scale = canvas.width / z2;
            return {
                x: cx + x1 * scale,
                y: cy - y1 * scale,
                z: z2,
                scale: scale
            };
        }
        
        function drawCube(x, y, z, size, color, outline = true) {
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            const projected = vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
            
            // Define faces (front, back, top, bottom, left, right)
            const faces = [
                [0, 1, 2, 3], // front
                [5, 4, 7, 6], // back
                [4, 5, 1, 0], // bottom
                [3, 2, 6, 7], // top
                [4, 0, 3, 7], // left
                [1, 5, 6, 2]  // right
            ];
            
            // Sort faces by average z-depth for proper rendering
            const faceDepths = faces.map(face => {
                const avgZ = face.reduce((sum, i) => sum + projected[i].z, 0) / face.length;
                return { face, depth: avgZ };
            });
            faceDepths.sort((a, b) => b.depth - a.depth);
            
            // Draw faces
            faceDepths.forEach(({ face }, faceIndex) => {
                ctx.beginPath();
                ctx.moveTo(projected[face[0]].x, projected[face[0]].y);
                for (let i = 1; i < face.length; i++) {
                    ctx.lineTo(projected[face[i]].x, projected[face[i]].y);
                }
                ctx.closePath();
                
                // Apply lighting based on face orientation and day/night cycle
                const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
                const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
                const faceLight = 0.7 + faceIndex * 0.05; // Different faces have different lighting
                const finalLight = lightIntensity * faceLight;
                
                ctx.fillStyle = adjustColorBrightness(color, finalLight);
                ctx.fill();
                
                if (outline) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            });
            
            return projected; // Return projected vertices for click detection
        }
        
        function getProjectedCube(x, y, z, size) {
            // Calculate cube projection without drawing - for click detection only
            const s = size / 2;
            
            // Define cube vertices
            const vertices = [
                [-s, -s, -s], [s, -s, -s], [s, s, -s], [-s, s, -s], // front face
                [-s, -s, s], [s, -s, s], [s, s, s], [-s, s, s]       // back face
            ];
            
            // Project vertices
            return vertices.map(v => project3D(x + v[0], y + v[1], z + v[2]));
        }
        
        function drawPlane(x, y, z, width, height, color) {
            // Draw ground plane
            const hw = width / 2;
            const hh = height / 2;
            
            const corners = [
                project3D(x - hw, y, z - hh),
                project3D(x + hw, y, z - hh),
                project3D(x + hw, y, z + hh),
                project3D(x - hw, y, z + hh)
            ];
            
            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(corner => ctx.lineTo(corner.x, corner.y));
            ctx.closePath();
            
            // Apply day/night lighting
            const dayNightProgress = (Math.sin(dayNightCycle) + 1) / 2; // 0 to 1 (night to day)
            const lightIntensity = 0.3 + 0.7 * dayNightProgress; // Night: 0.3, Day: 1.0
            ctx.fillStyle = adjustColorBrightness(color, lightIntensity);
            ctx.fill();
            
            // Grid lines
            ctx.strokeStyle = adjustColorBrightness('#000', lightIntensity * 0.3);
            ctx.lineWidth = 1;
            ctx.stroke();
            
            return corners;
        }
        
        function adjustColorBrightness(color, factor) {
            // Convert hex color to RGB and adjust brightness
            const hex = color.replace('#', '');
            const r = Math.min(255, Math.floor(parseInt(hex.substring(0, 2), 16) * factor));
            const g = Math.min(255, Math.floor(parseInt(hex.substring(2, 4), 16) * factor));
            const b = Math.min(255, Math.floor(parseInt(hex.substring(4, 6), 16) * factor));
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function isPointInProjectedQuad(point, quad) {
            // Simple point-in-polygon test for click detection
            let inside = false;
            for (let i = 0, j = quad.length - 1; i < quad.length; j = i++) {
                if (((quad[i].y > point.y) !== (quad[j].y > point.y)) &&
                    (point.x < (quad[j].x - quad[i].x) * (point.y - quad[i].y) / (quad[j].y - quad[i].y) + quad[i].x)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function plotContainsScreenPoint(x, y, plot) {
            // Use the "top" face of the cube for precise click detection
            const projected = getProjectedCube(plot.x, plot.y + 0.1, plot.z, 2);
            
            // Top face vertices are indices [3,2,6,7] of the projected cube
            const topQuad = [
                projected[3], // top-left
                projected[2], // top-right
                projected[6], // bottom-right
                projected[7]  // bottom-left
            ];
            
            return isPointInProjectedQuad({x: x, y: y}, topQuad);
        }
        
        // Save/Load Game System
        function saveGame() {
            const gameState = {
                score: score,
                coins: coins,
                inventory: inventory,
                seedInventory: seedInventory,
                equipment: equipment,
                animalInventory: animalInventory,
                plots: plots.map(plot => ({
                    x: plot.x,
                    y: plot.y,
                    z: plot.z,
                    stage: plot.stage,
                    plantType: plot.plantType,
                    growthTimer: plot.growthTimer,
                    waterLevel: plot.waterLevel,
                    lastWatered: plot.lastWatered,
                    unlocked: plot.unlocked,
                    unlockCost: plot.unlockCost
                })),
                activeSprinklers: activeSprinklers,
                objectives: objectives,
                dayNightCycle: dayNightCycle,
                dayNightCycleCount: dayNightCycleCount,
                cameraFollowX: cameraFollowX,
                cameraFollowZ: cameraFollowZ,
                // New save data
                currentWeather: currentWeather,
                currentSeason: currentSeason,
                animals: animals,
                dailyQuests: dailyQuests,
                questProgress: questProgress,
                lastQuestReset: lastQuestReset
            };
            
            try {
                localStorage.setItem('pixelHarvestSave', JSON.stringify(gameState));
                console.log('Game saved successfully');
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }
        
        function loadGame() {
            try {
                const savedData = localStorage.getItem('pixelHarvestSave');
                if (!savedData) return false;
                
                const gameState = JSON.parse(savedData);
                
                // Restore basic game state
                score = gameState.score || 0;
                coins = gameState.coins || 50;
                inventory = gameState.inventory || { 
                    carrot: 0, tomato: 0, rare: 0, potato: 0, cabbage: 0, 
                    corn: 0, watermelon: 0, pumpkin: 0, apple: 0 
                };
                seedInventory = gameState.seedInventory || { 
                    carrot: 5, tomato: 2, rare: 1, potato: 3, cabbage: 2,
                    corn: 1, watermelon: 1, pumpkin: 2, apple: 1
                };
                equipment = gameState.equipment || { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
                animalInventory = gameState.animalInventory || { eggs: 0, milk: 0, truffles: 0 };
                objectives = gameState.objectives || {
                    carrotsHarvested: 0,
                    dayNightCycles: 0,
                    coinsEarned: 0,
                    plantsHarvested: 0,
                    equipmentBought: 0,
                    seedsPlanted: 0,
                    plotsUnlocked: 9
                };
                dayNightCycle = gameState.dayNightCycle || 0;
                dayNightCycleCount = gameState.dayNightCycleCount || 0;
                cameraFollowX = gameState.cameraFollowX || 0;
                cameraFollowZ = gameState.cameraFollowZ || 0;
                
                // Restore new features with defaults for compatibility
                currentWeather = gameState.currentWeather || {
                    type: 'sunny',
                    name: 'Sunny',
                    icon: '☀️',
                    effect: 'Plants grow normally',
                    growthMultiplier: 1.0,
                    waterDecayMultiplier: 1.0,
                    duration: 0,
                    maxDuration: 30000
                };
                
                currentSeason = gameState.currentSeason || {
                    type: 'spring',
                    name: 'Spring',
                    icon: '🌸',
                    day: 1,
                    maxDays: 20,
                    availableCrops: ['carrot', 'tomato'],
                    growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
                };
                
                animals = gameState.animals || {
                    chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 },
                    cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 },
                    pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 }
                };
                
                dailyQuests = gameState.dailyQuests || [];
                questProgress = gameState.questProgress || {};
                lastQuestReset = gameState.lastQuestReset || Date.now();
                
                // Restore sprinklers
                activeSprinklers = gameState.activeSprinklers || [];
                
                // Restore plots with plant reconstruction
                if (gameState.plots) {
                    plots = gameState.plots.map(savedPlot => {
                        const plot = {
                            x: savedPlot.x,
                            y: savedPlot.y,
                            z: savedPlot.z,
                            stage: savedPlot.stage,
                            plantType: savedPlot.plantType,
                            growthTimer: savedPlot.growthTimer,
                            waterLevel: savedPlot.waterLevel,
                            lastWatered: savedPlot.lastWatered,
                            unlocked: savedPlot.unlocked,
                            unlockCost: savedPlot.unlockCost,
                            plant: null
                        };
                        
                        // Reconstruct plant object if needed
                        if (plot.stage > PLANT_STAGES.EMPTY && plot.plantType) {
                            const plantConfig = PLANT_TYPES[plot.plantType];
                            let size = 0.3;
                            if (plot.stage === PLANT_STAGES.GROWING1) size = 0.6;
                            else if (plot.stage === PLANT_STAGES.GROWING2) size = 0.9;
                            else if (plot.stage === PLANT_STAGES.MATURE) size = 1.2;
                            
                            plot.plant = {
                                size: size,
                                color: plantConfig.color,
                                baseColor: plantConfig.color
                            };
                            
                            if (plot.stage === PLANT_STAGES.MATURE) {
                                plot.plant.glow = true;
                            }
                            
                            // Handle withered plants
                            if (plot.stage === PLANT_STAGES.WITHERING) {
                                plot.plant.color = adjustColorBrightness(plantConfig.color, 0.5);
                            }
                        }
                        
                        return plot;
                    });
                }
                
                return true;
            } catch (e) {
                console.error('Failed to load game:', e);
                return false;
            }
        }
        
        function newGame() {
            // Clear save data
            localStorage.removeItem('pixelHarvestSave');
            
            // Reset all game state
            score = 0;
            coins = 50;
            dayNightCycle = 0;
            dayNightCycleCount = 0;
            cameraFollowX = 0;
            cameraFollowZ = 0;
            
            inventory = { 
                carrot: 0, tomato: 0, rare: 0, potato: 0, cabbage: 0, 
                corn: 0, watermelon: 0, pumpkin: 0, apple: 0 
            };
            seedInventory = { 
                carrot: 5, tomato: 2, rare: 1, potato: 3, cabbage: 2,
                corn: 1, watermelon: 1, pumpkin: 2, apple: 1
            };
            equipment = { sprinkler: 0, fertilizer: 0, greenhouse: 0 };
            animalInventory = { eggs: 0, milk: 0, truffles: 0 };
            activeSprinklers = [];
            objectives = {
                carrotsHarvested: 0,
                dayNightCycles: 0,
                coinsEarned: 0,
                plantsHarvested: 0,
                equipmentBought: 0,
                seedsPlanted: 0,
                plotsUnlocked: 9
            };
            
            // Reset new systems
            currentWeather = {
                type: 'sunny',
                name: 'Sunny',
                icon: '☀️',
                effect: 'Plants grow normally',
                growthMultiplier: 1.0,
                waterDecayMultiplier: 1.0,
                duration: 0,
                maxDuration: 30000
            };
            
            currentSeason = {
                type: 'spring',
                name: 'Spring',
                icon: '🌸',
                day: 1,
                maxDays: 20,
                availableCrops: ['carrot', 'tomato'],
                growthBonus: { carrot: 1.2, tomato: 1.0, rare: 0.8 }
            };
            
            animals = {
                chicken: { count: 0, eggs: 0, lastProduction: Date.now(), productionRate: 8000 },
                cow: { count: 0, milk: 0, lastProduction: Date.now(), productionRate: 15000 },
                pig: { count: 0, truffles: 0, lastProduction: Date.now(), productionRate: 20000 }
            };
            
            dailyQuests = [];
            questProgress = {};
            lastQuestReset = Date.now();
            
            // Generate initial quests
            generateDailyQuests();
            
            // Recreate plots
            createPlots();
            
            // Update UI
            updateUI();
            updateObjectives();
            updateWeatherUI();
            updateSeasonUI();
            updateAnimalsUI();
            updateQuestsUI();
            
            // Clear any effects
            if (window.gameEffects) window.gameEffects = [];
            
            console.log('New game started');
        }

        // Weather System Functions
        function updateWeather(deltaTime) {
            currentWeather.duration += deltaTime;
            
            // Check if weather should change
            if (currentWeather.duration >= currentWeather.maxDuration) {
                changeWeather();
            }
            
            // Apply weather effects to background
            updateBackgroundForWeather();
        }
        
        function changeWeather() {
            const weatherTypes = Object.keys(WEATHER_TYPES);
            const probabilities = weatherTypes.map(type => WEATHER_TYPES[type].probability);
            
            // Weighted random selection
            let random = Math.random();
            let selectedWeather = 'sunny';
            
            for (let i = 0; i < weatherTypes.length; i++) {
                random -= probabilities[i];
                if (random <= 0) {
                    selectedWeather = weatherTypes[i];
                    break;
                }
            }
            
            const weatherConfig = WEATHER_TYPES[selectedWeather];
            currentWeather = {
                type: selectedWeather,
                name: weatherConfig.name,
                icon: weatherConfig.icon,
                effect: weatherConfig.effect,
                growthMultiplier: weatherConfig.growthMultiplier,
                waterDecayMultiplier: weatherConfig.waterDecayMultiplier,
                duration: 0,
                maxDuration: 30000 + Math.random() * 20000 // 30-50 seconds
            };
            
            updateWeatherUI();
            saveGame();
        }
        
        function updateWeatherUI() {
            document.getElementById('weatherIcon').textContent = currentWeather.icon;
            document.getElementById('weatherName').textContent = currentWeather.name;
            document.getElementById('weatherEffect').textContent = currentWeather.effect;
        }
        
        function updateBackgroundForWeather() {
            const weatherConfig = WEATHER_TYPES[currentWeather.type];
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Blend day/night with weather colors
            const dayColor = weatherConfig.bgColor;
            const nightColor = { r: 25, g: 25, b: 112 };
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }

        // Season System Functions
        let lastDayState = false; // Track day state for season progression
        
        function updateSeason(deltaTime) {
            // Each day/night cycle advances the season by 1 day
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Check for season day advancement
            if (lastDayState !== isDay && isDay) {
                advanceSeasonDay();
            }
            lastDayState = isDay;
        }
        
        function advanceSeasonDay() {
            currentSeason.day++;
            
            if (currentSeason.day > currentSeason.maxDays) {
                changeSeason();
            }
            
            updateSeasonUI();
            saveGame();
        }
        
        function changeSeason() {
            const seasons = ['spring', 'summer', 'autumn', 'winter'];
            const currentIndex = seasons.indexOf(currentSeason.type);
            const nextIndex = (currentIndex + 1) % seasons.length;
            const nextSeasonType = seasons[nextIndex];
            
            const seasonConfig = SEASON_TYPES[nextSeasonType];
            currentSeason = {
                type: nextSeasonType,
                name: seasonConfig.name,
                icon: seasonConfig.icon,
                day: 1,
                maxDays: 20,
                availableCrops: seasonConfig.availableCrops,
                growthBonus: seasonConfig.growthBonus
            };
            
            updateSeasonUI();
            updateUI(); // Update plant buttons based on season
            
            // Show season change notification
            showInstruction(`🍂 Season changed to ${currentSeason.name}! Available crops updated.`, 3000);
            saveGame();
        }
        
        function updateSeasonUI() {
            document.getElementById('seasonIcon').textContent = currentSeason.icon;
            document.getElementById('seasonName').textContent = currentSeason.name;
            document.getElementById('seasonDay').textContent = `Day ${currentSeason.day} of ${currentSeason.maxDays}`;
        }

        // Animals System Functions
        function updateAnimals(deltaTime) {
            const currentTime = Date.now();
            
            Object.keys(animals).forEach(animalType => {
                const animal = animals[animalType];
                if (animal.count > 0) {
                    // Check if it's time to produce
                    if (currentTime - animal.lastProduction >= animal.productionRate) {
                        const productName = ANIMAL_PRODUCTS[animalType].name;
                        animal[productName] += animal.count; // Each animal produces 1 item
                        animal.lastProduction = currentTime;
                        updateAnimalsUI();
                        saveGame();
                    }
                }
            });
        }
        
        function buyAnimal(animalType, cost) {
            if (coins >= cost) {
                coins -= cost;
                animals[animalType].count++;
                objectives.equipmentBought++; // Count animals as equipment
                
                updateUI();
                updateAnimalsUI();
                updateObjectives();
                saveGame();
                
                showInstruction(`🐄 ${animalType.charAt(0).toUpperCase() + animalType.slice(1)} purchased! It will produce resources automatically.`, 2000);
            }
        }
        
        function collectResource(resourceType) {
            let collected = 0;
            
            Object.keys(animals).forEach(animalType => {
                const productInfo = ANIMAL_PRODUCTS[animalType];
                if (productInfo.name === resourceType) {
                    const amount = animals[animalType][resourceType];
                    if (amount > 0) {
                        collected += amount;
                        animals[animalType][resourceType] = 0;
                        
                        // Add to animal inventory instead of selling immediately
                        animalInventory[resourceType] += amount;
                        
                        // Track quest progress
                        updateQuestProgress('collect', amount);
                    }
                }
            });
            
            if (collected > 0) {
                updateUI();
                updateAnimalsUI();
                updateMarketplaceUI();
                updateQuestsUI();
                saveGame();
                
                showInstruction(`📦 Collected ${collected} ${resourceType}! Sell them at the marketplace.`, 2000);
            }
        }
        
        function updateAnimalsUI() {
            // Update animal counts
            document.getElementById('chickenCount').textContent = animals.chicken.count;
            document.getElementById('cowCount').textContent = animals.cow.count;
            document.getElementById('pigCount').textContent = animals.pig.count;
            
            // Update resource counts
            document.getElementById('eggCount').textContent = animals.chicken.eggs;
            document.getElementById('milkCount').textContent = animals.cow.milk;
            document.getElementById('truffleCount').textContent = animals.pig.truffles;
            
            // Update button states
            document.getElementById('buyChickenBtn').disabled = coins < ANIMAL_COSTS.chicken;
            document.getElementById('buyCowBtn').disabled = coins < ANIMAL_COSTS.cow;
            document.getElementById('buyPigBtn').disabled = coins < ANIMAL_COSTS.pig;
            
            document.getElementById('collectEggsBtn').disabled = animals.chicken.eggs === 0;
            document.getElementById('collectMilkBtn').disabled = animals.cow.milk === 0;
            document.getElementById('collectTrufflesBtn').disabled = animals.pig.truffles === 0;
        }

        // Daily Quests System Functions  
        function generateDailyQuests() {
            dailyQuests = [];
            questProgress = {};
            
            // Generate 3 random quests
            const availableQuests = [...QUEST_TYPES];
            for (let i = 0; i < 3; i++) {
                if (availableQuests.length === 0) break;
                
                const randomIndex = Math.floor(Math.random() * availableQuests.length);
                const questTemplate = availableQuests.splice(randomIndex, 1)[0];
                
                // Random difficulty (0, 1, or 2)
                const difficulty = Math.floor(Math.random() * 3);
                const quest = {
                    id: questTemplate.id + '_' + Date.now() + '_' + i,
                    name: questTemplate.name.replace('{target}', questTemplate.target[difficulty]),
                    description: questTemplate.description,
                    type: questTemplate.type,
                    target: questTemplate.target[difficulty],
                    reward: questTemplate.reward[difficulty],
                    progress: 0,
                    completed: false
                };
                
                dailyQuests.push(quest);
                questProgress[quest.id] = 0;
            }
            
            updateQuestsUI();
            saveGame();
        }
        
        function updateQuestProgress(type, amount = 1) {
            let questsCompleted = false;
            
            dailyQuests.forEach(quest => {
                if (!quest.completed && quest.type === type) {
                    quest.progress = Math.min(quest.target, quest.progress + amount);
                    questProgress[quest.id] = quest.progress;
                    
                    if (quest.progress >= quest.target && !quest.completed) {
                        quest.completed = true;
                        coins += quest.reward;
                        objectives.coinsEarned += quest.reward;
                        questsCompleted = true;
                        
                        showInstruction(`✅ Quest completed! Earned ${quest.reward} coins.`, 2000);
                    }
                }
            });
            
            if (questsCompleted) {
                updateUI();
                updateObjectives();
            }
            
            updateQuestsUI();
            saveGame();
        }
        
        function resetDailyQuests() {
            if (coins >= 50) {
                coins -= 50;
                generateDailyQuests();
                updateUI();
                showInstruction('🔄 New daily quests generated!', 2000);
            }
        }
        
        function updateQuestsUI() {
            const questList = document.getElementById('questList');
            questList.innerHTML = '';
            
            dailyQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = `quest-item ${quest.completed ? 'quest-completed' : ''}`;
                
                const progressPercent = (quest.progress / quest.target) * 100;
                
                questDiv.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 5px;">
                        ${quest.completed ? '✅' : '📋'} ${quest.name}
                    </div>
                    <div style="font-size: 11px; opacity: 0.8; margin-bottom: 5px;">
                        ${quest.description}
                    </div>
                    <div class="quest-progress">
                        <div class="quest-progress-bar" style="width: ${progressPercent}%"></div>
                    </div>
                    <div style="font-size: 11px; margin-top: 5px;">
                        Progress: ${quest.progress}/${quest.target} | Reward: ${quest.reward}💰
                    </div>
                `;
                
                questList.appendChild(questDiv);
            });
        }
        
        // Tutorial System Functions
        function startTutorial() {
            tutorialActive = true;
            tutorialStep = 0;
            document.getElementById('tutorialOverlay').style.display = 'flex';
            showTutorialStep();
        }

        function showTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            if (!step) return;

            document.getElementById('tutorialTitle').textContent = step.title;
            document.getElementById('tutorialText').innerHTML = `<div class="tutorial-step">${step.text}</div>`;
            
            // Hide highlight first
            hideHighlight();
            
            // Handle different action types
            switch (step.action) {
                case "continue":
                    setupContinueButton();
                    break;
                case "highlight":
                    highlightElement(step.target);
                    setupContinueButton();
                    break;
                case "wait_interaction":
                    highlightElement(step.target);
                    setupWaitForInteraction(step.element);
                    break;
                case "movement_demo":
                    setupMovementDemo();
                    break;
                case "wait_plant":
                    setupWaitForPlanting();
                    break;
                case "complete":
                    setupCompleteTutorial();
                    break;
            }
        }

        function setupContinueButton() {
            const nextBtn = document.getElementById('tutorialNext');
            nextBtn.textContent = "Continue";
            nextBtn.onclick = nextTutorialStep;
            
            const skipBtn = document.getElementById('tutorialSkip');
            skipBtn.style.display = 'inline-block';
        }

        function setupWaitForInteraction(elementSelector) {
            const nextBtn = document.getElementById('tutorialNext');
            nextBtn.textContent = "Click the highlighted element";
            nextBtn.style.display = 'none';
            
            // Wait for interaction with the specified element
            const elements = document.querySelectorAll(elementSelector);
            elements.forEach(el => {
                el.addEventListener('click', handleTutorialInteraction, { once: true });
            });
        }

        function setupMovementDemo() {
            const nextBtn = document.getElementById('tutorialNext');
            nextBtn.textContent = "Try moving with ZQSD or arrow keys";
            nextBtn.onclick = nextTutorialStep;
            
            // Hide tutorial overlay temporarily to show movement
            document.getElementById('tutorialOverlay').style.display = 'none';
            
            // Show a temporary instruction
            showInstruction("Try moving your character with ZQSD or arrow keys, then press this button to continue", 0);
            
            // Add a floating continue button
            const continueBtn = document.createElement('button');
            continueBtn.textContent = "Continue Tutorial";
            continueBtn.className = 'tutorial-btn';
            continueBtn.style.position = 'fixed';
            continueBtn.style.top = '50%';
            continueBtn.style.left = '50%';
            continueBtn.style.transform = 'translate(-50%, -50%)';
            continueBtn.style.zIndex = '500';
            continueBtn.onclick = () => {
                document.body.removeChild(continueBtn);
                document.getElementById('tutorialOverlay').style.display = 'flex';
                nextTutorialStep();
            };
            document.body.appendChild(continueBtn);
        }

        function setupWaitForPlanting() {
            const nextBtn = document.getElementById('tutorialNext');
            nextBtn.textContent = "Plant your first seed";
            nextBtn.style.display = 'none';
            
            // Hide tutorial overlay to allow planting
            document.getElementById('tutorialOverlay').style.display = 'none';
            
            // Show instruction
            showInstruction("Get close to the center plot and press SPACE to plant a seed!", 0);
            
            // Listen for planting action
            let originalPlantSeed = plantSeed;
            plantSeed = function(plot, plantType) {
                originalPlantSeed(plot, plantType);
                // Restore original function
                plantSeed = originalPlantSeed;
                // Continue tutorial
                setTimeout(() => {
                    document.getElementById('tutorialOverlay').style.display = 'flex';
                    nextTutorialStep();
                }, 1500);
            };
        }

        function setupCompleteTutorial() {
            const nextBtn = document.getElementById('tutorialNext');
            nextBtn.textContent = "Start Playing!";
            nextBtn.onclick = endTutorial;
            
            const skipBtn = document.getElementById('tutorialSkip');
            skipBtn.style.display = 'none';
        }

        function handleTutorialInteraction() {
            setTimeout(() => {
                nextTutorialStep();
            }, 500);
        }

        function nextTutorialStep() {
            tutorialStep++;
            if (tutorialStep >= tutorialSteps.length) {
                endTutorial();
            } else {
                showTutorialStep();
            }
        }

        function endTutorial() {
            tutorialActive = false;
            document.getElementById('tutorialOverlay').style.display = 'none';
            hideHighlight();
            
            // Save that tutorial was completed
            localStorage.setItem('pixelHarvestTutorialCompleted', 'true');
            
            showInstruction("Tutorial completed! Welcome to Pixel-Harvest!", 3000);
        }

        function skipTutorial() {
            endTutorial();
        }

        function highlightElement(selector) {
            if (!selector) return;
            
            const element = document.querySelector(selector);
            if (!element) return;
            
            const highlight = document.getElementById('tutorialHighlight');
            const rect = element.getBoundingClientRect();
            
            highlight.style.display = 'block';
            highlight.style.left = (rect.left - 5) + 'px';
            highlight.style.top = (rect.top - 5) + 'px';
            highlight.style.width = (rect.width + 10) + 'px';
            highlight.style.height = (rect.height + 10) + 'px';
        }

        function hideHighlight() {
            document.getElementById('tutorialHighlight').style.display = 'none';
        }

        // Profile System Functions
        function showProfileScreen() {
            document.getElementById('profileOverlay').style.display = 'flex';
            loadProfiles();
        }

        function hideProfileScreen() {
            document.getElementById('profileOverlay').style.display = 'none';
        }

        function loadProfiles() {
            try {
                const saved = localStorage.getItem('pixelHarvestProfiles');
                profiles = saved ? JSON.parse(saved) : [];
            } catch (e) {
                console.error('Failed to load profiles:', e);
                profiles = [];
            }
        }

        function saveProfiles() {
            try {
                localStorage.setItem('pixelHarvestProfiles', JSON.stringify(profiles));
            } catch (e) {
                console.error('Failed to save profiles:', e);
            }
        }

        function createProfile() {
            const username = document.getElementById('usernameInput').value.trim();
            if (!username) {
                alert('Please enter a username!');
                return;
            }

            if (profiles.some(p => p.username === username)) {
                alert('Username already exists! Please choose a different one.');
                return;
            }

            const selectedCharacter = document.querySelector('.character-option[data-character].selected');
            const selectedColor = document.querySelector('.character-option[data-color].selected');

            currentProfile = {
                username: username,
                character: selectedCharacter ? selectedCharacter.dataset.character : 'farmer',
                characterColor: selectedColor ? selectedColor.dataset.color : '#4169E1',
                highScore: 0,
                totalCoins: 0,
                created: Date.now(),
                id: generateProfileId()
            };

            profiles.push(currentProfile);
            saveProfiles();
            
            // Apply profile to character
            character.color = currentProfile.characterColor;
            
            hideProfileScreen();
            updatePlayerInfoDisplay();
            
            // Save this as the last used profile
            localStorage.setItem('pixelHarvestLastProfile', currentProfile.id);
            
            // Check if tutorial should be shown
            const tutorialCompleted = localStorage.getItem('pixelHarvestTutorialCompleted');
            if (!tutorialCompleted) {
                startTutorial();
            }
            
            showInstruction(`Welcome ${currentProfile.username}! Profile created successfully!`, 3000);
        }

        function generateProfileId() {
            return 'profile_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function loadExistingProfile() {
            if (profiles.length === 0) {
                alert('No profiles found! Please create a new profile.');
                return;
            }

            // Simple profile selection for now - could be enhanced with a better UI
            const usernames = profiles.map(p => p.username);
            const selected = prompt('Select profile:\n' + usernames.map((u, i) => `${i + 1}. ${u}`).join('\n') + '\n\nEnter the number:');
            
            const index = parseInt(selected) - 1;
            if (index >= 0 && index < profiles.length) {
                currentProfile = profiles[index];
                character.color = currentProfile.characterColor;
                hideProfileScreen();
                updatePlayerInfoDisplay();
                
                // Save this as the last used profile
                localStorage.setItem('pixelHarvestLastProfile', currentProfile.id);
                
                showInstruction(`Welcome back ${currentProfile.username}!`, 3000);
                
                // Load profile's game state if exists
                loadGameForProfile();
            } else {
                alert('Invalid selection!');
            }
        }

        function loadGameForProfile() {
            try {
                const gameData = localStorage.getItem(`pixelHarvestGame_${currentProfile.id}`);
                if (gameData) {
                    const data = JSON.parse(gameData);
                    // Restore game state
                    score = data.score || 0;
                    coins = data.coins || 50;
                    inventory = data.inventory || {};
                    objectives = data.objectives || {};
                    updateUI();
                }
            } catch (e) {
                console.error('Failed to load game data for profile:', e);
            }
            
            // Update player info display
            updatePlayerInfoDisplay();
        }

        function updatePlayerInfoDisplay() {
            const playerInfoElement = document.getElementById('playerInfo');
            if (playerInfoElement && currentProfile.username) {
                const characterEmoji = getCharacterEmoji(currentProfile.character);
                playerInfoElement.innerHTML = `${characterEmoji} Player: ${currentProfile.username} | High Score: ${currentProfile.highScore}`;
            }
        }

        function getCharacterEmoji(character) {
            switch (character) {
                case 'farmer': return '👨‍🌾';
                case 'girl': return '👩‍🌾';
                case 'boy': return '🧑‍🌾';
                case 'old': return '🧓';
                default: return '👨‍🌾';
            }
        }

        function saveGameForProfile() {
            if (!currentProfile.id) return;
            
            try {
                const gameData = {
                    score: score,
                    coins: coins,
                    inventory: inventory,
                    objectives: objectives,
                    lastPlayed: Date.now()
                };
                
                localStorage.setItem(`pixelHarvestGame_${currentProfile.id}`, JSON.stringify(gameData));
                
                // Update profile stats
                currentProfile.highScore = Math.max(currentProfile.highScore, score);
                currentProfile.totalCoins = coins;
                saveProfiles();
            } catch (e) {
                console.error('Failed to save game data for profile:', e);
            }
        }

        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Initialize audio
            initAudio();
            
            // Load saved controls
            loadSavedControls();
            
            // Initialize tutorial and profile event listeners
            initTutorialEvents();
            initProfileEvents();
            
            // Check for existing profiles
            loadProfiles();
            
            // Try to load saved game, otherwise create new game
            if (!loadGame()) {
                // Initialize camera
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
                
                // Create farming plots
                createPlots();
            } else {
                // Initialize camera for loaded game
                cameraAngleX = -0.3; // Look down slightly
                cameraAngleY = 0;
                
                // Generate quests if none exist or it's been too long
                if (dailyQuests.length === 0 || Date.now() - lastQuestReset > 86400000) {
                    generateDailyQuests();
                }
            }
            
            // Add event listeners
            addEventListeners();
            
            // Initialize UI
            setupUI();
            
            // Initialize new systems UI
            updateWeatherUI();
            updateSeasonUI();
            updateAnimalsUI();
            updateQuestsUI();
            
            // Generate initial daily quests if needed
            if (dailyQuests.length === 0) {
                generateDailyQuests();
            }
            
            // Update instructions with current controls
            updateInstructions();
            
            // Set up auto-save (every 10 seconds) - now includes profile saving
            autoSaveInterval = setInterval(() => {
                saveGame();
                if (currentProfile.id) {
                    saveGameForProfile();
                }
            }, 10000);
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('dayNightIndicator').style.display = 'block';
            document.getElementById('plantSelector').style.display = 'block';
            document.getElementById('inventory').style.display = 'block';
            document.getElementById('marketplace').style.display = 'block';
            document.getElementById('objectives').style.display = 'block';
            document.getElementById('settingsButton').style.display = 'block';
            document.getElementById('newGameButton').style.display = 'block';
            document.getElementById('profileButton').style.display = 'block';
            document.getElementById('uiModeToggle').style.display = 'block';
            document.getElementById('weatherPanel').style.display = 'block';
            document.getElementById('seasonPanel').style.display = 'block';
            document.getElementById('animalsPanel').style.display = 'block';
            document.getElementById('questsPanel').style.display = 'block';
            
            // Check if user has a profile
            if (profiles.length === 0 || !currentProfile.username) {
                showProfileScreen();
            } else {
                // Auto-load last used profile if exists
                const lastProfile = localStorage.getItem('pixelHarvestLastProfile');
                if (lastProfile) {
                    const found = profiles.find(p => p.id === lastProfile);
                    if (found) {
                        currentProfile = found;
                        character.color = currentProfile.characterColor;
                        loadGameForProfile();
                        localStorage.setItem('pixelHarvestLastProfile', currentProfile.id);
                    }
                } else if (profiles.length > 0) {
                    // If no last profile but profiles exist, use the first one
                    currentProfile = profiles[0];
                    character.color = currentProfile.characterColor;
                    loadGameForProfile();
                    localStorage.setItem('pixelHarvestLastProfile', currentProfile.id);
                }
                
                // Check tutorial
                const tutorialCompleted = localStorage.getItem('pixelHarvestTutorialCompleted');
                if (!tutorialCompleted) {
                    setTimeout(() => startTutorial(), 1000); // Small delay to ensure UI is ready
                }
            }
            
            // Start game loop
            animate();
        }

        function initTutorialEvents() {
            document.getElementById('tutorialNext').addEventListener('click', nextTutorialStep);
            document.getElementById('tutorialSkip').addEventListener('click', skipTutorial);
        }

        function initProfileEvents() {
            document.getElementById('createProfileBtn').addEventListener('click', createProfile);
            document.getElementById('loadProfileBtn').addEventListener('click', loadExistingProfile);
            
            // Profile button in main UI
            document.getElementById('profileButton').addEventListener('click', showProfileScreen);
            
            // Character selection events
            document.querySelectorAll('.character-option[data-character]').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.character-option[data-character]').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Character color selection events
            document.querySelectorAll('.character-option[data-color]').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.character-option[data-color]').forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                });
            });
            
            // Set default selections
            setTimeout(() => {
                const farmerOption = document.querySelector('.character-option[data-character="farmer"]');
                const blueOption = document.querySelector('.character-option[data-color="#4169E1"]');
                if (farmerOption) farmerOption.classList.add('selected');
                if (blueOption) blueOption.classList.add('selected');
            }, 100);
        }
        
        // Audio system functions
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Initialize wind ambience
                initWindAmbience();
                
                // Schedule bird sounds
                scheduleBirdSounds();
                
            } catch (e) {
                console.log('Web Audio API not supported', e);
            }
        }
        
        function initWindAmbience() {
            if (!audioContext) return;
            
            // Create wind sound using brown noise
            const bufferSize = audioContext.sampleRate * 2; // 2 seconds
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                data[i] = (lastOut + (0.02 * white)) / 1.02;
                lastOut = data[i];
                data[i] *= 0.1; // Lower volume
            }
            
            const windSource = audioContext.createBufferSource();
            windSource.buffer = buffer;
            windSource.loop = true;
            
            windGain = audioContext.createGain();
            windGain.gain.value = 0.1;
            
            // Create an irregular wind pattern
            const lfo = audioContext.createOscillator();
            lfo.frequency.value = 0.3; // Very slow modulation
            lfo.type = 'sine';
            
            const lfoGain = audioContext.createGain();
            lfoGain.gain.value = 0.05;
            
            lfo.connect(lfoGain);
            lfoGain.connect(windGain.gain);
            
            windSource.connect(windGain);
            windGain.connect(audioContext.destination);
            
            // Start the wind with proper audio context handling
            const startAudio = () => {
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        try {
                            windSource.start();
                            lfo.start();
                        } catch (e) {
                            console.log('Audio already started', e);
                        }
                    });
                } else {
                    try {
                        windSource.start();
                        lfo.start();
                    } catch (e) {
                        console.log('Audio already started', e);
                    }
                }
            };
            
            // Try to start immediately, or wait for user interaction
            if (audioContext.state === 'running') {
                startAudio();
            } else {
                document.addEventListener('click', startAudio, { once: true });
                document.addEventListener('keydown', startAudio, { once: true });
            }
        }
        
        function scheduleBirdSounds() {
            if (!audioContext) return;
            
            const playBirdSound = () => {
                if (Date.now() - lastBirdSound > 15000) { // At least 15 seconds between bird sounds
                    createBirdSound();
                    lastBirdSound = Date.now();
                }
                
                // Schedule next bird sound randomly between 20-60 seconds
                const nextDelay = 20000 + Math.random() * 40000;
                setTimeout(playBirdSound, nextDelay);
            };
            
            // Start first bird sound after 10 seconds
            setTimeout(playBirdSound, 10000);
        }
        
        function createBirdSound() {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            // Random bird chirp frequency
            const baseFreq = 800 + Math.random() * 1200;
            oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, audioContext.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 0.8, audioContext.currentTime + 0.2);
            
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.05);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        }
        
        function playActionSound(action) {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                switch (action) {
                    case 'plant':
                        oscillator.frequency.value = 400;
                        oscillator.type = 'triangle';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        oscillator.stop(audioContext.currentTime + 0.2);
                        break;
                        
                    case 'harvest':
                        oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
                        oscillator.frequency.linearRampToValueAtTime(800, audioContext.currentTime + 0.1);
                        oscillator.type = 'sawtooth';
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                        
                    case 'water':
                        // Water splash sound
                        const whiteNoise = audioContext.createBufferSource();
                        const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.3, audioContext.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < buffer.length; i++) {
                            data[i] = Math.random() * 2 - 1;
                        }
                        whiteNoise.buffer = buffer;
                        
                        const filter = audioContext.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 1000;
                        
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        
                        whiteNoise.connect(filter);
                        filter.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        whiteNoise.start(audioContext.currentTime);
                        whiteNoise.stop(audioContext.currentTime + 0.3);
                        return; // Don't use oscillator for water sound
                        
                    case 'unlock':
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        oscillator.frequency.exponentialRampToValueAtTime(900, audioContext.currentTime + 0.2);
                        oscillator.type = 'square';
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                }
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(audioContext.currentTime);
            } catch (e) {
                console.log('Audio playback error:', e);
            }
        }
        
        function createPlots() {
            // Create a 5x5 grid of farming plots (some locked initially)
            plots = [];
            for (let x = -8; x <= 8; x += 4) {
                for (let z = -8; z <= 8; z += 4) {
                    const distanceFromCenter = Math.sqrt(x*x + z*z);
                    const plot = {
                        x: x,
                        y: 0,
                        z: z,
                        stage: PLANT_STAGES.EMPTY,
                        plant: null,
                        plantType: null,
                        growthTimer: 0,
                        waterLevel: 1.0,
                        lastWatered: Date.now(),
                        unlocked: distanceFromCenter <= 6, // Inner 3x3 grid unlocked initially
                        unlockCost: Math.floor(distanceFromCenter * 2)
                    };
                    plots.push(plot);
                }
            }
        }
        
        function setupUI() {
            // Plant selector buttons
            document.querySelectorAll('.plant-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.plant-btn').forEach(b => b.classList.remove('selected'));
                    e.target.classList.add('selected');
                    selectedPlantType = e.target.dataset.plant;
                });
            });
            
            // Settings button
            document.getElementById('settingsButton').addEventListener('click', openSettings);
            
            // New Game button
            document.getElementById('newGameButton').addEventListener('click', () => {
                if (confirm('Are you sure you want to start a new game? This will delete your current progress.')) {
                    newGame();
                }
            });
            
            updateUI();
        }
        
        function addEventListeners() {
            // Mouse controls
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseLeave);
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('contextmenu', onRightClick);
            canvas.addEventListener('wheel', onMouseWheel);
            
            // Keyboard controls
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onKeyDown(event) {
            // Handle key recording
            if (recordingKey) {
                event.preventDefault();
                const keyCode = event.code;
                
                // Update the control mapping
                controls[recordingKey] = keyCode;
                
                // Update the button display
                document.getElementById(`key-${recordingKey}`).textContent = getKeyDisplayName(keyCode);
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                
                // Stop recording
                recordingKey = null;
                
                // Update instructions
                updateInstructions();
                return;
            }
            
            keys[event.code] = true;
            
            // Toggle camera mode
            if (event.code === controls.camera) {
                freeCameraMode = !freeCameraMode;
                cameraFollowCharacter = !freeCameraMode;
                
                // Update camera mode display
                document.getElementById('cameraMode').textContent = 
                    freeCameraMode ? 'Camera: Free Mode' : 'Camera: Character Follow';
            }
            
            // Action keys
            if (event.code === controls.action) {
                event.preventDefault();
                performCharacterAction();
            }
            
            if (event.code === controls.water) {
                event.preventDefault();
                performWateringAction();
            }
            
            // Open settings with Escape key
            if (event.code === 'Escape') {
                event.preventDefault();
                if (document.getElementById('settingsMenu').style.display === 'block') {
                    cancelControls();
                } else {
                    openSettings();
                }
            }
            
            // Handle R key for resetting panel positions (only in UI edit mode)
            if (event.code === 'KeyR' && window.uiEditMode) {
                event.preventDefault();
                resetPanelPositions();
            }
        }
        
        function updateInstructions() {
            const forwardKey = getKeyDisplayName(controls.forward);
            const leftKey = getKeyDisplayName(controls.left);
            const backwardKey = getKeyDisplayName(controls.backward);
            const rightKey = getKeyDisplayName(controls.right);
            const actionKey = getKeyDisplayName(controls.action);
            const waterKey = getKeyDisplayName(controls.water);
            const cameraKey = getKeyDisplayName(controls.camera);
            
            document.getElementById('instructions').innerHTML = `
                🌱 Move with ${forwardKey}${leftKey}${backwardKey}${rightKey} or arrow keys<br>
                ⚡ ${actionKey} to plant/harvest at closest plot<br>
                💧 ${waterKey} to water plants<br>
                📹 ${cameraKey} to toggle camera mode<br>
                🌿 Plants grow automatically (3 stages)<br>
                🔒 Unlock plots by getting close and pressing ${actionKey}<br>
                🌙 Watch the day/night cycle!<br>
                🖱️ Drag to rotate camera view<br>
                🔍 Scroll wheel to zoom in/out<br>
                ⚙️ ESC to open settings<br>
                🔧 UI Mode button to customize interface<br>
                📝 R to reset panel positions (in UI Mode)
            `;
        }
        
        function getKeyDisplayName(keyCode) {
            const keyMap = {
                'KeyZ': 'Z', 'KeyQ': 'Q', 'KeyS': 'S', 'KeyD': 'D',
                'KeyW': 'W', 'KeyA': 'A', 'KeyE': 'E', 'KeyC': 'C',
                'Space': 'SPACE', 'ArrowUp': '↑', 'ArrowDown': '↓',
                'ArrowLeft': '←', 'ArrowRight': '→', 'ShiftLeft': 'SHIFT',
                'ControlLeft': 'CTRL', 'AltLeft': 'ALT'
            };
            return keyMap[keyCode] || keyCode.replace('Key', '').replace('Digit', '');
        }
        
        // Settings menu functions
        function openSettings() {
            // Backup current controls
            backupControls = {...controls};
            
            // Update button displays
            updateControlButtons();
            
            // Show settings menu
            document.getElementById('settingsMenu').style.display = 'block';
        }
        
        function updateControlButtons() {
            Object.keys(controls).forEach(action => {
                const button = document.getElementById(`key-${action}`);
                if (button) {
                    button.textContent = getKeyDisplayName(controls[action]);
                }
            });
        }
        
        function recordKey(action) {
            if (recordingKey === action) {
                // Cancel recording
                document.getElementById(`key-${action}`).classList.remove('recording');
                recordingKey = null;
                return;
            }
            
            // Stop any current recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
            }
            
            // Start recording for this action
            recordingKey = action;
            document.getElementById(`key-${action}`).classList.add('recording');
            document.getElementById(`key-${action}`).textContent = 'Press key...';
        }
        
        function setControlPreset(preset) {
            // Stop any recording
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
            
            switch(preset) {
                case 'azerty':
                    controls.forward = 'KeyZ';
                    controls.left = 'KeyQ';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'qwerty':
                    controls.forward = 'KeyW';
                    controls.left = 'KeyA';
                    controls.backward = 'KeyS';
                    controls.right = 'KeyD';
                    break;
                case 'arrows':
                    controls.forward = 'ArrowUp';
                    controls.left = 'ArrowLeft';
                    controls.backward = 'ArrowDown';
                    controls.right = 'ArrowRight';
                    break;
            }
            
            updateControlButtons();
        }
        
        function saveControls() {
            // Save to localStorage
            localStorage.setItem('pixelHarvestControls', JSON.stringify(controls));
            
            // Update instructions
            updateInstructions();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            recordingKey = null;
        }
        
        function cancelControls() {
            // Restore backup controls
            controls = {...backupControls};
            
            // Update button displays
            updateControlButtons();
            
            // Close settings menu
            document.getElementById('settingsMenu').style.display = 'none';
            
            // Clear recording state
            if (recordingKey) {
                document.getElementById(`key-${recordingKey}`).classList.remove('recording');
                recordingKey = null;
            }
        }
        
        function resetControls() {
            // Reset to AZERTY default
            controls = {
                forward: 'KeyZ',
                left: 'KeyQ',
                backward: 'KeyS',
                right: 'KeyD',
                action: 'Space',
                water: 'KeyE',
                camera: 'KeyC'
            };
            updateControlButtons();
        }
        
        function loadSavedControls() {
            const saved = localStorage.getItem('pixelHarvestControls');
            if (saved) {
                try {
                    controls = JSON.parse(saved);
                } catch (e) {
                    console.log('Failed to load saved controls, using defaults');
                }
            }
        }
        
        function onKeyUp(event) {
            keys[event.code] = false;
        }
        
        function onMouseDown(event) {
            mouseDown = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            if (mouseDown && freeCameraMode) {
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.01;
                cameraAngleX += deltaY * 0.01;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                
                // Clear hover state when dragging
                hoveredPlot = null;
            } else if (mouseDown && !freeCameraMode) {
                // In character follow mode, still allow some camera control
                const deltaX = event.clientX - lastMouseX;
                const deltaY = event.clientY - lastMouseY;
                
                cameraAngleY += deltaX * 0.005; // Reduced sensitivity
                cameraAngleX += deltaY * 0.005;
                
                // Limit vertical rotation
                cameraAngleX = Math.max(-Math.PI / 2, Math.min(Math.PI / 6, cameraAngleX));
                
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
            } else {
                // Check for plot hover only in free camera mode
                if (freeCameraMode) {
                    hoveredPlot = null;
                    plots.forEach(plot => {
                        if (plotContainsScreenPoint(mouseX, mouseY, plot)) {
                            hoveredPlot = plot;
                        }
                    });
                }
                
                // Update cursor based on hover state and camera mode
                if (freeCameraMode) {
                    canvas.style.cursor = hoveredPlot ? 'pointer' : 'crosshair';
                } else {
                    canvas.style.cursor = 'grab';
                }
            }
        }
        
        function onMouseUp(event) {
            mouseDown = false;
        }
        
        function onMouseLeave(event) {
            mouseDown = false; // Reset mouse state when leaving canvas
        }
        
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling
            
            // Zoom in/out based on wheel direction
            const zoomSpeed = 0.5;
            const zoomDirection = event.deltaY > 0 ? 1 : -1; // Positive = zoom out, negative = zoom in
            
            cameraDistance += zoomDirection * zoomSpeed;
            
            // Limit zoom range
            cameraDistance = Math.max(3, Math.min(20, cameraDistance)); // Min: 3, Max: 20
        }
        
        function onRightClick(event) {
            event.preventDefault();
            
            if (!freeCameraMode) return; // Only allow right-click watering in free camera mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks for watering
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    waterPlot(plot);
                }
            });
        }
        
        function waterPlot(plot) {
            if (plot.stage !== PLANT_STAGES.EMPTY) {
                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.5);
                plot.lastWatered = Date.now();
                
                // Update quest progress
                updateQuestProgress('water');
                
                // Play water sound
                playActionSound('water');
                
                // Revive withered plants when watered
                if (plot.stage === PLANT_STAGES.WITHERING && plot.waterLevel > 0.3) {
                    // Determine what stage the plant should return to based on its growth timer
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    const growthProgress = Math.floor(plot.growthTimer / plantConfig.growthTime);
                    
                    if (growthProgress >= 2) {
                        plot.stage = PLANT_STAGES.GROWING2;
                    } else if (growthProgress >= 1) {
                        plot.stage = PLANT_STAGES.GROWING1;
                    } else {
                        plot.stage = PLANT_STAGES.PLANTED;
                    }
                    
                    // Restore plant color
                    if (plot.plant) {
                        plot.plant.color = plot.plant.baseColor || PLANT_TYPES[plot.plantType].color;
                    }
                }
                
                // Visual feedback for watering
                createWaterEffect(plot);
                updateQuestsUI();
                saveGame(); // Auto-save after watering
            }
        }
        
        function createWaterEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'water',
                emoji: '💧'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function onMouseClick(event) {
            if (mouseDown || !freeCameraMode) return; // Ignore clicks during drag or in character mode
            
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            // Check for plot clicks without drawing
            plots.forEach(plot => {
                if (plotContainsScreenPoint(clickX, clickY, plot)) {
                    handlePlotClick(plot);
                }
            });
        }
        
        function handlePlotClick(plot) {
            // Handle equipment placement
            if (selectedEquipment === 'sprinkler' && plot.unlocked) {
                // Check if there's already a sprinkler here
                const existingSprinkler = activeSprinklers.find(s => s.x === plot.x && s.z === plot.z);
                if (!existingSprinkler) {
                    activeSprinklers.push({
                        x: plot.x,
                        y: plot.y + 1,
                        z: plot.z,
                        range: 6, // Affects plots within 6 units
                        lastSprinkleTime: 0  // Initialize to 0 for immediate first sprinkle
                    });
                    
                    equipment.sprinkler--; // Remove from inventory
                    selectedEquipment = null;
                    canvas.style.cursor = 'crosshair';
                    
                    showInstruction('Auto Sprinkler placed! It will water nearby plants automatically.', 2000);
                    updateUI();
                    saveGame(); // Auto-save after placing sprinkler
                }
                return;
            }
            
            if (!plot.unlocked) {
                // Try to unlock the plot
                if (coins >= plot.unlockCost) {
                    coins -= plot.unlockCost;
                    plot.unlocked = true;
                    objectives.plotsUnlocked++; // Increment unlocked plots counter
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    
                    // Create unlock effect
                    createUnlockEffect(plot);
                }
                return;
            }
            
            if (plot.stage === PLANT_STAGES.EMPTY) {
                plantSeed(plot, selectedPlantType);
            } else if (plot.stage === PLANT_STAGES.MATURE) {
                harvestPlant(plot);
            }
        }
        
        function createUnlockEffect(plot) {
            const effect = {
                x: plot.x,
                y: plot.y + 1,
                z: plot.z,
                timer: 0,
                duration: 1500,
                type: 'unlock',
                emoji: '🔓'
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function plantSeed(plot, plantType) {
            if (seedInventory[plantType] <= 0) {
                return; // No seeds available
            }
            
            // Check if plant type is available in current season
            if (!currentSeason.availableCrops.includes(plantType)) {
                showInstruction(`❄️ ${PLANT_TYPES[plantType].name} is not available in ${currentSeason.name}!`, 2000);
                return;
            }
            
            const plantConfig = PLANT_TYPES[plantType];
            seedInventory[plantType]--;
            objectives.seedsPlanted++;
            
            plot.stage = PLANT_STAGES.PLANTED;
            plot.plantType = plantType;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            plot.lastWatered = Date.now();
            plot.plant = {
                size: 0.3,
                color: plantConfig.color,
                baseColor: plantConfig.color
            };
            
            // Update quest progress
            updateQuestProgress('plant');
            
            // Play plant sound
            playActionSound('plant');
            
            updateUI();
            updateObjectives();
            updateQuestsUI();
            saveGame(); // Auto-save after planting
        }
        
        function growPlant(plot) {
            const plantConfig = PLANT_TYPES[plot.plantType];
            
            if (plot.stage === PLANT_STAGES.PLANTED) {
                plot.stage = PLANT_STAGES.GROWING1;
                plot.plant.size = 0.6;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING1) {
                plot.stage = PLANT_STAGES.GROWING2;
                plot.plant.size = 0.9;
                plot.growthTimer = 0;
            } else if (plot.stage === PLANT_STAGES.GROWING2) {
                plot.stage = PLANT_STAGES.MATURE;
                plot.plant.size = 1.2;
                // Add glow effect for mature plants
                plot.plant.glow = true;
            }
        }
        
        function harvestPlant(plot) {
            if (plot.stage !== PLANT_STAGES.MATURE) return;
            
            const plantType = plot.plantType;
            const plantConfig = PLANT_TYPES[plantType];
            
            // Add to inventory
            inventory[plantType]++;
            
            // Add score (dynamic based on weather/season)
            const dynamicValue = getDynamicPrice(plantType, 'sell');
            score += dynamicValue;
            
            // Update objectives
            if (plantType === 'carrot') {
                objectives.carrotsHarvested++;
            }
            objectives.plantsHarvested++;
            
            // Update quest progress
            updateQuestProgress('harvest');
            
            // Reset plot
            plot.stage = PLANT_STAGES.EMPTY;
            plot.plant = null;
            plot.plantType = null;
            plot.growthTimer = 0;
            plot.waterLevel = 1.0;
            
            // Play harvest sound
            playActionSound('harvest');
            
            // Create harvest effect with animation
            createHarvestEffect(plot);
            
            updateUI();
            updateObjectives();
            updateQuestsUI();
            saveGame(); // Auto-save after harvesting
        }
        
        function createHarvestEffect(plot) {
            // Create floating score animation
            const effect = {
                x: plot.x,
                y: plot.y + 2,
                z: plot.z,
                timer: 0,
                duration: 2000,
                type: 'harvest'
            };
            
            // Add to effects array (we'll create this)
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function updateEffects(deltaTime) {
            if (!window.gameEffects) return;
            
            // Update and remove expired effects
            window.gameEffects = window.gameEffects.filter(effect => {
                effect.timer += deltaTime;
                effect.y += deltaTime * 0.001; // Float upward
                
                return effect.timer < effect.duration;
            });
        }
        
        function renderEffects() {
            if (!window.gameEffects) return;
            
            window.gameEffects.forEach(effect => {
                const alpha = 1 - (effect.timer / effect.duration);
                ctx.save();
                ctx.globalAlpha = alpha;
                
                const projected = project3D(effect.x, effect.y, effect.z);
                
                if (effect.type === 'harvest') {
                    ctx.fillStyle = '#4CAF50';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('+1', projected.x, projected.y);
                } else if (effect.type === 'plant' || effect.type === 'water' || effect.type === 'unlock') {
                    // Action effects with emoji
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(effect.emoji, projected.x, projected.y);
                    
                    // Add action name below emoji
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    let actionName = '';
                    if (effect.type === 'plant') actionName = 'Planted!';
                    else if (effect.type === 'water') actionName = 'Watered!';
                    else if (effect.type === 'unlock') actionName = 'Unlocked!';
                    
                    ctx.strokeText(actionName, projected.x, projected.y + 20);
                    ctx.fillText(actionName, projected.x, projected.y + 20);
                }
                
                ctx.restore();
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }
        
        function updateUI() {
            // Update score and coins
            document.getElementById('score').textContent = `Score: ${score}`;
            document.getElementById('coins').textContent = coins;
            
            // Update inventory
            document.getElementById('carrotCount').textContent = `🥕 Carrots: ${inventory.carrot || 0}`;
            document.getElementById('tomatoCount').textContent = `🍅 Tomatoes: ${inventory.tomato || 0}`;
            document.getElementById('rareCount').textContent = `✨ Rare Plants: ${inventory.rare || 0}`;
            document.getElementById('potatoCount').textContent = `🥔 Potatoes: ${inventory.potato || 0}`;
            document.getElementById('cabbageCount').textContent = `🥬 Cabbages: ${inventory.cabbage || 0}`;
            document.getElementById('cornCount').textContent = `🌽 Corn: ${inventory.corn || 0}`;
            document.getElementById('watermelonCount').textContent = `🍉 Watermelons: ${inventory.watermelon || 0}`;
            document.getElementById('pumpkinCount').textContent = `🎃 Pumpkins: ${inventory.pumpkin || 0}`;
            document.getElementById('appleCount').textContent = `🍎 Apples: ${inventory.apple || 0}`;
            
            // Update animal product inventory
            document.getElementById('eggInventory').textContent = `🥚 Eggs: ${animalInventory.eggs || 0}`;
            document.getElementById('milkInventory').textContent = `🥛 Milk: ${animalInventory.milk || 0}`;
            document.getElementById('truffleInventory').textContent = `🍄 Truffles: ${animalInventory.truffles || 0}`;
            
            // Update equipment inventory
            document.getElementById('sprinklerCount').textContent = `💧 Auto Sprinklers: ${equipment.sprinkler}`;
            document.getElementById('fertilizerCount').textContent = `🌿 Fertilizer: ${equipment.fertilizer}`;
            document.getElementById('greenhouseCount').textContent = `🏠 Greenhouses: ${equipment.greenhouse}`;
            
            // Update plant buttons availability based on season and seeds
            document.querySelectorAll('.plant-btn').forEach(btn => {
                const plantType = btn.dataset.plant;
                if (!plantType || !seedInventory.hasOwnProperty(plantType)) return;
                
                const hasSeeds = (seedInventory[plantType] || 0) > 0;
                const inSeason = currentSeason.availableCrops.includes(plantType);
                const available = hasSeeds && inSeason;
                
                btn.disabled = !available;
                btn.style.opacity = available ? '1' : '0.5';
                
                // Update button text with seed count and season availability
                const plantConfig = PLANT_TYPES[plantType];
                if (plantConfig) {
                    let buttonText = `${plantConfig.emoji} ${plantConfig.name} (${seedInventory[plantType] || 0})`;
                    if (!inSeason) {
                        buttonText += ` ❄️`;
                    }
                    btn.textContent = buttonText;
                }
            });
            
            // Update equipment buttons availability
            const sprinklerBtn = document.getElementById('sprinklerBtn');
            const fertilizerBtn = document.getElementById('fertilizerBtn');
            const greenhouseBtn = document.getElementById('greenhouseBtn');
            
            if (sprinklerBtn) {
                sprinklerBtn.disabled = coins < 150;
                sprinklerBtn.style.opacity = coins >= 150 ? '1' : '0.5';
            }
            if (fertilizerBtn) {
                fertilizerBtn.disabled = coins < 50;
                fertilizerBtn.style.opacity = coins >= 50 ? '1' : '0.5';
            }
            if (greenhouseBtn) {
                greenhouseBtn.disabled = coins < 300;
                greenhouseBtn.style.opacity = coins >= 300 ? '1' : '0.5';
            }
            
            // Update marketplace with dynamic prices
            updateMarketplaceUI();
            
            // Update new panels
            updateAnimalsUI();
        }
        
        function updateObjectives() {
            // Update objective displays
            document.getElementById('objective1').textContent = 
                `🥕 Harvest 5 carrots (${Math.min(objectives.carrotsHarvested, 5)}/5)`;
            document.getElementById('objective2').textContent = 
                `🌙 Survive 2 day/night cycles (${Math.min(objectives.dayNightCycles, 2)}/2)`;
            document.getElementById('objective3').textContent = 
                `💰 Earn 20 coins (${Math.min(objectives.coinsEarned, 20)}/20)`;
            document.getElementById('objective4').textContent = 
                `🌾 Harvest 25 total plants (${Math.min(objectives.plantsHarvested, 25)}/25)`;
            document.getElementById('objective5').textContent = 
                `🔧 Buy any equipment (${Math.min(objectives.equipmentBought, 1)}/1)`;
            document.getElementById('objective6').textContent = 
                `💰 Earn 500 coins (${Math.min(objectives.coinsEarned, 500)}/500)`;
            document.getElementById('objective7').textContent = 
                `🌱 Plant 50 seeds (${Math.min(objectives.seedsPlanted, 50)}/50)`;
            document.getElementById('objective8').textContent = 
                `🏆 Unlock all plots (${Math.min(objectives.plotsUnlocked, 25)}/25)`;
                
            // Check for completed objectives and show new ones
            if (objectives.carrotsHarvested >= 5 && objectives.dayNightCycles >= 2 && objectives.coinsEarned >= 20) {
                document.getElementById('objective1').style.color = '#4CAF50';
                document.getElementById('objective2').style.color = '#4CAF50';
                document.getElementById('objective3').style.color = '#4CAF50';
                
                // Show next tier objectives
                document.getElementById('objective4').style.display = 'block';
                document.getElementById('objective5').style.display = 'block';
            }
            
            if (objectives.plantsHarvested >= 25 && objectives.equipmentBought >= 1) {
                document.getElementById('objective4').style.color = '#4CAF50';
                document.getElementById('objective5').style.color = '#4CAF50';
                
                // Show final tier objectives
                document.getElementById('objective6').style.display = 'block';
                document.getElementById('objective7').style.display = 'block';
                document.getElementById('objective8').style.display = 'block';
            }
            
            if (objectives.coinsEarned >= 500) {
                document.getElementById('objective6').style.color = '#4CAF50';
            }
            if (objectives.seedsPlanted >= 50) {
                document.getElementById('objective7').style.color = '#4CAF50';
            }
            if (objectives.plotsUnlocked >= 25) {
                document.getElementById('objective8').style.color = '#4CAF50';
            }
        }
        
        // Marketplace functions with dynamic pricing
        function getDynamicPrice(plantType, action = 'sell') {
            const basePrice = PLANT_TYPES[plantType].value;
            let priceMultiplier = 1.0;
            
            // Weather effects on prices
            if (currentWeather.type === 'rainy' || currentWeather.type === 'stormy') {
                // High demand during bad weather
                priceMultiplier *= 1.3;
            } else if (currentWeather.type === 'sunny') {
                // Normal demand during good weather
                priceMultiplier *= 1.1;
            }
            
            // Season effects on prices
            if (currentSeason.availableCrops.includes(plantType)) {
                // In-season crops have lower prices (more supply)
                priceMultiplier *= 0.9;
            } else {
                // Out-of-season crops have higher prices (less supply)
                priceMultiplier *= 1.4;
            }
            
            // Different multiplier for seed purchases vs selling
            if (action === 'buy') {
                priceMultiplier *= 1.2; // Seeds cost more than selling price
            }
            
            return Math.ceil(basePrice * priceMultiplier);
        }
        
        function sellAll(plantType) {
            const count = inventory[plantType];
            if (count <= 0) return;
            
            const price = getDynamicPrice(plantType, 'sell');
            const earnings = count * price;
            
            inventory[plantType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            // Update quest progress
            updateQuestProgress('coins', earnings);
            
            updateUI();
            updateObjectives();
            updateMarketplaceUI();
            saveGame(); // Auto-save after selling
        }
        
        function sellAnimalProduct(productType) {
            const count = animalInventory[productType];
            if (count <= 0) return;
            
            let price = 0;
            if (productType === 'eggs') price = 2;
            else if (productType === 'milk') price = 5;
            else if (productType === 'truffles') price = 8;
            
            const earnings = count * price;
            
            animalInventory[productType] = 0;
            coins += earnings;
            objectives.coinsEarned += earnings;
            
            // Update quest progress
            updateQuestProgress('coins', earnings);
            
            updateUI();
            updateObjectives();
            updateMarketplaceUI();
            saveGame(); // Auto-save after selling
        }
        
        function buySeeds(plantType, baseCost) {
            const dynamicCost = getDynamicPrice(plantType, 'buy');
            if (coins >= dynamicCost) {
                coins -= dynamicCost;
                seedInventory[plantType] += 5; // Buy 5 seeds at a time
                updateUI();
                updateMarketplaceUI();
                saveGame(); // Auto-save after buying seeds
            }
        }
        
        function updateMarketplaceUI() {
            // Update sell buttons with dynamic prices for all plants
            const allPlantTypes = ['carrot', 'tomato', 'rare', 'potato', 'cabbage', 'corn', 'watermelon', 'pumpkin', 'apple'];
            allPlantTypes.forEach(plantType => {
                const price = getDynamicPrice(plantType, 'sell');
                const plantConfig = PLANT_TYPES[plantType];
                const sellBtn = document.getElementById(`sell${plantType.charAt(0).toUpperCase() + plantType.slice(1)}Btn`);
                if (sellBtn && plantConfig) {
                    sellBtn.textContent = `Sell ${plantConfig.name}s (${price}💰)`;
                    const count = inventory[plantType] || 0;
                    sellBtn.disabled = count <= 0;
                    sellBtn.style.opacity = count > 0 ? '1' : '0.5';
                }
            });
            
            // Update animal product sell buttons
            const animalProducts = ['eggs', 'milk', 'truffles'];
            const animalPrices = { eggs: 2, milk: 5, truffles: 8 };
            animalProducts.forEach(productType => {
                const price = animalPrices[productType];
                const sellBtn = document.getElementById(`sell${productType.charAt(0).toUpperCase() + productType.slice(1)}Btn`);
                if (sellBtn) {
                    const count = animalInventory[productType] || 0;
                    sellBtn.textContent = `Sell ${productType.charAt(0).toUpperCase() + productType.slice(1)} (${price}💰 each) [${count}]`;
                    sellBtn.disabled = count <= 0;
                    sellBtn.style.opacity = count > 0 ? '1' : '0.5';
                }
            });
            
            // Update seed purchase buttons with dynamic prices for all plants
            allPlantTypes.forEach(plantType => {
                const price = getDynamicPrice(plantType, 'buy');
                const plantConfig = PLANT_TYPES[plantType];
                const buyBtn = document.getElementById(`buy${plantType.charAt(0).toUpperCase() + plantType.slice(1)}SeedsBtn`);
                if (buyBtn && plantConfig) {
                    buyBtn.textContent = `Buy ${plantConfig.name} Seeds (${price}💰)`;
                    buyBtn.disabled = coins < price;
                    buyBtn.style.opacity = coins >= price ? '1' : '0.5';
                }
            });
        }
        
        function buyItem(itemType, cost) {
            if (coins >= cost) {
                coins -= cost;
                equipment[itemType]++;
                objectives.equipmentBought++;
                
                // Special handling for different equipment
                if (itemType === 'sprinkler') {
                    // Player needs to place the sprinkler
                    selectedEquipment = 'sprinkler';
                    canvas.style.cursor = 'crosshair';
                    showInstruction('Click on a plot to place the Auto Sprinkler!', 3000);
                } else if (itemType === 'fertilizer') {
                    // Fertilizer is applied automatically to all plants
                    showInstruction('Fertilizer pack applied! All plants grow 20% faster.', 2000);
                } else if (itemType === 'greenhouse') {
                    // Greenhouse provides passive benefits
                    showInstruction('Mini Greenhouse built! Plants grow better day and night.', 2000);
                }
                
                updateUI();
                updateObjectives();
                saveGame(); // Auto-save after buying equipment
            }
        }
        
        function showInstruction(text, duration) {
            // Create a temporary instruction overlay
            const instruction = document.createElement('div');
            instruction.style.position = 'absolute';
            instruction.style.top = '50%';
            instruction.style.left = '50%';
            instruction.style.transform = 'translate(-50%, -50%)';
            instruction.style.background = 'rgba(0, 0, 0, 0.8)';
            instruction.style.color = 'white';
            instruction.style.padding = '15px 25px';
            instruction.style.borderRadius = '10px';
            instruction.style.fontSize = '18px';
            instruction.style.zIndex = '200';
            instruction.style.border = '2px solid #4CAF50';
            instruction.textContent = text;
            
            document.body.appendChild(instruction);
            
            setTimeout(() => {
                document.body.removeChild(instruction);
            }, duration);
        }
        
        function updateDayNightCycle() {
            const oldProgress = (Math.sin(dayNightCycle) + 1) / 2;
            dayNightCycle += 0.01;
            const newProgress = (Math.sin(dayNightCycle) + 1) / 2;
            
            // Check for day/night cycle completion
            if (oldProgress > 0.5 && newProgress <= 0.5) {
                dayNightCycleCount++;
                objectives.dayNightCycles = dayNightCycleCount;
                updateObjectives();
            }
            
            // Calculate day/night progression
            const dayProgress = newProgress;
            const isDay = dayProgress > 0.5;
            
            // Update time display
            document.getElementById('timeDisplay').textContent = isDay ? 'Day' : 'Night';
            
            // Update background color
            const dayColor = { r: 135, g: 206, b: 235 }; // Sky blue
            const nightColor = { r: 25, g: 25, b: 112 }; // Midnight blue
            
            const r = Math.floor(dayColor.r + (nightColor.r - dayColor.r) * (1 - dayProgress));
            const g = Math.floor(dayColor.g + (nightColor.g - dayColor.g) * (1 - dayProgress));
            const b = Math.floor(dayColor.b + (nightColor.b - dayColor.b) * (1 - dayProgress));
            
            document.body.style.background = `rgb(${r}, ${g}, ${b})`;
        }
        
        function updatePlantGrowth(deltaTime) {
            const currentTime = Date.now();
            const dayProgress = (Math.sin(dayNightCycle) + 1) / 2;
            const isDay = dayProgress > 0.5;
            
            // Auto-sprinkler functionality - deterministic timing
            activeSprinklers.forEach(sprinkler => {
                // Check if 5 seconds have passed since last sprinkle
                if (currentTime - sprinkler.lastSprinkleTime >= 5000) {
                    plots.forEach(plot => {
                        if (plot.stage !== PLANT_STAGES.EMPTY) {
                            const distance = Math.sqrt(
                                Math.pow(plot.x - sprinkler.x, 2) + 
                                Math.pow(plot.z - sprinkler.z, 2)
                            );
                            
                            if (distance <= sprinkler.range && plot.waterLevel < 0.8) {
                                plot.waterLevel = Math.min(1.0, plot.waterLevel + 0.3);
                                plot.lastWatered = currentTime;
                                
                                // Create water effect
                                createWaterEffect(plot);
                            }
                        }
                    });
                    
                    // Update last sprinkle time
                    sprinkler.lastSprinkleTime = currentTime;
                }
            });
            
            plots.forEach(plot => {
                if (plot.stage !== PLANT_STAGES.EMPTY && plot.stage !== PLANT_STAGES.MATURE) {
                    // Water decay/gain based on weather
                    const deltaTimeSeconds = deltaTime / 1000;
                    let waterChange = currentWeather.waterDecayMultiplier * waterDecayRate * deltaTimeSeconds;
                    
                    // If weather has negative water decay (rain), plants gain water
                    if (currentWeather.waterDecayMultiplier < 0) {
                        plot.waterLevel = Math.min(1.0, plot.waterLevel - waterChange);
                    } else {
                        plot.waterLevel = Math.max(0, plot.waterLevel - waterChange);
                    }
                    
                    // Get plant configuration
                    const plantConfig = PLANT_TYPES[plot.plantType];
                    
                    // Calculate growth speed based on conditions
                    let growthMultiplier = 1;
                    
                    // Weather effects
                    growthMultiplier *= currentWeather.growthMultiplier;
                    
                    // Season effects
                    const seasonBonus = currentSeason.growthBonus[plot.plantType] || 1.0;
                    growthMultiplier *= seasonBonus;
                    
                    // Equipment bonuses
                    if (equipment.fertilizer > 0) {
                        growthMultiplier *= 1.2; // 20% faster growth with fertilizer
                    }
                    
                    if (equipment.greenhouse > 0) {
                        growthMultiplier *= 1.1; // 10% faster growth with greenhouse
                        // Greenhouse also provides weather protection
                        if (!isDay) growthMultiplier *= 1.2; // Better night growth
                    }
                    
                    // Day/night preference
                    if (plantConfig.dayPreference === isDay) {
                        growthMultiplier *= 1.5;
                    } else {
                        growthMultiplier *= 0.7;
                    }
                    
                    // Water level affects growth
                    if (plot.waterLevel > plantConfig.waterNeed) {
                        growthMultiplier *= 1.2;
                    } else if (plot.waterLevel < plantConfig.waterNeed * 0.5) {
                        growthMultiplier *= 0.5;
                    }
                    
                    // Check for proximity bonus (plants grow faster near other plants)
                    const nearbyPlants = plots.filter(otherPlot => {
                        if (otherPlot === plot || otherPlot.stage === PLANT_STAGES.EMPTY) return false;
                        const distance = Math.sqrt(
                            Math.pow(plot.x - otherPlot.x, 2) + Math.pow(plot.z - otherPlot.z, 2)
                        );
                        return distance <= 4.5; // Adjacent plots
                    });
                    
                    if (nearbyPlants.length > 0) {
                        growthMultiplier *= (1 + nearbyPlants.length * 0.1);
                    }
                    
                    // Apply growth
                    plot.growthTimer += deltaTime * growthMultiplier;
                    
                    // Check if plant should grow
                    if (plot.growthTimer >= plantConfig.growthTime) {
                        growPlant(plot);
                    }
                    
                    // Check if plant should wither due to lack of water
                    if (plot.waterLevel <= 0 && plot.stage !== PLANT_STAGES.WITHERING) {
                        plot.stage = PLANT_STAGES.WITHERING;
                        // Store baseColor if not already stored, then darken
                        if (!plot.plant.baseColor) {
                            plot.plant.baseColor = plot.plant.color;
                        }
                        plot.plant.color = adjustColorBrightness(plot.plant.baseColor, 0.5);
                    }
                }
            });
        }
        
        function render() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw ground (larger now)
            drawPlane(0, 0, 0, 25, 25, colors.ground);
            
            // Draw plots and plants
            plots.forEach(plot => {
                if (!plot.unlocked) {
                    // Draw locked plot with different color
                    drawCube(plot.x, plot.y + 0.1, plot.z, 2, '#555555');
                    
                    // Draw unlock cost indicator
                    const projected = project3D(plot.x, plot.y + 1, plot.z);
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${plot.unlockCost}💰`, projected.x, projected.y);
                    return;
                }
                
                // Determine if plot should be highlighted
                const isHovered = hoveredPlot === plot;
                let plotColor = colors.plot;
                
                // Show different colors based on water level
                if (plot.stage !== PLANT_STAGES.EMPTY) {
                    if (plot.waterLevel < 0.3) {
                        plotColor = colors.dryPlot;
                    } else if (plot.waterLevel > 0.8) {
                        plotColor = adjustColorBrightness(colors.plot, 1.2);
                    }
                }
                
                if (isHovered) {
                    plotColor = colors.plotHover;
                }
                
                // Draw plot
                drawCube(plot.x, plot.y + 0.1, plot.z, 2, plotColor);
                
                // Draw plant if exists
                if (plot.plant) {
                    let plantColor = plot.plant.color;
                    
                    // Add glow effect for mature plants
                    if (plot.stage === PLANT_STAGES.MATURE && plot.plant.glow) {
                        const glowIntensity = 0.5 + 0.5 * Math.sin(Date.now() * 0.005);
                        plantColor = adjustColorBrightness(plot.plant.color, 1 + glowIntensity * 0.3);
                        
                        // Draw glow effect around mature plants
                        const glowSize = plot.plant.size * 1.3;
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, glowSize, '#FFFF00', false);
                        ctx.restore();
                    }
                    
                    if (isHovered) {
                        plantColor = adjustColorBrightness(plantColor, 1.3);
                    }
                    
                    drawCube(plot.x, plot.y + 0.2 + plot.plant.size/2, plot.z, plot.plant.size, plantColor);
                    
                    // Draw water level indicator for watered plants
                    if (plot.waterLevel > 0.8 && plot.stage !== PLANT_STAGES.EMPTY) {
                        ctx.save();
                        ctx.globalAlpha = 0.4;
                        drawCube(plot.x, plot.y + 0.15, plot.z, 2.2, colors.water, false);
                        ctx.restore();
                    }
                }
            });
            
            // Draw character
            drawCharacter();
            
            // Draw sprinklers
            drawSprinklers();
            
            // Add some decorative elements
            drawDecorations();
            
            // Render visual effects
            renderEffects();
        }
        
        function drawSprinklers() {
            activeSprinklers.forEach(sprinkler => {
                // Draw sprinkler base
                drawCube(sprinkler.x, sprinkler.y, sprinkler.z, 1, '#4169E1');
                
                // Draw sprinkler head
                drawCube(sprinkler.x, sprinkler.y + 0.5, sprinkler.z, 0.6, '#87CEEB');
                
                // Draw water effect if it's working (show for 1 second after sprinkle)
                if (Date.now() - sprinkler.lastSprinkleTime < 1000) {
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    
                    // Draw water spray area
                    const projected = project3D(sprinkler.x, sprinkler.y + 0.8, sprinkler.z);
                    const radiusScale = sprinkler.range * 10; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#87CEEB';
                    ctx.fill();
                    ctx.restore();
                }
            });
        }
        
        function drawDecorations() {
            // Add trees around the farm
            const trees = [
                { x: -12, y: 0, z: -12 },
                { x: 12, y: 0, z: -12 },
                { x: -12, y: 0, z: 12 },
                { x: 12, y: 0, z: 12 }
            ];
            
            trees.forEach(tree => {
                // Tree trunk
                drawCube(tree.x, tree.y + 0.5, tree.z, 1, '#8B4513');
                // Tree leaves
                drawCube(tree.x, tree.y + 1.5, tree.z, 2.5, '#228B22');
            });
            
            // Add rocks
            const rocks = [
                { x: -10, y: 0, z: 0 },
                { x: 10, y: 0, z: 0 },
                { x: 0, y: 0, z: -10 },
                { x: 0, y: 0, z: 10 }
            ];
            
            rocks.forEach(rock => {
                drawCube(rock.x, rock.y + 0.3, rock.z, 1.5, '#696969');
            });
            
            // Draw fences around the unlocked farm area
            const unlockedPlots = plots.filter(p => p.unlocked);
            if (unlockedPlots.length > 0) {
                const minX = Math.min(...unlockedPlots.map(p => p.x)) - 2;
                const maxX = Math.max(...unlockedPlots.map(p => p.x)) + 2;
                const minZ = Math.min(...unlockedPlots.map(p => p.z)) - 2;
                const maxZ = Math.max(...unlockedPlots.map(p => p.z)) + 2;
                
                // Draw fence posts
                for (let x = minX; x <= maxX; x += 4) {
                    drawCube(x, 0.4, minZ, 0.3, '#8B4513'); // North fence
                    drawCube(x, 0.4, maxZ, 0.3, '#8B4513'); // South fence
                }
                for (let z = minZ; z <= maxZ; z += 4) {
                    drawCube(minX, 0.4, z, 0.3, '#8B4513'); // West fence
                    drawCube(maxX, 0.4, z, 0.3, '#8B4513'); // East fence
                }
            }
        }
        
        function updateCharacter(deltaTime) {
            // Handle keyboard input for movement
            let moveX = 0;
            let moveZ = 0;
            
            // Desktop controls
            if (keys[controls.forward] || keys['ArrowUp']) moveZ -= 1;
            if (keys[controls.backward] || keys['ArrowDown']) moveZ += 1;
            if (keys[controls.left] || keys['ArrowLeft']) moveX -= 1;
            if (keys[controls.right] || keys['ArrowRight']) moveX += 1;
            
            // Mobile joystick controls
            if (mobileControlsEnabled && (joystickInput.x !== 0 || joystickInput.y !== 0)) {
                moveX += joystickInput.x;
                moveZ += joystickInput.y; // Note: Y axis is typically inverted for joysticks
            }
            
            // Normalize movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
                
                // Calculate target direction
                character.targetDirection = Math.atan2(moveX, moveZ);
                
                // Set target position
                character.targetX = character.x + moveX * character.speed * deltaTime;
                character.targetZ = character.z + moveZ * character.speed * deltaTime;
                
                // Constrain to farm area
                const maxDistance = 10;
                character.targetX = Math.max(-maxDistance, Math.min(maxDistance, character.targetX));
                character.targetZ = Math.max(-maxDistance, Math.min(maxDistance, character.targetZ));
                
                character.moving = true;
                character.currentAction = 'walking';
            } else {
                character.moving = false;
                if (character.currentAction === 'walking') {
                    character.currentAction = 'idle';
                }
            }
            
            // Smooth movement
            if (character.moving) {
                const lerpFactor = 0.1;
                character.x += (character.targetX - character.x) * lerpFactor;
                character.z += (character.targetZ - character.z) * lerpFactor;
            }
            
            // Smooth rotation
            const angleDiff = character.targetDirection - character.direction;
            let adjustedAngleDiff = angleDiff;
            
            // Handle angle wrapping
            if (adjustedAngleDiff > Math.PI) {
                adjustedAngleDiff -= 2 * Math.PI;
            } else if (adjustedAngleDiff < -Math.PI) {
                adjustedAngleDiff += 2 * Math.PI;
            }
            
            character.direction += adjustedAngleDiff * 0.1;
            
            // Update animation frame
            if (character.moving) {
                character.animationFrame += deltaTime * 0.01;
            }
            
            // Update action timer
            if (character.actionTimer > 0) {
                character.actionTimer -= deltaTime;
                if (character.actionTimer <= 0) {
                    character.currentAction = 'idle';
                }
            }
            
            // Update camera to follow character
            if (cameraFollowCharacter) {
                updateCameraFollow();
            }
            
            // Update character status display
            updateCharacterStatusDisplay();
        }
        
        function updateCharacterStatusDisplay() {
            const statusElement = document.getElementById('characterStatus');
            let statusText = `Character: ${character.currentAction.charAt(0).toUpperCase() + character.currentAction.slice(1)}`;
            
            // Add position info
            statusText += ` (${character.x.toFixed(1)}, ${character.z.toFixed(1)})`;
            
            // Add closest plot info
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                if (distance <= 2.5) {
                    statusText += ` - Near plot (${distance.toFixed(1)}m)`;
                }
            }
            
            statusElement.textContent = statusText;
            
            // Color code based on action
            if (character.currentAction === 'walking') {
                statusElement.style.color = '#87CEEB';
            } else if (character.currentAction === 'planting') {
                statusElement.style.color = '#32CD32';
            } else if (character.currentAction === 'watering') {
                statusElement.style.color = '#4169E1';
            } else {
                statusElement.style.color = '#FFD700';
            }
        }
        
        function updateCameraFollow() {
            // Smoothly lerp camera follow position to character position
            cameraFollowX += (character.x - cameraFollowX) * cameraFollowLerp;
            cameraFollowZ += (character.z - cameraFollowZ) * cameraFollowLerp;
        }
        
        function drawCharacter() {
            // Character body
            let characterColor = character.color;
            
            // Apply action-based color changes
            if (character.currentAction === 'planting') {
                characterColor = '#32CD32'; // Green for planting
            } else if (character.currentAction === 'watering') {
                characterColor = '#87CEEB'; // Light blue for watering
            }
            
            // Add walking animation bob
            let yOffset = 0;
            if (character.moving && character.currentAction === 'walking') {
                yOffset = Math.sin(character.animationFrame * 5) * 0.1;
            }
            
            // Draw character body
            drawCube(
                character.x, 
                character.y + character.size/2 + yOffset, 
                character.z, 
                character.size, 
                characterColor
            );
            
            // Draw character head
            drawCube(
                character.x, 
                character.y + character.size * 1.3 + yOffset, 
                character.z, 
                character.size * 0.6, 
                '#FDBCB4' // Skin color
            );
            
            // Draw direction indicator (small arrow)
            const arrowSize = 0.3;
            const arrowDistance = character.size * 0.8;
            const arrowX = character.x + Math.sin(character.direction) * arrowDistance;
            const arrowZ = character.z + Math.cos(character.direction) * arrowDistance;
            
            drawCube(arrowX, character.y + character.size + yOffset, arrowZ, arrowSize, '#FFD700');
            
            // Draw interaction radius for closest plot
            const closestPlot = findClosestPlot();
            if (closestPlot) {
                const distance = getDistanceToPlot(closestPlot);
                
                // Draw interaction radius
                if (distance <= 2.5) {
                    // Draw green circle around character to show interaction is possible
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    const projected = project3D(character.x, character.y + 0.1, character.z);
                    const radiusScale = 50; // Visual radius on screen
                    
                    ctx.beginPath();
                    ctx.arc(projected.x, projected.y, radiusScale, 0, Math.PI * 2);
                    ctx.fillStyle = '#4CAF50';
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw line to closest plot
                    ctx.save();
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#4CAF50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    
                    const plotProjected = project3D(closestPlot.x, closestPlot.y + 0.5, closestPlot.z);
                    ctx.beginPath();
                    ctx.moveTo(projected.x, projected.y);
                    ctx.lineTo(plotProjected.x, plotProjected.y);
                    ctx.stroke();
                    ctx.restore();
                    
                    // Show action hint above character
                    ctx.save();
                    ctx.fillStyle = '#FFFFFF';
                    ctx.strokeStyle = '#000000';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.lineWidth = 1;
                    
                    let actionText = '';
                    if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                        actionText = `⚡ ${getKeyDisplayName(controls.action)} to plant`;
                    } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                        actionText = `⚡ ${getKeyDisplayName(controls.action)} to harvest`;
                    } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                        actionText = `⚡ ${getKeyDisplayName(controls.action)} to unlock (${closestPlot.unlockCost}💰)`;
                    } else if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                        actionText = `💧 ${getKeyDisplayName(controls.water)} to water`;
                    }
                    
                    if (actionText) {
                        const textY = projected.y - 60;
                        ctx.strokeText(actionText, projected.x, textY);
                        ctx.fillText(actionText, projected.x, textY);
                    }
                    
                    ctx.restore();
                }
            }
        }
        
        function performCharacterAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage === PLANT_STAGES.EMPTY && closestPlot.unlocked) {
                    // Plant seed
                    plantSeedAtPlot(closestPlot);
                    character.currentAction = 'planting';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create planting effect
                    createActionEffect(character.x, character.y + 1, character.z, 'plant', '🌱');
                } else if (closestPlot.stage === PLANT_STAGES.MATURE) {
                    // Harvest plant
                    harvestPlant(closestPlot);
                    character.currentAction = 'planting'; // Reuse planting animation
                    character.actionTimer = 1000;
                    
                    // Create harvest effect
                    createActionEffect(character.x, character.y + 1, character.z, 'harvest', '✨');
                } else if (!closestPlot.unlocked && coins >= closestPlot.unlockCost) {
                    // Unlock plot
                    coins -= closestPlot.unlockCost;
                    closestPlot.unlocked = true;
                    objectives.plotsUnlocked++;
                    
                    // Play unlock sound
                    playActionSound('unlock');
                    
                    updateUI();
                    updateObjectives();
                    saveGame(); // Auto-save after unlocking plot
                    character.currentAction = 'planting';
                    character.actionTimer = 1000;
                    
                    // Create unlock effect
                    createActionEffect(character.x, character.y + 1, character.z, 'unlock', '🔓');
                }
            }
        }
        
        function performWateringAction() {
            // Find the closest plot to the character
            const closestPlot = findClosestPlot();
            
            if (closestPlot && getDistanceToPlot(closestPlot) <= 2.5) {
                if (closestPlot.stage !== PLANT_STAGES.EMPTY) {
                    waterPlot(closestPlot);
                    character.currentAction = 'watering';
                    character.actionTimer = 1000; // 1 second animation
                    
                    // Create watering effect
                    createActionEffect(character.x, character.y + 1, character.z, 'water', '💧');
                }
            }
        }
        
        function createActionEffect(x, y, z, type, emoji) {
            const effect = {
                x: x,
                y: y,
                z: z,
                timer: 0,
                duration: 1500,
                type: type,
                emoji: emoji,
                startY: y
            };
            
            if (!window.gameEffects) window.gameEffects = [];
            window.gameEffects.push(effect);
        }
        
        function findClosestPlot() {
            let closestPlot = null;
            let closestDistance = Infinity;
            
            plots.forEach(plot => {
                const distance = getDistanceToPlot(plot);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestPlot = plot;
                }
            });
            
            return closestPlot;
        }
        
        function getDistanceToPlot(plot) {
            return Math.sqrt(
                Math.pow(character.x - plot.x, 2) + 
                Math.pow(character.z - plot.z, 2)
            );
        }
        
        function plantSeedAtPlot(plot) {
            if (seedInventory[selectedPlantType] <= 0) {
                return; // No seeds available
            }
            
            plantSeed(plot, selectedPlantType);
        }
        
        // Game loop
        let lastTime = 0;
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Update character
            updateCharacter(deltaTime);
            
            // Update day/night cycle
            updateDayNightCycle();
            
            // Update new systems
            updateWeather(deltaTime);
            updateSeason(deltaTime);
            updateAnimals(deltaTime);
            
            // Update plant growth with new weather/season effects
            updatePlantGrowth(deltaTime);
            
            // Update visual effects
            updateEffects(deltaTime);
            
            // Render scene
            render();
        }
        
        function onWindowResize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update mobile controls state
            const isMobile = window.innerWidth <= 768;
            const mobileControls = document.getElementById('mobileControls');
            
            if (isMobile && !mobileControlsEnabled) {
                mobileControlsEnabled = true;
                if (mobileControls) mobileControls.style.display = 'block';
                updateInstructionsForMobile();
            } else if (!isMobile && mobileControlsEnabled) {
                mobileControlsEnabled = false;
                if (mobileControls) mobileControls.style.display = 'none';
                updateInstructionsForDesktop();
            }
            
            // Update joystick center when window resizes
            if (mobileControlsEnabled) {
                setTimeout(updateJoystickCenter, 100);
            }
        }

        function updateInstructionsForMobile() {
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = `
                    🕹️ Use virtual joystick to move<br>
                    🌱 Green button to plant/harvest<br>
                    💧 Blue button to water plants<br>
                    📹 Purple button to toggle camera<br>
                    🔍 Pinch to zoom, drag to rotate camera<br>
                    🌿 Plants grow automatically (3 stages)<br>
                    🔒 Get close to plots and tap green button to unlock<br>
                    🌙 Watch the day/night cycle!
                `;
            }
        }

        function updateInstructionsForDesktop() {
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.innerHTML = `
                    🌱 Move with ZQSD or arrow keys<br>
                    ⚡ SPACE to plant/harvest at closest plot<br>
                    💧 E to water plants<br>
                    📹 C to toggle camera mode<br>
                    🌿 Plants grow automatically (3 stages)<br>
                    🔒 Unlock plots by getting close and pressing SPACE<br>
                    🌙 Watch the day/night cycle!<br>
                    🖱️ Drag to rotate camera view<br>
                    🔍 Scroll wheel to zoom in/out
                `;
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);

        // UI Dragging and Resizing System
        window.uiEditMode = false; // Make global for access
        let draggedPanel = null;
        let resizingPanel = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStartData = { x: 0, y: 0, width: 0, height: 0 };

        // Panel configuration - defines which panels are draggable
        const draggablePanels = [
            { id: 'ui', name: 'Info' },
            { id: 'plantSelector', name: 'Plants' },
            { id: 'inventory', name: 'Inventory' },
            { id: 'marketplace', name: 'Market' },
            { id: 'objectives', name: 'Goals' },
            { id: 'weatherPanel', name: 'Weather' },
            { id: 'seasonPanel', name: 'Season' },
            { id: 'animalsPanel', name: 'Animals' },
            { id: 'questsPanel', name: 'Quests' }
        ];

        function initDraggableUI() {
            // Add UI mode toggle functionality
            const uiModeToggle = document.getElementById('uiModeToggle');
            uiModeToggle.addEventListener('click', toggleUIEditMode);

            // Setup each draggable panel
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    setupDraggablePanel(panel, panelConfig.name);
                }
            });

            // Load saved panel positions and sizes
            loadPanelStates();

            // Add global mouse event listeners
            document.addEventListener('mousemove', handleGlobalMouseMove);
            document.addEventListener('mouseup', handleGlobalMouseUp);
        }

        function setupDraggablePanel(panel, name) {
            // Add draggable class
            panel.classList.add('draggable-panel');

            // Create drag handle
            const dragHandle = document.createElement('div');
            dragHandle.className = 'drag-handle';
            dragHandle.textContent = name;
            panel.appendChild(dragHandle);

            // Create resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            panel.appendChild(resizeHandle);

            // Add panel content wrapper if needed
            const children = Array.from(panel.children).filter(child => 
                !child.classList.contains('drag-handle') && !child.classList.contains('resize-handle')
            );
            
            if (children.length > 0 && !panel.querySelector('.panel-content')) {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'panel-content';
                children.forEach(child => contentWrapper.appendChild(child));
                panel.appendChild(contentWrapper);
            }

            // Add event listeners
            dragHandle.addEventListener('mousedown', (e) => startDragging(e, panel));
            resizeHandle.addEventListener('mousedown', (e) => startResizing(e, panel));

            // Prevent default drag behavior
            dragHandle.addEventListener('dragstart', (e) => e.preventDefault());
        }

        function toggleUIEditMode() {
            window.uiEditMode = !window.uiEditMode;
            const toggle = document.getElementById('uiModeToggle');
            
            if (window.uiEditMode) {
                toggle.classList.add('active');
                toggle.textContent = '✅ UI Mode';
                document.body.style.cursor = 'default';
                
                // Show all drag handles
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    if (panel) {
                        panel.style.border = '2px dashed rgba(76, 175, 80, 0.5)';
                        const handle = panel.querySelector('.drag-handle');
                        if (handle) {
                            handle.style.opacity = '1';
                            handle.style.visibility = 'visible';
                        }
                        const resizeHandle = panel.querySelector('.resize-handle');
                        if (resizeHandle) {
                            resizeHandle.style.opacity = '1';
                            resizeHandle.style.visibility = 'visible';
                        }
                    }
                });
                
                showInstruction('UI Edit Mode ON - Drag panels by their handles, resize from bottom-right corner', 3000);
            } else {
                toggle.classList.remove('active');
                toggle.textContent = '🔧 UI Mode';
                
                // Hide drag handles
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    if (panel) {
                        panel.style.border = '2px solid transparent';
                        const handle = panel.querySelector('.drag-handle');
                        if (handle) {
                            handle.style.opacity = '0';
                            handle.style.visibility = 'hidden';
                        }
                        const resizeHandle = panel.querySelector('.resize-handle');
                        if (resizeHandle) {
                            resizeHandle.style.opacity = '0';
                            resizeHandle.style.visibility = 'hidden';
                        }
                    }
                });
                
                showInstruction('UI Edit Mode OFF - Panels locked in position', 2000);
                savePanelStates();
            }
        }

        function startDragging(e, panel) {
            if (!window.uiEditMode) return;
            
            e.preventDefault();
            draggedPanel = panel;
            panel.classList.add('dragging');
            
            const rect = panel.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            // Bring panel to front
            panel.style.zIndex = '1000';
        }

        function startResizing(e, panel) {
            if (!window.uiEditMode) return;
            
            e.preventDefault();
            resizingPanel = panel;
            
            const rect = panel.getBoundingClientRect();
            resizeStartData = {
                x: e.clientX,
                y: e.clientY,
                width: rect.width,
                height: rect.height
            };
            
            panel.style.transition = 'none';
        }

        function handleGlobalMouseMove(e) {
            if (draggedPanel) {
                const newX = e.clientX - dragOffset.x;
                const newY = e.clientY - dragOffset.y;
                
                // Constrain to viewport
                const maxX = window.innerWidth - draggedPanel.offsetWidth;
                const maxY = window.innerHeight - draggedPanel.offsetHeight;
                
                const constrainedX = Math.max(0, Math.min(maxX, newX));
                const constrainedY = Math.max(0, Math.min(maxY, newY));
                
                draggedPanel.style.left = constrainedX + 'px';
                draggedPanel.style.top = constrainedY + 'px';
                draggedPanel.style.right = 'auto';
                draggedPanel.style.bottom = 'auto';
            }
            
            if (resizingPanel) {
                const deltaX = e.clientX - resizeStartData.x;
                const deltaY = e.clientY - resizeStartData.y;
                
                const newWidth = Math.max(150, resizeStartData.width + deltaX);
                const newHeight = Math.max(100, resizeStartData.height + deltaY);
                
                // Constrain to viewport
                const rect = resizingPanel.getBoundingClientRect();
                const maxWidth = window.innerWidth - rect.left;
                const maxHeight = window.innerHeight - rect.top;
                
                resizingPanel.style.width = Math.min(newWidth, maxWidth) + 'px';
                resizingPanel.style.height = Math.min(newHeight, maxHeight) + 'px';
            }
        }

        function handleGlobalMouseUp(e) {
            if (draggedPanel) {
                draggedPanel.classList.remove('dragging');
                draggedPanel.style.zIndex = '100';
                draggedPanel = null;
            }
            
            if (resizingPanel) {
                resizingPanel.style.transition = '';
                resizingPanel = null;
            }
        }

        function savePanelStates() {
            const panelStates = {};
            
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    const style = window.getComputedStyle(panel);
                    panelStates[panelConfig.id] = {
                        left: panel.style.left || style.left,
                        top: panel.style.top || style.top,
                        width: panel.style.width || style.width,
                        height: panel.style.height || style.height,
                        right: panel.style.right,
                        bottom: panel.style.bottom
                    };
                }
            });
            
            localStorage.setItem('pixelHarvestPanelStates', JSON.stringify(panelStates));
            console.log('Panel states saved');
        }

        function loadPanelStates() {
            try {
                const savedStates = localStorage.getItem('pixelHarvestPanelStates');
                if (!savedStates) return;
                
                const panelStates = JSON.parse(savedStates);
                
                draggablePanels.forEach(panelConfig => {
                    const panel = document.getElementById(panelConfig.id);
                    const state = panelStates[panelConfig.id];
                    
                    if (panel && state) {
                        // Apply saved position and size
                        if (state.left && state.left !== 'auto') {
                            panel.style.left = state.left;
                            panel.style.right = 'auto';
                        }
                        if (state.top && state.top !== 'auto') {
                            panel.style.top = state.top;
                            panel.style.bottom = 'auto';
                        }
                        if (state.width && state.width !== 'auto') {
                            panel.style.width = state.width;
                        }
                        if (state.height && state.height !== 'auto') {
                            panel.style.height = state.height;
                        }
                    }
                });
                
                console.log('Panel states loaded');
            } catch (e) {
                console.error('Failed to load panel states:', e);
            }
        }

        function resetPanelPositions() {
            draggablePanels.forEach(panelConfig => {
                const panel = document.getElementById(panelConfig.id);
                if (panel) {
                    panel.style.left = '';
                    panel.style.top = '';
                    panel.style.right = '';
                    panel.style.bottom = '';
                    panel.style.width = '';
                    panel.style.height = '';
                }
            });
            
            localStorage.removeItem('pixelHarvestPanelStates');
            showInstruction('Panel positions reset to defaults', 2000);
        }

        // Mobile Controls System
        let mobileControlsEnabled = false;
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickRadius = 60;
        let joystickInput = { x: 0, y: 0 };
        let touchStartPos = { x: 0, y: 0 };
        let lastTouchCameraPos = { x: 0, y: 0 };
        let cameraRotationTouch = false;

        function initMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            const joystick = document.getElementById('mobileJoystick');
            const joystickHandle = document.getElementById('joystickHandle');
            const actionBtn = document.getElementById('mobileActionBtn');
            const waterBtn = document.getElementById('mobileWaterBtn');
            const cameraBtn = document.getElementById('mobileCameraBtn');
            const zoomInBtn = document.getElementById('mobileZoomInBtn');
            const zoomOutBtn = document.getElementById('mobileZoomOutBtn');

            // Enhanced mobile device detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                            ('ontouchstart' in window) || 
                            (navigator.maxTouchPoints > 0) ||
                            (window.innerWidth <= 768);

            if (isMobile) {
                mobileControlsEnabled = true;
                mobileControls.style.display = 'block';
                
                // Update instructions for mobile
                updateInstructionsForMobile();
                
                // Add mobile-specific meta tag if not present
                if (!document.querySelector('meta[name="viewport"]')) {
                    const viewport = document.createElement('meta');
                    viewport.name = 'viewport';
                    viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                    document.head.appendChild(viewport);
                }
            }

            // Joystick event handlers
            if (joystick) {
                // Touch events
                joystick.addEventListener('touchstart', startJoystick, { passive: false });
                joystick.addEventListener('touchmove', moveJoystick, { passive: false });
                joystick.addEventListener('touchend', endJoystick, { passive: false });
                
                // Mouse events for testing on desktop
                joystick.addEventListener('mousedown', startJoystickMouse);
                joystick.addEventListener('mousemove', moveJoystickMouse);
                joystick.addEventListener('mouseup', endJoystickMouse);
                joystick.addEventListener('mouseleave', endJoystickMouse);
            }

            // Action button events
            if (actionBtn) {
                actionBtn.addEventListener('touchstart', () => performMobileAction('action'), { passive: true });
                actionBtn.addEventListener('click', () => performMobileAction('action'));
            }

            if (waterBtn) {
                waterBtn.addEventListener('touchstart', () => performMobileAction('water'), { passive: true });
                waterBtn.addEventListener('click', () => performMobileAction('water'));
            }

            if (cameraBtn) {
                cameraBtn.addEventListener('touchstart', () => performMobileAction('camera'), { passive: true });
                cameraBtn.addEventListener('click', () => performMobileAction('camera'));
            }

            if (zoomInBtn) {
                zoomInBtn.addEventListener('touchstart', () => performMobileAction('zoomIn'), { passive: true });
                zoomInBtn.addEventListener('click', () => performMobileAction('zoomIn'));
            }

            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('touchstart', () => performMobileAction('zoomOut'), { passive: true });
                zoomOutBtn.addEventListener('click', () => performMobileAction('zoomOut'));
            }

            // Touch gestures for camera control on canvas
            if (canvas) {
                canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleCanvasTouchEnd, { passive: false });
            }

            // Update joystick center position
            updateJoystickCenter();
        }

        function updateJoystickCenter() {
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) {
                const rect = joystick.getBoundingClientRect();
                joystickCenter.x = rect.left + rect.width / 2;
                joystickCenter.y = rect.top + rect.height / 2;
                joystickRadius = rect.width / 2 - 20; // Leave some margin
            }
        }

        // Joystick touch handlers
        function startJoystick(e) {
            e.preventDefault();
            joystickActive = true;
            const touch = e.touches[0];
            updateJoystickCenter();
            updateJoystickPosition(touch.clientX, touch.clientY);
            
            // Add visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.add('active');
            
            // Add haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
        }

        function moveJoystick(e) {
            e.preventDefault();
            if (!joystickActive) return;
            const touch = e.touches[0];
            updateJoystickPosition(touch.clientX, touch.clientY);
        }

        function endJoystick(e) {
            e.preventDefault();
            joystickActive = false;
            resetJoystickPosition();
            
            // Remove visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.remove('active');
        }

        // Joystick mouse handlers (for desktop testing)
        function startJoystickMouse(e) {
            joystickActive = true;
            updateJoystickCenter();
            updateJoystickPosition(e.clientX, e.clientY);
            
            // Add visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.add('active');
        }

        function moveJoystickMouse(e) {
            if (!joystickActive) return;
            updateJoystickPosition(e.clientX, e.clientY);
        }

        function endJoystickMouse(e) {
            joystickActive = false;
            resetJoystickPosition();
            
            // Remove visual feedback
            const joystick = document.getElementById('mobileJoystick');
            if (joystick) joystick.classList.remove('active');
        }

        function updateJoystickPosition(clientX, clientY) {
            const deltaX = clientX - joystickCenter.x;
            const deltaY = clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance <= joystickRadius) {
                // Inside joystick area
                joystickInput.x = deltaX / joystickRadius;
                joystickInput.y = deltaY / joystickRadius;
                
                const handle = document.getElementById('joystickHandle');
                if (handle) {
                    handle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                }
            } else {
                // Outside joystick area, clamp to edge
                const angle = Math.atan2(deltaY, deltaX);
                const clampedX = Math.cos(angle) * joystickRadius;
                const clampedY = Math.sin(angle) * joystickRadius;
                
                joystickInput.x = clampedX / joystickRadius;
                joystickInput.y = clampedY / joystickRadius;
                
                const handle = document.getElementById('joystickHandle');
                if (handle) {
                    handle.style.transform = `translate(${clampedX}px, ${clampedY}px)`;
                }
            }
        }

        function resetJoystickPosition() {
            joystickInput.x = 0;
            joystickInput.y = 0;
            const handle = document.getElementById('joystickHandle');
            if (handle) {
                handle.style.transform = 'translate(0px, 0px)';
            }
        }

        function performMobileAction(action) {
            // Add visual feedback
            const button = event.target;
            button.classList.add('touched');
            setTimeout(() => button.classList.remove('touched'), 200);

            // Add haptic feedback if supported
            if (navigator.vibrate) {
                navigator.vibrate(50); // Short vibration feedback
            }

            switch (action) {
                case 'action':
                    performCharacterAction();
                    break;
                case 'water':
                    performWateringAction();
                    break;
                case 'camera':
                    toggleCameraMode();
                    break;
                case 'zoomIn':
                    cameraDistance = Math.max(5, cameraDistance - 1);
                    break;
                case 'zoomOut':
                    cameraDistance = Math.min(20, cameraDistance + 1);
                    break;
            }
        }

        // Canvas touch handlers for camera control
        function handleCanvasTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - start camera rotation
                cameraRotationTouch = true;
                lastTouchCameraPos.x = e.touches[0].clientX;
                lastTouchCameraPos.y = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Two touches - prepare for pinch zoom
                cameraRotationTouch = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                touchStartPos.distance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }
        }

        function handleCanvasTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && cameraRotationTouch) {
                // Single touch - rotate camera
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastTouchCameraPos.x;
                const deltaY = touch.clientY - lastTouchCameraPos.y;
                
                // Apply camera rotation
                cameraAngleY += deltaX * 0.01;
                cameraAngleX = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngleX + deltaY * 0.01));
                
                lastTouchCameraPos.x = touch.clientX;
                lastTouchCameraPos.y = touch.clientY;
            } else if (e.touches.length === 2) {
                // Two touches - pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                if (touchStartPos.distance) {
                    const scale = currentDistance / touchStartPos.distance;
                    cameraDistance = Math.max(5, Math.min(20, cameraDistance / scale));
                    touchStartPos.distance = currentDistance;
                }
            }
        }

        function handleCanvasTouchEnd(e) {
            e.preventDefault();
            cameraRotationTouch = false;
            touchStartPos.distance = 0;
        }

        // Window resize handler for mobile
        function onWindowResizeMobile() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update mobile controls state
            const isMobile = window.innerWidth <= 768;
            const mobileControls = document.getElementById('mobileControls');
            
            if (isMobile && !mobileControlsEnabled) {
                mobileControlsEnabled = true;
                if (mobileControls) mobileControls.style.display = 'block';
            } else if (!isMobile && mobileControlsEnabled) {
                mobileControlsEnabled = false;
                if (mobileControls) mobileControls.style.display = 'none';
            }
            
            // Update joystick center when window resizes
            if (mobileControlsEnabled) {
                setTimeout(updateJoystickCenter, 100);
            }
        }

        // Initialize draggable UI when the game loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                initDraggableUI();
                initMobileControls();
            }, 100); // Small delay to ensure game is initialized
        });
    </script>
</body>
</html>